from __future__ import print_function
"""
Auto-generated type declaration to provide c-definitions for the cffi interface. It's highly unlikely you actually need this.
If you simply need a list of callbacks consult the manual in main PANDA.
"""
# NOTE: panda_datatypes.py is auto generated by the script create_panda_datatypes.py
# Please do not tinker with it!  Instead, fix the script that generates it

# update DATATYPES_VERSION and corresponding check in pandare.panda._do_types_import
# when this file changes and users will need to regenerate
DATATYPES_VERSION = 1.1

from enum import Enum
from ctypes import *
from collections import namedtuple

class PandaState(Enum):
    UNINT = 1
    INIT_DONE = 2
    IN_RECORD = 3
    IN_REPLAY = 4
    
PandaCB = namedtuple("PandaCB", "init \
before_block_translate \
after_block_translate \
before_block_exec_invalidate_opt \
before_tcg_codegen \
before_block_exec \
after_block_exec \
insn_translate \
insn_exec \
after_insn_translate \
after_insn_exec \
virt_mem_before_read \
virt_mem_before_write \
phys_mem_before_read \
phys_mem_before_write \
virt_mem_after_read \
virt_mem_after_write \
phys_mem_after_read \
phys_mem_after_write \
mmio_after_read \
mmio_before_write \
hd_read \
hd_write \
guest_hypercall \
monitor \
qmp \
cpu_restore_state \
before_loadvm \
asid_changed \
replay_hd_transfer \
replay_net_transfer \
replay_serial_receive \
replay_serial_read \
replay_serial_send \
replay_serial_write \
replay_before_dma \
replay_after_dma \
replay_handle_packet \
after_cpu_exec_enter \
before_cpu_exec_exit \
after_machine_init \
after_loadvm \
top_loop \
during_machine_init \
main_loop_wait \
pre_shutdown \
unassigned_io_read \
unassigned_io_write \
before_handle_exception \
before_handle_interrupt \
start_block_exec \
end_block_exec ")

def get_cb_docs():
    ''' Generate a PCB of (return type, arg type, docstring) '''
    return PandaCB(init = (None, None, None),
    before_block_translate = ('void', 'CPUState *env,  target_ptr_t pc', 'PANDA_CB_BEFORE_BLOCK_TRANSLATE\n\nbefore_block_translate:\nCalled before translation of each basic block.\n\nArguments:\nCPUState *env:   the current CPU state\ntarget_ptr_t pc: the guest PC we are about to translate\n\nHelper call location: cpu-exec.c\n\nReturn value:\nnone\n\nvoid (*before_block_translate)(CPUState *env, target_ptr_t pc);'),
    after_block_translate = ('void', 'CPUState *env,  TranslationBlock *tb', 'PANDA_CB_AFTER_BLOCK_TRANSLATE\n\nafter_block_translate:\nCalled after the translation of each basic block.\n\nArguments:\nCPUState *env:        the current CPU state\nTranslationBlock *tb: the TB we just translated\n\nHelper call location: cpu-exec.c\n\nReturn value:\nnone\n\nNotes:\nThis is a good place to perform extra passes over the generated\ncode (particularly by manipulating the LLVM code).\nFIXME: How would this actually work? By this point the out ASM\nhas already been generated. Modify the IR and then regenerate?\n\nvoid (*after_block_translate)(CPUState *env, TranslationBlock *tb);'),
    before_block_exec_invalidate_opt = ('bool', 'CPUState *env,  TranslationBlock *tb', 'PANDA_CB_BEFORE_BLOCK_EXEC_INVALIDATE_OPT\n\nbefore_block_exec_invalidate_opt:\nCalled before execution of every basic block, with the option\nto invalidate the TB.\n\nArguments:\nCPUState *env:        the current CPU state\nTranslationBlock *tb: the TB we are about to execute\n\nHelper call location: cpu-exec.c (indirectly)\n\nReturn value:\ntrue if we should invalidate the current translation block\nand retranslate, false otherwise.\n\nbool (*before_block_exec_invalidate_opt)(CPUState *env, TranslationBlock *tb);'),
    before_tcg_codegen = ('void', 'CPUState *env,  TranslationBlock *tb', 'PANDA_CB_BEFORE_TCG_CODEGEN\n\nbefore_tcg_codegen:\nCalled before host code generation for every basic block. Enables\ninspection and modification of the TCG block after lifting from guest\ncode.\n\nArguments:\nCPUState *env:        the current CPU state\nTranslationBlock *tb: the TB about to be compiled\n\nHelper call location: translate-all.c\n\nReturn value:\nNone\n\nvoid (*before_tcg_codegen)(CPUState *env, TranslationBlock *tb);'),
    before_block_exec = ('void', 'CPUState *env,  TranslationBlock *tb', 'PANDA_CB_BEFORE_BLOCK_EXEC\n\nbefore_block_exec:\nCalled before execution of every basic block.\n\nArguments:\nCPUState *env:        the current CPU state\nTranslationBlock *tb: the TB we are about to execute\n\nHelper call location: cpu-exec.c\n\nReturn value:\nnone\n\nvoid (*before_block_exec)(CPUState *env, TranslationBlock *tb);'),
    after_block_exec = ('void', 'CPUState *env,  TranslationBlock *tb,  uint8_t exitCode', 'PANDA_CB_AFTER_BLOCK_EXEC\n\nafter_block_exec:\nCalled after execution of every basic block.\nIf exitCode > TB_EXIT_IDX1, then the block exited early.\n\nArguments:\nCPUState *env:        the current CPU state\nTranslationBlock *tb: the TB we just executed\nuint8_t exitCode:     why the block execution exited\n\nHelper call location: cpu-exec.c\n\nReturn value:\nnone\n\nvoid (*after_block_exec)(CPUState *env, TranslationBlock *tb, uint8_t exitCode);'),
    insn_translate = ('bool', 'CPUState *env,  target_ptr_t pc', 'PANDA_CB_INSN_TRANSLATE\n\ninsn_translate:\nCalled before the translation of each instruction.\n\nArguments:\nCPUState *env:   the current CPU state\ntarget_ptr_t pc: the guest PC we are about to translate\n\nHelper call location: panda/target/ARCH/translate.c\n\nReturn value:\ntrue if PANDA should insert instrumentation into the generated code,\nfalse otherwise\n\nNotes:\nThis allows a plugin writer to instrument only a small number of\ninstructions, avoiding the performance hit of instrumenting everything.\nIf you do want to instrument every single instruction, just return\ntrue. See the documentation for PANDA_CB_INSN_EXEC for more detail.\n\nbool (*insn_translate)(CPUState *env, target_ptr_t pc);'),
    insn_exec = ('int', 'CPUState *env,  target_ptr_t pc', "PANDA_CB_INSN_EXEC\n\ninsn_exec:\nCalled before execution of any instruction identified by the\nPANDA_CB_INSN_TRANSLATE callback.\n\nArguments:\nCPUState *env:   the current CPU state\ntarget_ptr_t pc: the guest PC we are about to execute\n\nHelper call location: TBA\n\nReturn value:\nunused\n\nNotes:\nThis instrumentation is implemented by generating a call to a\nhelper function just before the instruction itself is generated.\nThis is fairly expensive, which is why it's only enabled via\nthe PANDA_CB_INSN_TRANSLATE callback.\n\nint (*insn_exec)(CPUState *env, target_ptr_t pc);"),
    after_insn_translate = ('bool', 'CPUState *env,  target_ptr_t pc', "PANDA_CB_AFTER_INSN_TRANSLATE\n\nafter_insn_translate:\nCalled after the translation of each instruction.\n\nArguments:\nCPUState *env:   the current CPU state\ntarget_ptr_t pc: the next guest PC we've translated\n\nHelper call location: panda/target/ARCH/translate.c\n\nReturn value:\ntrue if PANDA should insert instrumentation into the generated code,\nfalse otherwise\n\nNotes:\nSee `insn_translate`, callbacks are registered via PANDA_CB_AFTER_INSN_EXEC\n\nbool (*after_insn_translate)(CPUState *env, target_ptr_t pc);"),
    after_insn_exec = ('int', 'CPUState *env,  target_ptr_t pc', 'PANDA_CB_AFTER_INSN_EXEC\n\nafter_insn_exec:\nCalled after execution of an instruction identified by the\nPANDA_CB_AFTER_INSN_TRANSLATE callback\n\nArguments:\nCPUState *env:   the current CPU state\ntarget_ptr_t pc: the next guest PC already executed\n\nHelper call location: TBA\n\nReturn value:\nunused\n\nNotes:\nSee `insn_exec`. Enabled via the PANDA_CB_AFTER_INSN_TRANSLATE callback.\n\nint (*after_insn_exec)(CPUState *env, target_ptr_t pc);'),
    virt_mem_before_read = ('void', 'CPUState *env,  target_ptr_t pc,  target_ptr_t addr,  size_t size', 'PANDA_CB_VIRT_MEM_BEFORE_READ\n\nvirt_mem_before_read:\nCalled before memory is read.\n\nArguments:\nCPUState *env:     the current CPU state\ntarget_ptr_t pc:   the guest PC doing the read\ntarget_ptr_t addr: the (virtual) address being read\nsize_t size:       the size of the read\n\nHelper call location: TBA\n\nReturn value:\nnone\n\nvoid (*virt_mem_before_read)(CPUState *env, target_ptr_t pc, target_ptr_t addr, size_t size);'),
    virt_mem_before_write = ('void', 'CPUState *env,  target_ptr_t pc,  target_ptr_t addr,  size_t size,  uint8_t *buf', 'PANDA_CB_VIRT_MEM_BEFORE_WRITE\n\nvirt_mem_before_write:\nCalled before memory is written.\n\nArguments:\nCPUState *env:     the current CPU state\ntarget_ptr_t pc:   the guest PC doing the write\ntarget_ptr_t addr: the (virtual) address being written\nsize_t size:       the size of the write\nuint8_t *buf:      pointer to the data that is to be written\n\nHelper call location: TBA\n\nReturn value:\nnone\n\nvoid (*virt_mem_before_write)(CPUState *env, target_ptr_t pc, target_ptr_t addr, size_t size, uint8_t *buf);'),
    phys_mem_before_read = ('void', 'CPUState *env,  target_ptr_t pc,  target_ptr_t addr,  size_t size', 'PANDA_CB_PHYS_MEM_BEFORE_READ\n\nphys_mem_before_read:\nCalled after memory is read.\n\nArguments:\nCPUState *env:     the current CPU state\ntarget_ptr_t pc:   the guest PC doing the read\ntarget_ptr_t addr: the (physical) address being read\nsize_t size:       the size of the read\n\nHelper call location: TBA\n\nReturn value:\nnone\n\nvoid (*phys_mem_before_read)(CPUState *env, target_ptr_t pc, target_ptr_t addr, size_t size);'),
    phys_mem_before_write = ('void', 'CPUState *env,  target_ptr_t pc,  target_ptr_t addr,  size_t size,  uint8_t *buf', 'PANDA_CB_PHYS_MEM_BEFORE_WRITE\n\nphys_mem_write:\nCalled before memory is written.\n\nArguments:\nCPUState *env:     the current CPU state\ntarget_ptr_t pc:   the guest PC doing the write\ntarget_ptr_t addr: the (physical) address being written\nsize_t size:       the size of the write\nuint8_t *buf:      pointer to the data that is to be written\n\nHelper call location: TBA\n\nReturn value:\nnone\n\nvoid (*phys_mem_before_write)(CPUState *env, target_ptr_t pc, target_ptr_t addr, size_t size, uint8_t *buf);'),
    virt_mem_after_read = ('void', 'CPUState *env,  target_ptr_t pc,  target_ptr_t addr,  size_t size,  uint8_t *buf', 'PANDA_CB_VIRT_MEM_AFTER_READ\n\nvirt_mem_after_read:\nCalled after memory is read.\n\nArguments:\nCPUState *env:     the current CPU state\ntarget_ptr_t pc:   the guest PC doing the read\ntarget_ptr_t addr: the (virtual) address being read\nsize_t size:       the size of the read\nuint8_t *buf:      pointer to data just read\n\nHelper call location: TBA\n\nReturn value:\nnone\n\nvoid (*virt_mem_after_read)(CPUState *env, target_ptr_t pc, target_ptr_t addr, size_t size, uint8_t *buf);'),
    virt_mem_after_write = ('void', 'CPUState *env,  target_ptr_t pc,  target_ptr_t addr,  size_t size,  uint8_t *buf', 'PANDA_CB_VIRT_MEM_AFTER_WRITE\n\nvirt_mem_after_write:\nCalled after memory is written.\n\nArguments:\nCPUState *env:     the current CPU state\ntarget_ptr_t pc:   the guest PC doing the write\ntarget_ptr_t addr: the (virtual) address being written\nsize_t size:       the size of the write\nuint8_t *buf:      pointer to the data that was written\n\nHelper call location: TBA\n\nReturn value:\nnone\n\nvoid (*virt_mem_after_write)(CPUState *env, target_ptr_t pc, target_ptr_t addr, size_t size, uint8_t *buf);'),
    phys_mem_after_read = ('void', 'CPUState *env,  target_ptr_t pc,  target_ptr_t addr,  size_t size,  uint8_t *buf', 'PANDA_CB_PHYS_MEM_AFTER_READ\n\nphys_mem_after_read:\nCalled after memory is read.\n\nArguments:\nCPUState *env:     the current CPU state\ntarget_ptr_t pc:   the guest PC doing the read\ntarget_ptr_t addr: the (physical) address being read\nsize_t size:       the size of the read\nuint8_t *buf:      pointer to data just read\n\nHelper call location: TBA\n\nReturn value:\nnone\n\nvoid (*phys_mem_after_read)(CPUState *env, target_ptr_t pc, target_ptr_t addr, size_t size, uint8_t *buf);'),
    phys_mem_after_write = ('void', 'CPUState *env,  target_ptr_t pc,  target_ptr_t addr,  size_t size,  uint8_t *buf', 'PANDA_CB_PHYS_MEM_AFTER_WRITE\n\nphys_mem_write:\nCalled after memory is written.\n\nArguments:\nCPUState *env:     the current CPU state\ntarget_ptr_t pc:   the guest PC doing the write\ntarget_ptr_t addr: the (physical) address being written\nsize_t size:       the size of the write\nuint8_t *buf:      pointer to the data that was written\n\nHelper call location: TBA\n\nReturn value:\nnone\n\nvoid (*phys_mem_after_write)(CPUState *env, target_ptr_t pc, target_ptr_t addr, size_t size, uint8_t *buf);'),
    mmio_after_read = ('void', 'CPUState *env,  target_ptr_t physaddr,  target_ptr_t vaddr,  size_t size,  uint64_t *val', 'PANDA_CB_MMIO_AFTER_READ\n\nmmio_after_read:\nCalled after MMIO memory is read.\n\nArguments:\nCPUState *env:          the current CPU state\ntarget_ptr_t physaddr:  the physical address being read from\ntarget_ptr_t vaddr:     the virtual address being read from\nsize_t size:            the size of the read\nuin64_t *val:           the value being read\n\nHelper call location: cputlb.c\n\nReturn value:\nnone\n\nvoid (*mmio_after_read)(CPUState *env, target_ptr_t physaddr, target_ptr_t vaddr, size_t size, uint64_t *val);'),
    mmio_before_write = ('void', 'CPUState *env,  target_ptr_t physaddr,  target_ptr_t vaddr,  size_t size,  uint64_t *val', 'PANDA_CB_MMIO_BEFORE_WRITE\n\nmmio_before_write:\nCalled after MMIO memory is written to.\n\nArguments:\nCPUState *env:          the current CPU state\ntarget_ptr_t physaddr:  the physical address being written to\ntarget_ptr_t vaddr:     the virtual address being written to\nsize_t size:            the size of the write\nuin64_t *val:           the value being written\n\nHelper call location: cputlb.c\n\nReturn value:\nnone\n\nvoid (*mmio_before_write)(CPUState *env, target_ptr_t physaddr, target_ptr_t vaddr, size_t size, uint64_t *val);'),
    hd_read = ('void', 'CPUState *env', "PANDA_CB_HD_READ\nhd_read : called when there is a hard drive read\n\nNote: this was added to panda_cb_type enum but no callback prototype inserted\nHere is a stub.  I'm not sure what the args should be.\nArguments\nCPUState *env\n\n\nvoid (*hd_read)(CPUState *env);"),
    hd_write = ('void', 'CPUState *env', "PANDA_CB_HD_WRITE\nhd_write : called when there is a hard drive write\n\nNote: this was added to panda_cb_type enum but no callback prototype inserted\nHere is a stub.  I'm not sure what the args should be.\nArguments\nCPUState *env\n\n\nvoid (*hd_write)(CPUState *env);"),
    guest_hypercall = ('bool', 'CPUState *env', 'PANDA_CB_GUEST_HYPERCALL\n\nguest_hypercall:\nCalled when a program inside the guest makes a hypercall to pass\ninformation from inside the guest to a plugin\n\nArguments:\nCPUState *env: the current CPU state\n\nHelper call location: target/i386/misc_helper.c\n\nReturn value:\ntrue if the callback has processed the hypercall, false if the\nhypercall has been ignored.\n\nNotes:\nOn x86, this is called whenever CPUID is executed. On ARM, the\nMCR instructions is used. Plugins should check for magic values\nin the registers to determine if it really is a guest hypercall.\nParameters can be passed in other registers. If the plugin\nprocesses the hypercall, it should return true so the execution\nof the normal instruction is skipped.\n\nbool (*guest_hypercall)(CPUState *env);'),
    monitor = ('int', 'Monitor *mon,  const char *cmd', 'PANDA_CB_MONITOR\n\nmonitor:\nCalled when someone uses the plugin_cmd monitor command.\n\nArguments:\nMonitor *mon:    a pointer to the Monitor\nconst char *cmd: the command string passed to plugin_cmd\n\nHelper call location: TBA\n\nReturn value:\nunused\n\nNotes:\nThe command is passed as a single string. No parsing is performed\non the string before it is passed to the plugin, so each plugin\nmust parse the string as it deems appropriate (e.g. by using strtok\nand getopt) to do more complex option processing.\nIt is recommended that each plugin implementing this callback respond\nto the "help" message by listing the commands supported by the plugin.\nNote that every loaded plugin will have the opportunity to respond to\neach plugin_cmd; thus it is a good idea to ensure that your plugin\'s\nmonitor commands are uniquely named, e.g. by using the plugin name\nas a prefix ("sample_do_foo" rather than "do_foo").\n\nint (*monitor)(Monitor *mon, const char *cmd);'),
    qmp = ('bool', 'char *command,  char* args,  char **result', 'PANDA_CB_QMP\n\nqmp:\nCalled when someone sends an unhandled QMP command\n\nArguments:\nchar *command: the command string as json\nchar *args:    the arguments string as json\nchar **result: pointer to a json result or NULL\n\nHelper call location: TBA\n\nReturn value:\nbool: true IFF the command was handled by the plugin\n\nbool (*qmp)(char *command, char* args, char **result);'),
    cpu_restore_state = ('void', 'CPUState *env,  TranslationBlock *tb', 'PANDA_CB_CPU_RESTORE_STATE\n\ncpu_restore_state:\nCalled inside of cpu_restore_state(), when there is a CPU\nfault/exception.\n\nArguments:\nCPUState *env:        the current CPU state\nTranslationBlock *tb: the current translation block\n\nHelper call location: translate-all.c\n\nReturn value:\nnone\n\nvoid (*cpu_restore_state)(CPUState *env, TranslationBlock *tb);'),
    before_loadvm = ('int', 'void', "PANDA_CB_BEFORE_LOADVM\n\nbefore_loadvm:\nCalled at start of replay, before loadvm is called. This allows\nus to hook devices' loadvm handlers. Remember to unregister the\nexisting handler for the device first. See the example in the\nsample plugin.\n\nArguments:\nnone\n\nHelper call location: TBA\n\nReturn value:\nunused\n\nint (*before_loadvm)(void);"),
    asid_changed = ('bool', 'CPUState *env,  target_ptr_t oldval,  target_ptr_t newval', 'PANDA_CB_ASID_CHANGED\n\nasid_changed:\nCalled when asid changes.\n\nArguments:\nCPUState *env:       pointer to CPUState\ntarget_ptr_t oldval: old asid value\ntarget_ptr_t newval: new asid value\n\nHelper call location: target/i386/helper.c, target/arm/helper.c\n\nReturn value:\ntrue if the asid should be prevented from being changed\nfalse otherwise\n\nNotes:\nThe callback is only invoked implemented for x86 and ARM.\nThis should break plugins which rely on it to detect context\nswitches in any other architecture.\n\nbool (*asid_changed)(CPUState *env, target_ptr_t oldval, target_ptr_t newval);'),
    replay_hd_transfer = ('void', 'CPUState *env,  uint32_t type,  target_ptr_t src_addr,  target_ptr_t dest_addr,  size_t num_bytes', 'PANDA_CB_REPLAY_HD_TRANSFER,\n\nreplay_hd_transfer:\nIn replay only. Some kind of data transfer involving hard drive.\n\nArguments:\nCPUState *env:          pointer to CPUState\nuint32_t type:          type of transfer  (Hd_transfer_type)\ntarget_ptr_t src_addr:  address for src\ntarget_ptr_t dest_addr: address for dest\nsize_t num_bytes:       size of transfer in bytes\n\nHelper call location: panda/src/rr/rr_log.c\n\nReturn value:\nnone\n\nHelper call location: TBA\n\nNotes:\nUnlike most callbacks, this is neither a "before" or "after" callback.\nIn replay the transfer doesn\'t really happen. We are *at* the point at\nwhich it happened, really.\n\nvoid (*replay_hd_transfer)(CPUState *env, uint32_t type, target_ptr_t src_addr, target_ptr_t dest_addr, size_t num_bytes);'),
    replay_net_transfer = ('void', 'CPUState *env,  uint32_t type,  uint64_t src_addr,  uint64_t dest_addr,  size_t num_bytes', 'PANDA_CB_REPLAY_NET_TRANSFER,\n\nreplay_net_transfer:\nIn replay only, some kind of data transfer within the network card\n(currently, only the E1000 is supported).\n\nArguments:\nCPUState *env:          pointer to CPUState\nuint32_t type:          type of transfer  (Net_transfer_type)\nuint64_t src_addr:      address for src\nuint64_t dest_addr:     address for dest\nsize_t num_bytes:       size of transfer in bytes\n\nHelper call location: panda/src/rr/rr_log.c\n\nReturn value:\nnone\n\nNotes:\nUnlike most callbacks, this is neither a "before" or "after" callback.\nIn replay the transfer doesn\'t really happen. We are *at* the point at\nwhich it happened, really.\nAlso, the src_addr and dest_addr may be for either host (ie. a location\nin the emulated network device) or guest, depending upon the type.\n\nvoid (*replay_net_transfer)(CPUState *env, uint32_t type, uint64_t src_addr, uint64_t dest_addr, size_t num_bytes);'),
    replay_serial_receive = ('void', 'CPUState *env,  target_ptr_t fifo_addr,  uint8_t value', 'PANDA_CB_REPLAY_SERIAL_RECEIVE,\n\nreplay_serial_receive:\nIn replay only, called when a byte is received on the serial port.\n\nArguments:\nCPUState *env:          pointer to CPUState\ntarget_ptr_t fifo_addr: address of the data within the fifo\nuint8_t value:          value received\n\nHelper call location: panda/src/rr/rr_log.c\n\nReturn value:\nunused\n\nvoid (*replay_serial_receive)(CPUState *env, target_ptr_t fifo_addr, uint8_t value);'),
    replay_serial_read = ('void', 'CPUState *env,  target_ptr_t fifo_addr,  uint32_t port_addr,  uint8_t value', 'PANDA_CB_REPLAY_SERIAL_READ,\n\nreplay_serial_read:\nIn replay only, called when a byte read from the serial RX FIFO\n\nArguments:\nCPUState *env:          pointer to CPUState\ntarget_ptr_t fifo_addr: address of the data within the fifo (source)\nuint32_t port_addr:     address of the IO port where data is being read (destination)\nuint8_t value:          value read\n\nHelper call location: panda/src/rr/rr_log.c\n\nReturn value:\nnone\n\nvoid (*replay_serial_read)(CPUState *env, target_ptr_t fifo_addr, uint32_t port_addr, uint8_t value);'),
    replay_serial_send = ('void', 'CPUState *env,  target_ptr_t fifo_addr,  uint8_t value', 'PANDA_CB_REPLAY_SERIAL_SEND,\n\nreplay_serial_send:\nIn replay only, called when a byte is sent on the serial port.\n\nArguments:\nCPUState *env:          pointer to CPUState\ntarget_ptr_t fifo_addr: address of the data within the fifo\nuint8_t value:          value received\n\nHelper call location: panda/src/rr/rr_log.c\n\nReturn value:\nnone\n\nvoid (*replay_serial_send)(CPUState *env, target_ptr_t fifo_addr, uint8_t value);'),
    replay_serial_write = ('void', 'CPUState *env,  target_ptr_t fifo_addr,  uint32_t port_addr,  uint8_t value', 'PANDA_CB_REPLAY_SERIAL_WRITE,\n\nIn replay only, called when a byte written to the serial TX FIFO\n\nArguments:\nCPUState *env:          pointer to CPUState\ntarget_ptr_t fifo_addr: address of the data within the fifo (source)\nuint32_t port_addr:     address of the IO port where data is being read (destination)\nuint8_t value:          value read\n\nHelper call location: panda/src/rr/rr_log.c\n\nReturn value:\nnone\n\nvoid (*replay_serial_write)(CPUState *env, target_ptr_t fifo_addr, uint32_t port_addr, uint8_t value);'),
    replay_before_dma = ('void', 'CPUState *env,  const uint8_t *buf,  hwaddr addr,  size_t size,  bool is_write', "PANDA_CB_REPLAY_BEFORE_DMA,\n\nreplay_before_dma:\nIn replay only. We are about to dma between qemu buffer and\nguest memory.\n\nArguments:\nCPUState *env:      pointer to CPUState\nconst uint8_t *buf: pointer to the QEMU's device buffer ussed in the transfer\nhwaddr addr:        address written to in the guest RAM\nsize_t size:        size of transfer\nbool is_write:      indicates whether the DMA transfer writes to memory\n\nHelper call location: exec.c\n\nReturn value:\nnone\n\nvoid (*replay_before_dma)(CPUState *env, const uint8_t *buf, hwaddr addr, size_t size, bool is_write);"),
    replay_after_dma = ('void', 'CPUState *env,  const uint8_t *buf,  hwaddr addr,  size_t size,  bool is_write', "PANDA_CB_REPLAY_AFTER_DMA,\n\nIn replay only, we are about to dma between qemu buffer and guest memory\n\nArguments:\nCPUState *env:      pointer to CPUState\nconst uint8_t *buf: pointer to the QEMU's device buffer ussed in the transfer\nhwaddr addr:        address written to in the guest RAM\nsize_t size:        size of transfer\nbool is_write:      indicates whether the DMA transfer writes to memory\n\nHelper call location: exec.c\n\nReturn value:\nnone\n\nvoid (*replay_after_dma)(CPUState *env, const uint8_t *buf, hwaddr addr, size_t size, bool is_write);"),
    replay_handle_packet = ('void', 'CPUState *env,  uint8_t *buf,  size_t size,  uint8_t direction,  uint64_t buf_addr_rec', 'PANDA_CB_REPLAY_HANDLE_PACKET,\n\nIn replay only, we have a packet (incoming / outgoing) in hand.\n\nArguments:\nCPUState *env:         pointer to CPUState\nuint8_t *buf:          buffer containing packet data\nsize_t size:           num bytes in buffer\nuint8_t direction:     either `PANDA_NET_RX` or `PANDA_NET_TX`\nuint64_t buf_addr_rec: the address of `buf` at the time of recording\n\nHelper call location: panda/src/rr/rr_log.c\n\nReturn value:\nnone\n\nNotes:\n`buf_addr_rec` corresponds to the address of the device buffer of\nthe emulated NIC. I.e. it is the address of a VM-host-side buffer.\nIt is useful for implementing network tainting in an OS-agnostic\nway, in conjunction with taint2_label_io().\n\nFIXME: The `buf_addr_rec` maps to the `uint8_t *buf` field of the\ninternal `RR_handle_packet_args` struct. The field is dumped/loaded\nto/from the trace without proper serialization/deserialization. As\na result, a 64bit build of PANDA will not be able to process traces\nproduced by a 32bit of PANDA, and vice-versa.\nThere are more internal structs that suffer from the same issue.\nThis is an oversight that will eventually be fixed. But as the\nreal impact is minimal (virtually nobody uses 32bit builds),\nthe fix has a very low priority in the bugfix list.\n\nvoid (*replay_handle_packet)(CPUState *env, uint8_t *buf, size_t size, uint8_t direction, uint64_t buf_addr_rec);'),
    after_cpu_exec_enter = ('void', 'CPUState *env', 'PANDA_CB_AFTER_CPU_EXEC_ENTER\n\nafter_cpu_exec_enter:\nCalled after cpu_exec calls cpu_exec_enter function.\n\nArguments:\nCPUState *env: the current CPU state\n\nHelper call location: cpu-exec.c\n\nReturn value:\nnone\n\nvoid (*after_cpu_exec_enter)(CPUState *env);'),
    before_cpu_exec_exit = ('void', 'CPUState *env,  bool ranBlock', 'PANDA_CB_BEFORE_CPU_EXEC_EXIT\n\nbefore_cpu_exec_exit:\nCalled before cpu_exec calls cpu_exec_exit function.\n\nArguments:\nCPUState *env: the current CPU state\nbool ranBlock: true if ran a block since previous cpu_exec_enter\n\nHelper call location: cpu-exec.c\n\nReturn value:\nnone\n\nvoid (*before_cpu_exec_exit)(CPUState *env, bool ranBlock);'),
    after_machine_init = ('void', 'CPUState *env', 'PANDA_CB_AFTER_MACHINE_INIT\n\nafter_machine_init:\nCalled right after the machine has been initialized, but before\nany guest code runs.\n\nArguments:\nvoid *cpu_env: pointer to CPUState\n\nHelper call location: TBA\n\nReturn value:\nnone\n\nNotes:\nThis callback allows initialization of components that need\naccess to the RAM, CPU object, etc. E.g. for the taint2 plugin,\nthis is the appropriate place to call taint2_enable_taint().\n\nvoid (*after_machine_init)(CPUState *env);'),
    after_loadvm = ('void', 'CPUState *env', 'PANDA_CB_AFTER_LOADVM\n\nafter_loadvm:\nCalled right after a snapshot has been loaded (either with loadvm or replay initialization),\nbut before any guest code runs.\n\nArguments:\nvoid *cpu_env: pointer to CPUState\n\nReturn value:\nnone\n\n\nvoid (*after_loadvm)(CPUState *env);'),
    top_loop = ('void', 'CPUState *env', 'PANDA_CB_TOP_LOOP\n\ntop_loop:\nCalled at the top of the loop that manages emulation.\n\nArguments:\nCPUState *env:          pointer to CPUState\n\nHelper call location: cpus.c\n\nReturn value:\nunused\n\nvoid (*top_loop)(CPUState *env);'),
    during_machine_init = ('void', 'MachineState *machine', 'PANDA_CB_DURING_MACHINE_INIT\n\nduring_machine_init: Called in the middle of machine initialization\n\nArguments:\nMachineState *machine: pointer to the machine state\n\nReturn value:\nNone\n\n\nvoid (*during_machine_init)(MachineState *machine);'),
    main_loop_wait = ('void', 'void', 'PANDA_CB_MAIN_LOOP_WAIT\n\nmain_loop_wait: Called in IO thread in place where monitor cmds are processed\n\nArguments:\nNone\n\nReturn value:\nNone\n\n\nvoid (*main_loop_wait)(void);'),
    pre_shutdown = ('void', 'void', 'PANDA_CB_PRE_SHUTDOWN\n\npre_shutdown: Called just before qemu shuts down\n\nArguments:\nNone\n\nReturn value:\nNone\n\nvoid (*pre_shutdown)(void);'),
    unassigned_io_read = ('bool', 'CPUState *env,  target_ptr_t pc,  hwaddr addr,  size_t size,  uint64_t *val', 'PANDA_CB_UNASSIGNED_IO_READ\n\nunassigned_io_read: Called when the guest attempts to read from an unmapped peripheral via MMIO\n\nArguments:\npc: Guest program counter at time of write\naddr: Physical address written to\nsize: Size of write\nval: Pointer to a buffer that will be passed to the guest as the result of the read\n\nReturn value:\nTrue if value read was changed by a PANDA plugin and should be returned\nFalse if error-logic (invalid write) should be run\n\nbool (*unassigned_io_read)(CPUState *env, target_ptr_t pc, hwaddr addr, size_t size, uint64_t *val);'),
    unassigned_io_write = ('bool', 'CPUState *env,  target_ptr_t pc,  hwaddr addr,  size_t size,  uint64_t val', 'PANDA_CB_UNASSIGNED_IO_WRITE\n\nunassigned_io_write: Called when the guest attempts to write to an unmapped peripheral via MMIO\n\nArguments:\npc: Guest program counter at time of write\naddr: Physical address written to\nsize: Size of write\nval: Data being written, up to 8 bytes\n\nReturn value:\nTrue if the write should be allowed without error\nFalse if normal behavior should be used (error-logic)\n\nbool (*unassigned_io_write)(CPUState *env, target_ptr_t pc, hwaddr addr, size_t size, uint64_t val);'),
    before_handle_exception = ('int32_t', 'CPUState *cpu,  int32_t exception_index', 'PANDA_CB_BEFORE_HANDLE_EXCEPTION\n\nbefore_handle_exception: Called just before we are about to\nhandle an exception.\n\nNote: only called for cpu->exception_index > 0\n\nArguments:\nexception_index (the current exception number)\n\nReturn value:\na new exception_index.\n\nNote: There might be more than one callback for this location.\nFirst callback that returns an exception index that *differs*\nfrom the one passed as an arg wins. That is what we return as\nthe new exception index, which will replace\ncpu->exception_index\n\n\n\nint32_t (*before_handle_exception)(CPUState *cpu, int32_t exception_index);'),
    before_handle_interrupt = ('int32_t', 'CPUState *cpu,  int32_t interrupt_request', 'PANDA_CB_BEFORE_HANDLE_INTERRUPT\n\nbefore_handle_interrupt: Called just before we are about to\nhandle an interrupt.\n\nArguments:\ninterrupt request\n\nReturn value:\nnew interrupt_rquest\n\nNote: There might be more than one callback for this location.\nFirst callback that returns an interrupt_request that *differs*\nfrom the one passed as an arg wins.\n\n\n\n\nint32_t (*before_handle_interrupt)(CPUState *cpu, int32_t interrupt_request);'),
    start_block_exec = ('void', 'CPUState *cpu,  TranslationBlock* tb', 'PANDA_CB_START_BLOCK_EXEC\n\nstart_block_exec:\nThis is like before_block_exec except its part of the TCG stream.\n\nArguments:\nCPUState *env:        the current CPU state\nTranslationBlock *tb: the TB we are executing\n\nHelper call location: cpu-exec.c\n\nReturn value:\nnone\n\n\nvoid (*start_block_exec)(CPUState *cpu, TranslationBlock* tb);'),
    end_block_exec = ('void', 'CPUState *cpu,  TranslationBlock* tb', 'PANDA_CB_END_BLOCK_EXEC\n\nend_block_exec:\nThis is like after_block_exec except its part of the TCG stream.\n\nArguments:\nCPUState *env:        the current CPU state\nTranslationBlock *tb: the TB we are executing\n\nHelper call location: cpu-exec.c\n\nReturn value:\nnone\n\nvoid (*end_block_exec)(CPUState *cpu, TranslationBlock* tb);'))

def get_cbs(ffi):
    '''
    Returns (callback_dictory, pcb) tuple of ({callback name: CFFI func}, CFFI funcs)
    '''

    # So we need access to some data structures, but don't actually
    # want to open all of libpanda yet because we don't have all the
    # file information. So we just open libc to access this.
    C = ffi.dlopen(None)

    # Stores the names and numbers for callbacks
    pandacbtype = namedtuple("pandacbtype", "name number")

    pcb = PandaCB(init = ffi.callback("bool(void*)"),
    before_block_translate = ffi.callback("void (CPUState *env,  target_ptr_t pc)"),
    after_block_translate = ffi.callback("void (CPUState *env,  TranslationBlock *tb)"),
    before_block_exec_invalidate_opt = ffi.callback("bool (CPUState *env,  TranslationBlock *tb)"),
    before_tcg_codegen = ffi.callback("void (CPUState *env,  TranslationBlock *tb)"),
    before_block_exec = ffi.callback("void (CPUState *env,  TranslationBlock *tb)"),
    after_block_exec = ffi.callback("void (CPUState *env,  TranslationBlock *tb,  uint8_t exitCode)"),
    insn_translate = ffi.callback("bool (CPUState *env,  target_ptr_t pc)"),
    insn_exec = ffi.callback("int (CPUState *env,  target_ptr_t pc)"),
    after_insn_translate = ffi.callback("bool (CPUState *env,  target_ptr_t pc)"),
    after_insn_exec = ffi.callback("int (CPUState *env,  target_ptr_t pc)"),
    virt_mem_before_read = ffi.callback("void (CPUState *env,  target_ptr_t pc,  target_ptr_t addr,  size_t size)"),
    virt_mem_before_write = ffi.callback("void (CPUState *env,  target_ptr_t pc,  target_ptr_t addr,  size_t size,  uint8_t *buf)"),
    phys_mem_before_read = ffi.callback("void (CPUState *env,  target_ptr_t pc,  target_ptr_t addr,  size_t size)"),
    phys_mem_before_write = ffi.callback("void (CPUState *env,  target_ptr_t pc,  target_ptr_t addr,  size_t size,  uint8_t *buf)"),
    virt_mem_after_read = ffi.callback("void (CPUState *env,  target_ptr_t pc,  target_ptr_t addr,  size_t size,  uint8_t *buf)"),
    virt_mem_after_write = ffi.callback("void (CPUState *env,  target_ptr_t pc,  target_ptr_t addr,  size_t size,  uint8_t *buf)"),
    phys_mem_after_read = ffi.callback("void (CPUState *env,  target_ptr_t pc,  target_ptr_t addr,  size_t size,  uint8_t *buf)"),
    phys_mem_after_write = ffi.callback("void (CPUState *env,  target_ptr_t pc,  target_ptr_t addr,  size_t size,  uint8_t *buf)"),
    mmio_after_read = ffi.callback("void (CPUState *env,  target_ptr_t physaddr,  target_ptr_t vaddr,  size_t size,  uint64_t *val)"),
    mmio_before_write = ffi.callback("void (CPUState *env,  target_ptr_t physaddr,  target_ptr_t vaddr,  size_t size,  uint64_t *val)"),
    hd_read = ffi.callback("void (CPUState *env)"),
    hd_write = ffi.callback("void (CPUState *env)"),
    guest_hypercall = ffi.callback("bool (CPUState *env)"),
    monitor = ffi.callback("int (Monitor *mon,  const char *cmd)"),
    qmp = ffi.callback("bool (char *command,  char* args,  char **result)"),
    cpu_restore_state = ffi.callback("void (CPUState *env,  TranslationBlock *tb)"),
    before_loadvm = ffi.callback("int (void)"),
    asid_changed = ffi.callback("bool (CPUState *env,  target_ptr_t oldval,  target_ptr_t newval)"),
    replay_hd_transfer = ffi.callback("void (CPUState *env,  uint32_t type,  target_ptr_t src_addr,  target_ptr_t dest_addr,  size_t num_bytes)"),
    replay_net_transfer = ffi.callback("void (CPUState *env,  uint32_t type,  uint64_t src_addr,  uint64_t dest_addr,  size_t num_bytes)"),
    replay_serial_receive = ffi.callback("void (CPUState *env,  target_ptr_t fifo_addr,  uint8_t value)"),
    replay_serial_read = ffi.callback("void (CPUState *env,  target_ptr_t fifo_addr,  uint32_t port_addr,  uint8_t value)"),
    replay_serial_send = ffi.callback("void (CPUState *env,  target_ptr_t fifo_addr,  uint8_t value)"),
    replay_serial_write = ffi.callback("void (CPUState *env,  target_ptr_t fifo_addr,  uint32_t port_addr,  uint8_t value)"),
    replay_before_dma = ffi.callback("void (CPUState *env,  const uint8_t *buf,  hwaddr addr,  size_t size,  bool is_write)"),
    replay_after_dma = ffi.callback("void (CPUState *env,  const uint8_t *buf,  hwaddr addr,  size_t size,  bool is_write)"),
    replay_handle_packet = ffi.callback("void (CPUState *env,  uint8_t *buf,  size_t size,  uint8_t direction,  uint64_t buf_addr_rec)"),
    after_cpu_exec_enter = ffi.callback("void (CPUState *env)"),
    before_cpu_exec_exit = ffi.callback("void (CPUState *env,  bool ranBlock)"),
    after_machine_init = ffi.callback("void (CPUState *env)"),
    after_loadvm = ffi.callback("void (CPUState *env)"),
    top_loop = ffi.callback("void (CPUState *env)"),
    during_machine_init = ffi.callback("void (MachineState *machine)"),
    main_loop_wait = ffi.callback("void (void)"),
    pre_shutdown = ffi.callback("void (void)"),
    unassigned_io_read = ffi.callback("bool (CPUState *env,  target_ptr_t pc,  hwaddr addr,  size_t size,  uint64_t *val)"),
    unassigned_io_write = ffi.callback("bool (CPUState *env,  target_ptr_t pc,  hwaddr addr,  size_t size,  uint64_t val)"),
    before_handle_exception = ffi.callback("int32_t (CPUState *cpu,  int32_t exception_index)"),
    before_handle_interrupt = ffi.callback("int32_t (CPUState *cpu,  int32_t interrupt_request)"),
    start_block_exec = ffi.callback("void (CPUState *cpu,  TranslationBlock* tb)"),
    end_block_exec = ffi.callback("void (CPUState *cpu,  TranslationBlock* tb)"))


    callback_dictionary = {
        pcb.init : pandacbtype("init", -1),
        pcb.before_block_translate : pandacbtype("before_block_translate", C.PANDA_CB_BEFORE_BLOCK_TRANSLATE),
        pcb.after_block_translate : pandacbtype("after_block_translate", C.PANDA_CB_AFTER_BLOCK_TRANSLATE),
        pcb.before_block_exec_invalidate_opt : pandacbtype("before_block_exec_invalidate_opt", C.PANDA_CB_BEFORE_BLOCK_EXEC_INVALIDATE_OPT),
        pcb.before_tcg_codegen : pandacbtype("before_tcg_codegen", C.PANDA_CB_BEFORE_TCG_CODEGEN),
        pcb.before_block_exec : pandacbtype("before_block_exec", C.PANDA_CB_BEFORE_BLOCK_EXEC),
        pcb.after_block_exec : pandacbtype("after_block_exec", C.PANDA_CB_AFTER_BLOCK_EXEC),
        pcb.insn_translate : pandacbtype("insn_translate", C.PANDA_CB_INSN_TRANSLATE),
        pcb.insn_exec : pandacbtype("insn_exec", C.PANDA_CB_INSN_EXEC),
        pcb.after_insn_translate : pandacbtype("after_insn_translate", C.PANDA_CB_AFTER_INSN_TRANSLATE),
        pcb.after_insn_exec : pandacbtype("after_insn_exec", C.PANDA_CB_AFTER_INSN_EXEC),
        pcb.virt_mem_before_read : pandacbtype("virt_mem_before_read", C.PANDA_CB_VIRT_MEM_BEFORE_READ),
        pcb.virt_mem_before_write : pandacbtype("virt_mem_before_write", C.PANDA_CB_VIRT_MEM_BEFORE_WRITE),
        pcb.phys_mem_before_read : pandacbtype("phys_mem_before_read", C.PANDA_CB_PHYS_MEM_BEFORE_READ),
        pcb.phys_mem_before_write : pandacbtype("phys_mem_before_write", C.PANDA_CB_PHYS_MEM_BEFORE_WRITE),
        pcb.virt_mem_after_read : pandacbtype("virt_mem_after_read", C.PANDA_CB_VIRT_MEM_AFTER_READ),
        pcb.virt_mem_after_write : pandacbtype("virt_mem_after_write", C.PANDA_CB_VIRT_MEM_AFTER_WRITE),
        pcb.phys_mem_after_read : pandacbtype("phys_mem_after_read", C.PANDA_CB_PHYS_MEM_AFTER_READ),
        pcb.phys_mem_after_write : pandacbtype("phys_mem_after_write", C.PANDA_CB_PHYS_MEM_AFTER_WRITE),
        pcb.mmio_after_read : pandacbtype("mmio_after_read", C.PANDA_CB_MMIO_AFTER_READ),
        pcb.mmio_before_write : pandacbtype("mmio_before_write", C.PANDA_CB_MMIO_BEFORE_WRITE),
        pcb.hd_read : pandacbtype("hd_read", C.PANDA_CB_HD_READ),
        pcb.hd_write : pandacbtype("hd_write", C.PANDA_CB_HD_WRITE),
        pcb.guest_hypercall : pandacbtype("guest_hypercall", C.PANDA_CB_GUEST_HYPERCALL),
        pcb.monitor : pandacbtype("monitor", C.PANDA_CB_MONITOR),
        pcb.qmp : pandacbtype("qmp", C.PANDA_CB_QMP),
        pcb.cpu_restore_state : pandacbtype("cpu_restore_state", C.PANDA_CB_CPU_RESTORE_STATE),
        pcb.before_loadvm : pandacbtype("before_loadvm", C.PANDA_CB_BEFORE_LOADVM),
        pcb.asid_changed : pandacbtype("asid_changed", C.PANDA_CB_ASID_CHANGED),
        pcb.replay_hd_transfer : pandacbtype("replay_hd_transfer", C.PANDA_CB_REPLAY_HD_TRANSFER),
        pcb.replay_net_transfer : pandacbtype("replay_net_transfer", C.PANDA_CB_REPLAY_NET_TRANSFER),
        pcb.replay_serial_receive : pandacbtype("replay_serial_receive", C.PANDA_CB_REPLAY_SERIAL_RECEIVE),
        pcb.replay_serial_read : pandacbtype("replay_serial_read", C.PANDA_CB_REPLAY_SERIAL_READ),
        pcb.replay_serial_send : pandacbtype("replay_serial_send", C.PANDA_CB_REPLAY_SERIAL_SEND),
        pcb.replay_serial_write : pandacbtype("replay_serial_write", C.PANDA_CB_REPLAY_SERIAL_WRITE),
        pcb.replay_before_dma : pandacbtype("replay_before_dma", C.PANDA_CB_REPLAY_BEFORE_DMA),
        pcb.replay_after_dma : pandacbtype("replay_after_dma", C.PANDA_CB_REPLAY_AFTER_DMA),
        pcb.replay_handle_packet : pandacbtype("replay_handle_packet", C.PANDA_CB_REPLAY_HANDLE_PACKET),
        pcb.after_cpu_exec_enter : pandacbtype("after_cpu_exec_enter", C.PANDA_CB_AFTER_CPU_EXEC_ENTER),
        pcb.before_cpu_exec_exit : pandacbtype("before_cpu_exec_exit", C.PANDA_CB_BEFORE_CPU_EXEC_EXIT),
        pcb.after_machine_init : pandacbtype("after_machine_init", C.PANDA_CB_AFTER_MACHINE_INIT),
        pcb.after_loadvm : pandacbtype("after_loadvm", C.PANDA_CB_AFTER_LOADVM),
        pcb.top_loop : pandacbtype("top_loop", C.PANDA_CB_TOP_LOOP),
        pcb.during_machine_init : pandacbtype("during_machine_init", C.PANDA_CB_DURING_MACHINE_INIT),
        pcb.main_loop_wait : pandacbtype("main_loop_wait", C.PANDA_CB_MAIN_LOOP_WAIT),
        pcb.pre_shutdown : pandacbtype("pre_shutdown", C.PANDA_CB_PRE_SHUTDOWN),
        pcb.unassigned_io_read : pandacbtype("unassigned_io_read", C.PANDA_CB_UNASSIGNED_IO_READ),
        pcb.unassigned_io_write : pandacbtype("unassigned_io_write", C.PANDA_CB_UNASSIGNED_IO_WRITE),
        pcb.before_handle_exception : pandacbtype("before_handle_exception", C.PANDA_CB_BEFORE_HANDLE_EXCEPTION),
        pcb.before_handle_interrupt : pandacbtype("before_handle_interrupt", C.PANDA_CB_BEFORE_HANDLE_INTERRUPT),
        pcb.start_block_exec : pandacbtype("start_block_exec", C.PANDA_CB_START_BLOCK_EXEC),
        pcb.end_block_exec : pandacbtype("end_block_exec", C.PANDA_CB_END_BLOCK_EXEC)}
    return (pcb, callback_dictionary)