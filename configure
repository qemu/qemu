#!/bin/sh
#
# qemu configure script (c) 2003 Fabrice Bellard
#

# Unset some variables known to interfere with behavior of common tools,
# just as autoconf does.
CLICOLOR_FORCE= GREP_OPTIONS=
unset CLICOLOR_FORCE GREP_OPTIONS

# Don't allow CCACHE, if present, to use cached results of compile tests!
export CCACHE_RECACHE=yes

# make source path absolute
source_path=$(cd "$(dirname -- "$0")"; pwd)

if test "$PWD" = "$source_path"
then
    echo "Using './build' as the directory for build output"

    MARKER=build/auto-created-by-configure

    if test -e build
    then
        if test -f $MARKER
        then
           rm -rf build
        else
            echo "ERROR: ./build dir already exists and was not previously created by configure"
            exit 1
        fi
    fi

    mkdir build
    touch $MARKER

    cat > GNUmakefile <<'EOF'
# This file is auto-generated by configure to support in-source tree
# 'make' command invocation

ifeq ($(MAKECMDGOALS),)
recurse: all
endif

.NOTPARALLEL: %
%: force
	@echo 'changing dir to build for $(MAKE) "$(MAKECMDGOALS)"...'
	@$(MAKE) -C build -f Makefile $(MAKECMDGOALS)
	@if test "$(MAKECMDGOALS)" = "distclean" && \
	    test -e build/auto-created-by-configure ; \
	then \
	    rm -rf build GNUmakefile ; \
	fi
force: ;
.PHONY: force
GNUmakefile: ;

EOF
    cd build
    exec $source_path/configure "$@"
fi

# Temporary directory used for files created while
# configure runs. Since it is in the build directory
# we can safely blow away any previous version of it
# (and we need not jump through hoops to try to delete
# it when configure exits.)
TMPDIR1="config-temp"
rm -rf "${TMPDIR1}"
mkdir -p "${TMPDIR1}"
if [ $? -ne 0 ]; then
    echo "ERROR: failed to create temporary directory"
    exit 1
fi

TMPB="qemu-conf"
TMPC="${TMPDIR1}/${TMPB}.c"
TMPO="${TMPDIR1}/${TMPB}.o"
TMPCXX="${TMPDIR1}/${TMPB}.cxx"
TMPE="${TMPDIR1}/${TMPB}.exe"
TMPTXT="${TMPDIR1}/${TMPB}.txt"

rm -f config.log

# Print a helpful header at the top of config.log
echo "# QEMU configure log $(date)" >> config.log
printf "# Configured with:" >> config.log
printf " '%s'" "$0" "$@" >> config.log
echo >> config.log
echo "#" >> config.log

quote_sh() {
    printf "%s" "$1" | sed "s,','\\\\'',g; s,.*,'&',"
}

print_error() {
    (echo
    echo "ERROR: $1"
    while test -n "$2"; do
        echo "       $2"
        shift
    done
    echo) >&2
}

error_exit() {
    print_error "$@"
    exit 1
}

do_compiler() {
    # Run the compiler, capturing its output to the log. First argument
    # is compiler binary to execute.
    compiler="$1"
    shift
    if test -n "$BASH_VERSION"; then eval '
        echo >>config.log "
funcs: ${FUNCNAME[*]}
lines: ${BASH_LINENO[*]}"
    '; fi
    echo $compiler "$@" >> config.log
    $compiler "$@" >> config.log 2>&1 || return $?
    # Test passed. If this is an --enable-werror build, rerun
    # the test with -Werror and bail out if it fails. This
    # makes warning-generating-errors in configure test code
    # obvious to developers.
    if test "$werror" != "yes"; then
        return 0
    fi
    # Don't bother rerunning the compile if we were already using -Werror
    case "$*" in
        *-Werror*)
           return 0
        ;;
    esac
    echo $compiler -Werror "$@" >> config.log
    $compiler -Werror "$@" >> config.log 2>&1 && return $?
    error_exit "configure test passed without -Werror but failed with -Werror." \
        "This is probably a bug in the configure script. The failing command" \
        "will be at the bottom of config.log." \
        "You can run configure with --disable-werror to bypass this check."
}

do_cc() {
    do_compiler "$cc" $CPU_CFLAGS "$@"
}

do_cxx() {
    do_compiler "$cxx" $CPU_CFLAGS "$@"
}

# Append $2 to the variable named $1, with space separation
add_to() {
    eval $1=\${$1:+\"\$$1 \"}\$2
}

update_cxxflags() {
    # Set QEMU_CXXFLAGS from QEMU_CFLAGS by filtering out those
    # options which some versions of GCC's C++ compiler complain about
    # because they only make sense for C programs.
    QEMU_CXXFLAGS="-D__STDC_LIMIT_MACROS -D__STDC_CONSTANT_MACROS -D__STDC_FORMAT_MACROS"
    CONFIGURE_CXXFLAGS=$(echo "$CONFIGURE_CFLAGS" | sed s/-std=gnu11/-std=gnu++11/)
    for arg in $QEMU_CFLAGS; do
        case $arg in
            -Wstrict-prototypes|-Wmissing-prototypes|-Wnested-externs|\
            -Wold-style-declaration|-Wold-style-definition|-Wredundant-decls)
                ;;
            *)
                QEMU_CXXFLAGS=${QEMU_CXXFLAGS:+$QEMU_CXXFLAGS }$arg
                ;;
        esac
    done
}

compile_object() {
  local_cflags="$1"
  do_cc $CFLAGS $EXTRA_CFLAGS $CONFIGURE_CFLAGS $QEMU_CFLAGS $local_cflags -c -o $TMPO $TMPC
}

compile_prog() {
  local_cflags="$1"
  local_ldflags="$2"
  do_cc $CFLAGS $EXTRA_CFLAGS $CONFIGURE_CFLAGS $QEMU_CFLAGS $local_cflags -o $TMPE $TMPC \
      $LDFLAGS $EXTRA_LDFLAGS $CONFIGURE_LDFLAGS $QEMU_LDFLAGS $local_ldflags
}

# symbolically link $1 to $2.  Portable version of "ln -sf".
symlink() {
  rm -rf "$2"
  mkdir -p "$(dirname "$2")"
  ln -s "$1" "$2"
}

# check whether a command is available to this shell (may be either an
# executable or a builtin)
has() {
    type "$1" >/dev/null 2>&1
}

version_ge () {
    local_ver1=$(expr "$1" : '\([0-9.]*\)' | tr . ' ')
    local_ver2=$(echo "$2" | tr . ' ')
    while true; do
        set x $local_ver1
        local_first=${2-0}
        # 'shift 2' if $2 is set, or 'shift' if $2 is not set
        shift ${2:+2}
        local_ver1=$*
        set x $local_ver2
        # the second argument finished, the first must be greater or equal
        test $# = 1 && return 0
        test $local_first -lt $2 && return 1
        test $local_first -gt $2 && return 0
        shift ${2:+2}
        local_ver2=$*
    done
}

glob() {
    eval test -z '"${1#'"$2"'}"'
}

ld_has() {
    $ld --help 2>/dev/null | grep ".$1" >/dev/null 2>&1
}

if printf %s\\n "$source_path" "$PWD" | grep -q "[[:space:]:]";
then
  error_exit "main directory cannot contain spaces nor colons"
fi

# default parameters
cpu=""
iasl="iasl"
interp_prefix="/usr/gnemul/qemu-%M"
static="no"
cross_compile="no"
cross_prefix=""
audio_drv_list="default"
block_drv_rw_whitelist=""
block_drv_ro_whitelist=""
block_drv_whitelist_tools="no"
host_cc="cc"
libs_qga=""
debug_info="yes"
lto="false"
stack_protector=""
safe_stack=""
use_containers="yes"
gdb_bin=$(command -v "gdb-multiarch" || command -v "gdb")

if test -e "$source_path/.git"
then
    git_submodules_action="update"
else
    git_submodules_action="ignore"
fi

git_submodules="ui/keycodemapdb"
git="git"

# Don't accept a target_list environment variable.
unset target_list
unset target_list_exclude

# Default value for a variable defining feature "foo".
#  * foo="no"  feature will only be used if --enable-foo arg is given
#  * foo=""    feature will be searched for, and if found, will be used
#              unless --disable-foo is given
#  * foo="yes" this value will only be set by --enable-foo flag.
#              feature will searched for,
#              if not found, configure exits with error
#
# Always add --enable-foo and --disable-foo command line args.
# Distributions want to ensure that several features are compiled in, and it
# is impossible without a --enable-foo that exits if a feature is not found.

default_feature=""
# parse CC options second
for opt do
  optarg=$(expr "x$opt" : 'x[^=]*=\(.*\)')
  case "$opt" in
      --without-default-features)
          default_feature="no"
  ;;
  esac
done

EXTRA_CFLAGS=""
EXTRA_CXXFLAGS=""
EXTRA_LDFLAGS=""

xen_ctrl_version="$default_feature"
xfs="$default_feature"
membarrier="$default_feature"
vhost_kernel="$default_feature"
vhost_net="$default_feature"
vhost_crypto="$default_feature"
vhost_scsi="$default_feature"
vhost_vsock="$default_feature"
vhost_user="no"
vhost_user_fs="$default_feature"
vhost_vdpa="$default_feature"
rdma="$default_feature"
pvrdma="$default_feature"
gprof="no"
debug_tcg="no"
debug="no"
sanitizers="no"
tsan="no"
fortify_source="$default_feature"
strip_opt="yes"
mingw32="no"
gcov="no"
EXESUF=""
modules="no"
module_upgrades="no"
prefix="/usr/local"
qemu_suffix="qemu"
bsd="no"
linux="no"
solaris="no"
profiler="no"
softmmu="yes"
linux_user="no"
bsd_user="no"
pkgversion=""
pie=""
qom_cast_debug="yes"
trace_backends="log"
trace_file="trace"
opengl="$default_feature"
cpuid_h="no"
avx2_opt="$default_feature"
guest_agent="$default_feature"
guest_agent_with_vss="no"
guest_agent_ntddscsi="no"
vss_win32_sdk="$default_feature"
win_sdk="no"
want_tools="$default_feature"
coroutine=""
coroutine_pool="$default_feature"
debug_stack_usage="no"
crypto_afalg="no"
tls_priority="NORMAL"
tpm="$default_feature"
live_block_migration=${default_feature:-yes}
numa="$default_feature"
replication=${default_feature:-yes}
bochs=${default_feature:-yes}
cloop=${default_feature:-yes}
dmg=${default_feature:-yes}
qcow1=${default_feature:-yes}
vdi=${default_feature:-yes}
vvfat=${default_feature:-yes}
qed=${default_feature:-yes}
parallels=${default_feature:-yes}
debug_mutex="no"
plugins="$default_feature"
rng_none="no"
secret_keyring="$default_feature"
meson=""
meson_args=""
ninja=""
gio="$default_feature"
skip_meson=no
slirp_smbd="$default_feature"

# The following Meson options are handled manually (still they
# are included in the automatically generated help message)

# 1. Track which submodules are needed
capstone="auto"
fdt="auto"
slirp="auto"

# 2. Support --with/--without option
default_devices="true"

# 3. Automatically enable/disable other options
tcg="enabled"
cfi="false"

# 4. Detection partly done in configure
xen=${default_feature:+disabled}

# parse CC options second
for opt do
  optarg=$(expr "x$opt" : 'x[^=]*=\(.*\)')
  case "$opt" in
  --cross-prefix=*) cross_prefix="$optarg"
                    cross_compile="yes"
  ;;
  --cc=*) CC="$optarg"
  ;;
  --cxx=*) CXX="$optarg"
  ;;
  --cpu=*) cpu="$optarg"
  ;;
  --extra-cflags=*)
    EXTRA_CFLAGS="$EXTRA_CFLAGS $optarg"
    EXTRA_CXXFLAGS="$EXTRA_CXXFLAGS $optarg"
    ;;
  --extra-cxxflags=*) EXTRA_CXXFLAGS="$EXTRA_CXXFLAGS $optarg"
  ;;
  --extra-ldflags=*) EXTRA_LDFLAGS="$EXTRA_LDFLAGS $optarg"
  ;;
  --enable-debug-info) debug_info="yes"
  ;;
  --disable-debug-info) debug_info="no"
  ;;
  --cross-cc-*[!a-zA-Z0-9_-]*=*) error_exit "Passed bad --cross-cc-FOO option"
  ;;
  --cross-cc-cflags-*) cc_arch=${opt#--cross-cc-flags-}; cc_arch=${cc_arch%%=*}
                      eval "cross_cc_cflags_${cc_arch}=\$optarg"
                      cross_cc_vars="$cross_cc_vars cross_cc_cflags_${cc_arch}"
  ;;
  --cross-cc-*) cc_arch=${opt#--cross-cc-}; cc_arch=${cc_arch%%=*}
                cc_archs="$cc_archs $cc_arch"
                eval "cross_cc_${cc_arch}=\$optarg"
                cross_cc_vars="$cross_cc_vars cross_cc_${cc_arch}"
  ;;
  esac
done
# OS specific
# Using uname is really, really broken.  Once we have the right set of checks
# we can eliminate its usage altogether.

# Preferred compiler:
#  ${CC} (if set)
#  ${cross_prefix}gcc (if cross-prefix specified)
#  system compiler
if test -z "${CC}${cross_prefix}"; then
  cc="$host_cc"
else
  cc="${CC-${cross_prefix}gcc}"
fi

if test -z "${CXX}${cross_prefix}"; then
  cxx="c++"
else
  cxx="${CXX-${cross_prefix}g++}"
fi

ar="${AR-${cross_prefix}ar}"
as="${AS-${cross_prefix}as}"
ccas="${CCAS-$cc}"
cpp="${CPP-$cc -E}"
objcopy="${OBJCOPY-${cross_prefix}objcopy}"
ld="${LD-${cross_prefix}ld}"
ranlib="${RANLIB-${cross_prefix}ranlib}"
nm="${NM-${cross_prefix}nm}"
strip="${STRIP-${cross_prefix}strip}"
windres="${WINDRES-${cross_prefix}windres}"
pkg_config_exe="${PKG_CONFIG-${cross_prefix}pkg-config}"
query_pkg_config() {
    "${pkg_config_exe}" ${QEMU_PKG_CONFIG_FLAGS} "$@"
}
pkg_config=query_pkg_config
sdl2_config="${SDL2_CONFIG-${cross_prefix}sdl2-config}"

# default flags for all hosts
# We use -fwrapv to tell the compiler that we require a C dialect where
# left shift of signed integers is well defined and has the expected
# 2s-complement style results. (Both clang and gcc agree that it
# provides these semantics.)
QEMU_CFLAGS="-fno-strict-aliasing -fno-common -fwrapv"
QEMU_CFLAGS="-Wundef -Wwrite-strings -Wmissing-prototypes $QEMU_CFLAGS"
QEMU_CFLAGS="-Wstrict-prototypes -Wredundant-decls $QEMU_CFLAGS"
QEMU_CFLAGS="-D_GNU_SOURCE -D_FILE_OFFSET_BITS=64 -D_LARGEFILE_SOURCE $QEMU_CFLAGS"

QEMU_LDFLAGS=

# Flags that are needed during configure but later taken care of by Meson
CONFIGURE_CFLAGS="-std=gnu11 -Wall"
CONFIGURE_LDFLAGS=


check_define() {
cat > $TMPC <<EOF
#if !defined($1)
#error $1 not defined
#endif
int main(void) { return 0; }
EOF
  compile_object
}

check_include() {
cat > $TMPC <<EOF
#include <$1>
int main(void) { return 0; }
EOF
  compile_object
}

write_c_skeleton() {
    cat > $TMPC <<EOF
int main(void) { return 0; }
EOF
}

if check_define __linux__ ; then
  targetos=linux
elif check_define _WIN32 ; then
  targetos=windows
elif check_define __OpenBSD__ ; then
  targetos=openbsd
elif check_define __sun__ ; then
  targetos=sunos
elif check_define __HAIKU__ ; then
  targetos=haiku
elif check_define __FreeBSD__ ; then
  targetos=freebsd
elif check_define __FreeBSD_kernel__ && check_define __GLIBC__; then
  targetos=gnu/kfreebsd
elif check_define __DragonFly__ ; then
  targetos=dragonfly
elif check_define __NetBSD__; then
  targetos=netbsd
elif check_define __APPLE__; then
  targetos=darwin
else
  # This is a fatal error, but don't report it yet, because we
  # might be going to just print the --help text, or it might
  # be the result of a missing compiler.
  targetos=bogus
fi

# OS specific

case $targetos in
windows)
  mingw32="yes"
  plugins="no"
  pie="no"
;;
gnu/kfreebsd)
  bsd="yes"
;;
freebsd)
  bsd="yes"
  bsd_user="yes"
  make="${MAKE-gmake}"
  # needed for kinfo_getvmmap(3) in libutil.h
;;
dragonfly)
  bsd="yes"
  make="${MAKE-gmake}"
;;
netbsd)
  bsd="yes"
  make="${MAKE-gmake}"
;;
openbsd)
  bsd="yes"
  make="${MAKE-gmake}"
;;
darwin)
  bsd="yes"
  darwin="yes"
  # Disable attempts to use ObjectiveC features in os/object.h since they
  # won't work when we're compiling with gcc as a C compiler.
  QEMU_CFLAGS="-DOS_OBJECT_USE_OBJC=0 $QEMU_CFLAGS"
;;
sunos)
  solaris="yes"
  make="${MAKE-gmake}"
  smbd="${SMBD-/usr/sfw/sbin/smbd}"
# needed for CMSG_ macros in sys/socket.h
  QEMU_CFLAGS="-D_XOPEN_SOURCE=600 $QEMU_CFLAGS"
# needed for TIOCWIN* defines in termios.h
  QEMU_CFLAGS="-D__EXTENSIONS__ $QEMU_CFLAGS"
  # $(uname -m) returns i86pc even on an x86_64 box, so default based on isainfo
  # Note that this check is broken for cross-compilation: if you're
  # cross-compiling to one of these OSes then you'll need to specify
  # the correct CPU with the --cpu option.
  if test -z "$cpu" && test "$(isainfo -k)" = "amd64"; then
    cpu="x86_64"
  fi
;;
haiku)
  pie="no"
  QEMU_CFLAGS="-DB_USE_POSITIVE_POSIX_ERRORS -D_BSD_SOURCE -fPIC $QEMU_CFLAGS"
;;
linux)
  linux="yes"
  linux_user="yes"
  vhost_user=${default_feature:-yes}
;;
esac

if test ! -z "$cpu" ; then
  # command line argument
  :
elif check_define __i386__ ; then
  cpu="i386"
elif check_define __x86_64__ ; then
  if check_define __ILP32__ ; then
    cpu="x32"
  else
    cpu="x86_64"
  fi
elif check_define __sparc__ ; then
  if check_define __arch64__ ; then
    cpu="sparc64"
  else
    cpu="sparc"
  fi
elif check_define _ARCH_PPC ; then
  if check_define _ARCH_PPC64 ; then
    if check_define _LITTLE_ENDIAN ; then
      cpu="ppc64le"
    else
      cpu="ppc64"
    fi
  else
    cpu="ppc"
  fi
elif check_define __mips__ ; then
  cpu="mips"
elif check_define __s390__ ; then
  if check_define __s390x__ ; then
    cpu="s390x"
  else
    cpu="s390"
  fi
elif check_define __riscv ; then
  cpu="riscv"
elif check_define __arm__ ; then
  cpu="arm"
elif check_define __aarch64__ ; then
  cpu="aarch64"
elif check_define __loongarch64 ; then
  cpu="loongarch64"
else
  cpu=$(uname -m)
fi

# Normalise host CPU name, set multilib cflags
# Note that this case should only have supported host CPUs, not guests.
case "$cpu" in
  armv*b|armv*l|arm)
    cpu="arm" ;;

  i386|i486|i586|i686|i86pc|BePC)
    cpu="i386"
    CPU_CFLAGS="-m32" ;;
  x32)
    cpu="x86_64"
    CPU_CFLAGS="-mx32" ;;
  x86_64|amd64)
    cpu="x86_64"
    # ??? Only extremely old AMD cpus do not have cmpxchg16b.
    # If we truly care, we should simply detect this case at
    # runtime and generate the fallback to serial emulation.
    CPU_CFLAGS="-m64 -mcx16" ;;

  mips*)
    cpu="mips" ;;

  ppc)
    CPU_CFLAGS="-m32" ;;
  ppc64)
    CPU_CFLAGS="-m64 -mbig" ;;
  ppc64le)
    cpu="ppc64"
    CPU_CFLAGS="-m64 -mlittle" ;;

  s390)
    CPU_CFLAGS="-m31" ;;
  s390x)
    CPU_CFLAGS="-m64" ;;

  sparc|sun4[cdmuv])
    cpu="sparc"
    CPU_CFLAGS="-m32 -mv8plus -mcpu=ultrasparc" ;;
  sparc64)
    CPU_CFLAGS="-m64 -mcpu=ultrasparc" ;;
esac

: ${make=${MAKE-make}}

# We prefer python 3.x. A bare 'python' is traditionally
# python 2.x, but some distros have it as python 3.x, so
# we check that too
python=
explicit_python=no
for binary in "${PYTHON-python3}" python
do
    if has "$binary"
    then
        python=$(command -v "$binary")
        break
    fi
done


# Check for ancillary tools used in testing
genisoimage=
for binary in genisoimage mkisofs
do
    if has $binary
    then
        genisoimage=$(command -v "$binary")
        break
    fi
done

# Default objcc to clang if available, otherwise use CC
if has clang; then
  objcc=clang
else
  objcc="$cc"
fi

if test "$mingw32" = "yes" ; then
  EXESUF=".exe"
  # MinGW needs -mthreads for TLS and macro _MT.
  CONFIGURE_CFLAGS="-mthreads $CONFIGURE_CFLAGS"
  write_c_skeleton;
  prefix="/qemu"
  qemu_suffix=""
  libs_qga="-lws2_32 -lwinmm -lpowrprof -lwtsapi32 -lwininet -liphlpapi -lnetapi32 $libs_qga"
fi

werror=""

. $source_path/scripts/meson-buildoptions.sh

meson_options=
meson_option_parse() {
  meson_options="$meson_options $(_meson_option_parse "$@")"
  if test $? -eq 1; then
    echo "ERROR: unknown option $1"
    echo "Try '$0 --help' for more information"
    exit 1
  fi
}

for opt do
  optarg=$(expr "x$opt" : 'x[^=]*=\(.*\)')
  case "$opt" in
  --help|-h) show_help=yes
  ;;
  --version|-V) exec cat $source_path/VERSION
  ;;
  --prefix=*) prefix="$optarg"
  ;;
  --interp-prefix=*) interp_prefix="$optarg"
  ;;
  --cross-prefix=*)
  ;;
  --cc=*)
  ;;
  --host-cc=*) host_cc="$optarg"
  ;;
  --cxx=*)
  ;;
  --iasl=*) iasl="$optarg"
  ;;
  --objcc=*) objcc="$optarg"
  ;;
  --make=*) make="$optarg"
  ;;
  --install=*)
  ;;
  --python=*) python="$optarg" ; explicit_python=yes
  ;;
  --sphinx-build=*) sphinx_build="$optarg"
  ;;
  --skip-meson) skip_meson=yes
  ;;
  --meson=*) meson="$optarg"
  ;;
  --ninja=*) ninja="$optarg"
  ;;
  --smbd=*) smbd="$optarg"
  ;;
  --extra-cflags=*)
  ;;
  --extra-cxxflags=*)
  ;;
  --extra-ldflags=*)
  ;;
  --enable-debug-info)
  ;;
  --disable-debug-info)
  ;;
  --cross-cc-*)
  ;;
  --enable-modules)
      modules="yes"
  ;;
  --disable-modules)
      modules="no"
  ;;
  --disable-module-upgrades) module_upgrades="no"
  ;;
  --enable-module-upgrades) module_upgrades="yes"
  ;;
  --cpu=*)
  ;;
  --target-list=*) target_list="$optarg"
                   if test "$target_list_exclude"; then
                       error_exit "Can't mix --target-list with --target-list-exclude"
                   fi
  ;;
  --target-list-exclude=*) target_list_exclude="$optarg"
                   if test "$target_list"; then
                       error_exit "Can't mix --target-list-exclude with --target-list"
                   fi
  ;;
  --with-trace-file=*) trace_file="$optarg"
  ;;
  --with-default-devices) default_devices="true"
  ;;
  --without-default-devices) default_devices="false"
  ;;
  --with-devices-*[!a-zA-Z0-9_-]*=*) error_exit "Passed bad --with-devices-FOO option"
  ;;
  --with-devices-*) device_arch=${opt#--with-devices-};
                    device_arch=${device_arch%%=*}
                    cf=$source_path/configs/devices/$device_arch-softmmu/$optarg.mak
                    if test -f "$cf"; then
                        device_archs="$device_archs $device_arch"
                        eval "devices_${device_arch}=\$optarg"
                    else
                        error_exit "File $cf does not exist"
                    fi
  ;;
  --without-default-features) # processed above
  ;;
  --enable-gprof) gprof="yes"
  ;;
  --enable-gcov) gcov="yes"
  ;;
  --static)
    static="yes"
    QEMU_PKG_CONFIG_FLAGS="--static $QEMU_PKG_CONFIG_FLAGS"
  ;;
  --mandir=*) mandir="$optarg"
  ;;
  --bindir=*) bindir="$optarg"
  ;;
  --libdir=*) libdir="$optarg"
  ;;
  --libexecdir=*) libexecdir="$optarg"
  ;;
  --includedir=*) includedir="$optarg"
  ;;
  --datadir=*) datadir="$optarg"
  ;;
  --with-suffix=*) qemu_suffix="$optarg"
  ;;
  --docdir=*) docdir="$optarg"
  ;;
  --localedir=*) localedir="$optarg"
  ;;
  --sysconfdir=*) sysconfdir="$optarg"
  ;;
  --localstatedir=*) local_statedir="$optarg"
  ;;
  --firmwarepath=*) firmwarepath="$optarg"
  ;;
  --host=*|--build=*|\
  --disable-dependency-tracking|\
  --sbindir=*|--sharedstatedir=*|\
  --oldincludedir=*|--datarootdir=*|--infodir=*|\
  --htmldir=*|--dvidir=*|--pdfdir=*|--psdir=*)
    # These switches are silently ignored, for compatibility with
    # autoconf-generated configure scripts. This allows QEMU's
    # configure to be used by RPM and similar macros that set
    # lots of directory switches by default.
  ;;
  --disable-qom-cast-debug) qom_cast_debug="no"
  ;;
  --enable-qom-cast-debug) qom_cast_debug="yes"
  ;;
  --audio-drv-list=*) audio_drv_list="$optarg"
  ;;
  --block-drv-rw-whitelist=*|--block-drv-whitelist=*) block_drv_rw_whitelist=$(echo "$optarg" | sed -e 's/,/ /g')
  ;;
  --block-drv-ro-whitelist=*) block_drv_ro_whitelist=$(echo "$optarg" | sed -e 's/,/ /g')
  ;;
  --enable-block-drv-whitelist-in-tools) block_drv_whitelist_tools="yes"
  ;;
  --disable-block-drv-whitelist-in-tools) block_drv_whitelist_tools="no"
  ;;
  --enable-debug-tcg) debug_tcg="yes"
  ;;
  --disable-debug-tcg) debug_tcg="no"
  ;;
  --enable-debug)
      # Enable debugging options that aren't excessively noisy
      debug_tcg="yes"
      debug_mutex="yes"
      debug="yes"
      strip_opt="no"
      fortify_source="no"
  ;;
  --enable-sanitizers) sanitizers="yes"
  ;;
  --disable-sanitizers) sanitizers="no"
  ;;
  --enable-tsan) tsan="yes"
  ;;
  --disable-tsan) tsan="no"
  ;;
  --disable-strip) strip_opt="no"
  ;;
  --disable-slirp) slirp="disabled"
  ;;
  --enable-slirp) slirp="enabled"
  ;;
  --enable-slirp=git) slirp="internal"
  ;;
  --enable-slirp=*) slirp="$optarg"
  ;;
  --disable-xen) xen="disabled"
  ;;
  --enable-xen) xen="enabled"
  ;;
  --disable-tcg) tcg="disabled"
                 plugins="no"
  ;;
  --enable-tcg) tcg="enabled"
  ;;
  --enable-profiler) profiler="yes"
  ;;
  --disable-system) softmmu="no"
  ;;
  --enable-system) softmmu="yes"
  ;;
  --disable-user)
      linux_user="no" ;
      bsd_user="no" ;
  ;;
  --enable-user) ;;
  --disable-linux-user) linux_user="no"
  ;;
  --enable-linux-user) linux_user="yes"
  ;;
  --disable-bsd-user) bsd_user="no"
  ;;
  --enable-bsd-user) bsd_user="yes"
  ;;
  --enable-pie) pie="yes"
  ;;
  --disable-pie) pie="no"
  ;;
  --enable-werror) werror="yes"
  ;;
  --disable-werror) werror="no"
  ;;
  --enable-lto) lto="true"
  ;;
  --disable-lto) lto="false"
  ;;
  --enable-stack-protector) stack_protector="yes"
  ;;
  --disable-stack-protector) stack_protector="no"
  ;;
  --enable-safe-stack) safe_stack="yes"
  ;;
  --disable-safe-stack) safe_stack="no"
  ;;
  --enable-cfi)
      cfi="true";
      lto="true";
  ;;
  --disable-cfi) cfi="false"
  ;;
  --disable-fdt) fdt="disabled"
  ;;
  --enable-fdt) fdt="enabled"
  ;;
  --enable-fdt=git) fdt="internal"
  ;;
  --enable-fdt=*) fdt="$optarg"
  ;;
  --disable-membarrier) membarrier="no"
  ;;
  --enable-membarrier) membarrier="yes"
  ;;
  --with-pkgversion=*) pkgversion="$optarg"
  ;;
  --with-coroutine=*) coroutine="$optarg"
  ;;
  --disable-coroutine-pool) coroutine_pool="no"
  ;;
  --enable-coroutine-pool) coroutine_pool="yes"
  ;;
  --enable-debug-stack-usage) debug_stack_usage="yes"
  ;;
  --enable-crypto-afalg) crypto_afalg="yes"
  ;;
  --disable-crypto-afalg) crypto_afalg="no"
  ;;
  --disable-vhost-net) vhost_net="no"
  ;;
  --enable-vhost-net) vhost_net="yes"
  ;;
  --disable-vhost-crypto) vhost_crypto="no"
  ;;
  --enable-vhost-crypto) vhost_crypto="yes"
  ;;
  --disable-vhost-scsi) vhost_scsi="no"
  ;;
  --enable-vhost-scsi) vhost_scsi="yes"
  ;;
  --disable-vhost-vsock) vhost_vsock="no"
  ;;
  --enable-vhost-vsock) vhost_vsock="yes"
  ;;
  --disable-vhost-user-fs) vhost_user_fs="no"
  ;;
  --enable-vhost-user-fs) vhost_user_fs="yes"
  ;;
  --disable-opengl) opengl="no"
  ;;
  --enable-opengl) opengl="yes"
  ;;
  --disable-xfsctl) xfs="no"
  ;;
  --enable-xfsctl) xfs="yes"
  ;;
  --disable-zlib-test)
  ;;
  --enable-guest-agent) guest_agent="yes"
  ;;
  --disable-guest-agent) guest_agent="no"
  ;;
  --with-vss-sdk) vss_win32_sdk=""
  ;;
  --with-vss-sdk=*) vss_win32_sdk="$optarg"
  ;;
  --without-vss-sdk) vss_win32_sdk="no"
  ;;
  --with-win-sdk) win_sdk=""
  ;;
  --with-win-sdk=*) win_sdk="$optarg"
  ;;
  --without-win-sdk) win_sdk="no"
  ;;
  --enable-tools) want_tools="yes"
  ;;
  --disable-tools) want_tools="no"
  ;;
  --disable-avx2) avx2_opt="no"
  ;;
  --enable-avx2) avx2_opt="yes"
  ;;
  --disable-avx512f) avx512f_opt="no"
  ;;
  --enable-avx512f) avx512f_opt="yes"
  ;;
  --disable-virtio-blk-data-plane|--enable-virtio-blk-data-plane)
      echo "$0: $opt is obsolete, virtio-blk data-plane is always on" >&2
  ;;
  --enable-vhdx|--disable-vhdx)
      echo "$0: $opt is obsolete, VHDX driver is always built" >&2
  ;;
  --enable-uuid|--disable-uuid)
      echo "$0: $opt is obsolete, UUID support is always built" >&2
  ;;
  --tls-priority=*) tls_priority="$optarg"
  ;;
  --enable-rdma) rdma="yes"
  ;;
  --disable-rdma) rdma="no"
  ;;
  --enable-pvrdma) pvrdma="yes"
  ;;
  --disable-pvrdma) pvrdma="no"
  ;;
  --disable-tpm) tpm="no"
  ;;
  --enable-tpm) tpm="yes"
  ;;
  --disable-live-block-migration) live_block_migration="no"
  ;;
  --enable-live-block-migration) live_block_migration="yes"
  ;;
  --disable-numa) numa="no"
  ;;
  --enable-numa) numa="yes"
  ;;
  --disable-replication) replication="no"
  ;;
  --enable-replication) replication="yes"
  ;;
  --disable-bochs) bochs="no"
  ;;
  --enable-bochs) bochs="yes"
  ;;
  --disable-cloop) cloop="no"
  ;;
  --enable-cloop) cloop="yes"
  ;;
  --disable-dmg) dmg="no"
  ;;
  --enable-dmg) dmg="yes"
  ;;
  --disable-qcow1) qcow1="no"
  ;;
  --enable-qcow1) qcow1="yes"
  ;;
  --disable-vdi) vdi="no"
  ;;
  --enable-vdi) vdi="yes"
  ;;
  --disable-vvfat) vvfat="no"
  ;;
  --enable-vvfat) vvfat="yes"
  ;;
  --disable-qed) qed="no"
  ;;
  --enable-qed) qed="yes"
  ;;
  --disable-parallels) parallels="no"
  ;;
  --enable-parallels) parallels="yes"
  ;;
  --disable-vhost-user) vhost_user="no"
  ;;
  --enable-vhost-user) vhost_user="yes"
  ;;
  --disable-vhost-vdpa) vhost_vdpa="no"
  ;;
  --enable-vhost-vdpa) vhost_vdpa="yes"
  ;;
  --disable-vhost-kernel) vhost_kernel="no"
  ;;
  --enable-vhost-kernel) vhost_kernel="yes"
  ;;
  --disable-capstone) capstone="disabled"
  ;;
  --enable-capstone) capstone="enabled"
  ;;
  --enable-capstone=git) capstone="internal"
  ;;
  --enable-capstone=*) capstone="$optarg"
  ;;
  --with-git=*) git="$optarg"
  ;;
  --with-git-submodules=*)
      git_submodules_action="$optarg"
  ;;
  --enable-debug-mutex) debug_mutex=yes
  ;;
  --disable-debug-mutex) debug_mutex=no
  ;;
  --enable-plugins) if test "$mingw32" = "yes"; then
                        error_exit "TCG plugins not currently supported on Windows platforms"
                    else
                        plugins="yes"
                    fi
  ;;
  --disable-plugins) plugins="no"
  ;;
  --enable-containers) use_containers="yes"
  ;;
  --disable-containers) use_containers="no"
  ;;
  --gdb=*) gdb_bin="$optarg"
  ;;
  --enable-rng-none) rng_none=yes
  ;;
  --disable-rng-none) rng_none=no
  ;;
  --enable-keyring) secret_keyring="yes"
  ;;
  --disable-keyring) secret_keyring="no"
  ;;
  --enable-gio) gio=yes
  ;;
  --disable-gio) gio=no
  ;;
  --enable-slirp-smbd) slirp_smbd=yes
  ;;
  --disable-slirp-smbd) slirp_smbd=no
  ;;
  # backwards compatibility options
  --enable-trace-backend=*) meson_option_parse "--enable-trace-backends=$optarg" "$optarg"
  ;;
  --disable-blobs) meson_option_parse --disable-install-blobs ""
  ;;
  --enable-tcmalloc) meson_option_parse --enable-malloc=tcmalloc tcmalloc
  ;;
  --enable-jemalloc) meson_option_parse --enable-malloc=jemalloc jemalloc
  ;;
  # everything else has the same name in configure and meson
  --enable-* | --disable-*) meson_option_parse "$opt" "$optarg"
  ;;
  *)
      echo "ERROR: unknown option $opt"
      echo "Try '$0 --help' for more information"
      exit 1
  ;;
  esac
done

# test for any invalid configuration combinations
if test "$plugins" = "yes" -a "$tcg" = "disabled"; then
    error_exit "Can't enable plugins on non-TCG builds"
fi

case $git_submodules_action in
    update|validate)
        if test ! -e "$source_path/.git"; then
            echo "ERROR: cannot $git_submodules_action git submodules without .git"
            exit 1
        fi
    ;;
    ignore)
        if ! test -f "$source_path/ui/keycodemapdb/README"
        then
            echo
            echo "ERROR: missing GIT submodules"
            echo
            if test -e "$source_path/.git"; then
                echo "--with-git-submodules=ignore specified but submodules were not"
                echo "checked out.  Please initialize and update submodules."
            else
                echo "This is not a GIT checkout but module content appears to"
                echo "be missing. Do not use 'git archive' or GitHub download links"
                echo "to acquire QEMU source archives. Non-GIT builds are only"
                echo "supported with source archives linked from:"
                echo
                echo "  https://www.qemu.org/download/#source"
                echo
                echo "Developers working with GIT can use scripts/archive-source.sh"
                echo "if they need to create valid source archives."
            fi
            echo
            exit 1
        fi
    ;;
    *)
        echo "ERROR: invalid --with-git-submodules= value '$git_submodules_action'"
        exit 1
    ;;
esac

libdir="${libdir:-$prefix/lib}"
libexecdir="${libexecdir:-$prefix/libexec}"
includedir="${includedir:-$prefix/include}"

if test "$mingw32" = "yes" ; then
    bindir="${bindir:-$prefix}"
else
    bindir="${bindir:-$prefix/bin}"
fi
mandir="${mandir:-$prefix/share/man}"
datadir="${datadir:-$prefix/share}"
docdir="${docdir:-$prefix/share/doc}"
sysconfdir="${sysconfdir:-$prefix/etc}"
local_statedir="${local_statedir:-$prefix/var}"
firmwarepath="${firmwarepath:-$datadir/qemu-firmware}"
localedir="${localedir:-$datadir/locale}"

if eval test -z "\${cross_cc_$cpu}"; then
    eval "cross_cc_${cpu}=\$cc"
    cross_cc_vars="$cross_cc_vars cross_cc_${cpu}"
fi

# For user-mode emulation the host arch has to be one we explicitly
# support, even if we're using TCI.
if [ "$ARCH" = "unknown" ]; then
  bsd_user="no"
  linux_user="no"
fi

default_target_list=""
deprecated_targets_list=ppc64abi32-linux-user
deprecated_features=""
mak_wilds=""

if [ "$softmmu" = "yes" ]; then
    mak_wilds="${mak_wilds} $source_path/configs/targets/*-softmmu.mak"
fi
if [ "$linux_user" = "yes" ]; then
    mak_wilds="${mak_wilds} $source_path/configs/targets/*-linux-user.mak"
fi
if [ "$bsd_user" = "yes" ]; then
    mak_wilds="${mak_wilds} $source_path/configs/targets/*-bsd-user.mak"
fi

# If the user doesn't explicitly specify a deprecated target we will
# skip it.
if test -z "$target_list"; then
    if test -z "$target_list_exclude"; then
        target_list_exclude="$deprecated_targets_list"
    else
        target_list_exclude="$target_list_exclude,$deprecated_targets_list"
    fi
fi

for config in $mak_wilds; do
    target="$(basename "$config" .mak)"
    if echo "$target_list_exclude" | grep -vq "$target"; then
        default_target_list="${default_target_list} $target"
    fi
done

if test x"$show_help" = x"yes" ; then
cat << EOF

Usage: configure [options]
Options: [defaults in brackets after descriptions]

Standard options:
  --help                   print this message
  --prefix=PREFIX          install in PREFIX [$prefix]
  --interp-prefix=PREFIX   where to find shared libraries, etc.
                           use %M for cpu name [$interp_prefix]
  --target-list=LIST       set target list (default: build all non-deprecated)
$(echo Available targets: $default_target_list | \
  fold -s -w 53 | sed -e 's/^/                           /')
$(echo Deprecated targets: $deprecated_targets_list | \
  fold -s -w 53 | sed -e 's/^/                           /')
  --target-list-exclude=LIST exclude a set of targets from the default target-list

Advanced options (experts only):
  --cross-prefix=PREFIX    use PREFIX for compile tools, PREFIX can be blank [$cross_prefix]
  --cc=CC                  use C compiler CC [$cc]
  --iasl=IASL              use ACPI compiler IASL [$iasl]
  --host-cc=CC             use C compiler CC [$host_cc] for code run at
                           build time
  --cxx=CXX                use C++ compiler CXX [$cxx]
  --objcc=OBJCC            use Objective-C compiler OBJCC [$objcc]
  --extra-cflags=CFLAGS    append extra C compiler flags CFLAGS
  --extra-cxxflags=CXXFLAGS append extra C++ compiler flags CXXFLAGS
  --extra-ldflags=LDFLAGS  append extra linker flags LDFLAGS
  --cross-cc-ARCH=CC       use compiler when building ARCH guest test cases
  --cross-cc-flags-ARCH=   use compiler flags when building ARCH guest tests
  --make=MAKE              use specified make [$make]
  --python=PYTHON          use specified python [$python]
  --sphinx-build=SPHINX    use specified sphinx-build [$sphinx_build]
  --meson=MESON            use specified meson [$meson]
  --ninja=NINJA            use specified ninja [$ninja]
  --smbd=SMBD              use specified smbd [$smbd]
  --with-git=GIT           use specified git [$git]
  --with-git-submodules=update   update git submodules (default if .git dir exists)
  --with-git-submodules=validate fail if git submodules are not up to date
  --with-git-submodules=ignore   do not update or check git submodules (default if no .git dir)
  --static                 enable static build [$static]
  --mandir=PATH            install man pages in PATH
  --datadir=PATH           install firmware in PATH/$qemu_suffix
  --localedir=PATH         install translation in PATH/$qemu_suffix
  --docdir=PATH            install documentation in PATH/$qemu_suffix
  --bindir=PATH            install binaries in PATH
  --libdir=PATH            install libraries in PATH
  --libexecdir=PATH        install helper binaries in PATH
  --sysconfdir=PATH        install config in PATH/$qemu_suffix
  --localstatedir=PATH     install local state in PATH (set at runtime on win32)
  --firmwarepath=PATH      search PATH for firmware files
  --efi-aarch64=PATH       PATH of efi file to use for aarch64 VMs.
  --with-suffix=SUFFIX     suffix for QEMU data inside datadir/libdir/sysconfdir/docdir [$qemu_suffix]
  --with-pkgversion=VERS   use specified string as sub-version of the package
  --without-default-features default all --enable-* options to "disabled"
  --without-default-devices  do not include any device that is not needed to
                           start the emulator (only use if you are including
                           desired devices in configs/devices/)
  --with-devices-ARCH=NAME override default configs/devices
  --enable-debug           enable common debug build options
  --enable-sanitizers      enable default sanitizers
  --enable-tsan            enable thread sanitizer
  --disable-strip          disable stripping binaries
  --disable-werror         disable compilation abort on warning
  --disable-stack-protector disable compiler-provided stack protection
  --audio-drv-list=LIST    set audio drivers to try if -audiodev is not used
  --block-drv-whitelist=L  Same as --block-drv-rw-whitelist=L
  --block-drv-rw-whitelist=L
                           set block driver read-write whitelist
                           (by default affects only QEMU, not tools like qemu-img)
  --block-drv-ro-whitelist=L
                           set block driver read-only whitelist
                           (by default affects only QEMU, not tools like qemu-img)
  --enable-block-drv-whitelist-in-tools
                           use block whitelist also in tools instead of only QEMU
  --with-trace-file=NAME   Full PATH,NAME of file to store traces
                           Default:trace-<pid>
  --cpu=CPU                Build for host CPU [$cpu]
  --with-coroutine=BACKEND coroutine backend. Supported options:
                           ucontext, sigaltstack, windows
  --enable-gcov            enable test coverage analysis with gcov
  --with-vss-sdk=SDK-path  enable Windows VSS support in QEMU Guest Agent
  --with-win-sdk=SDK-path  path to Windows Platform SDK (to build VSS .tlb)
  --tls-priority           default TLS protocol/cipher priority string
  --enable-gprof           QEMU profiling with gprof
  --enable-profiler        profiler support
  --enable-debug-stack-usage
                           track the maximum stack usage of stacks created by qemu_alloc_stack
  --enable-plugins
                           enable plugins via shared library loading
  --disable-containers     don't use containers for cross-building
  --gdb=GDB-path           gdb to use for gdbstub tests [$gdb_bin]
EOF
  meson_options_help
cat << EOF
  system          all system emulation targets
  user            supported user emulation targets
  linux-user      all linux usermode emulation targets
  bsd-user        all BSD usermode emulation targets
  guest-agent     build the QEMU Guest Agent
  pie             Position Independent Executables
  modules         modules support (non-Windows)
  module-upgrades try to load modules from alternate paths for upgrades
  debug-tcg       TCG debugging (default is disabled)
  debug-info      debugging information
  lto             Enable Link-Time Optimization.
  safe-stack      SafeStack Stack Smash Protection. Depends on
                  clang/llvm >= 3.7 and requires coroutine backend ucontext.
  membarrier      membarrier system call (for Linux 4.14+ or Windows)
  rdma            Enable RDMA-based migration
  pvrdma          Enable PVRDMA support
  vhost-net       vhost-net kernel acceleration support
  vhost-vsock     virtio sockets device support
  vhost-scsi      vhost-scsi kernel target support
  vhost-crypto    vhost-user-crypto backend support
  vhost-kernel    vhost kernel backend support
  vhost-user      vhost-user backend support
  vhost-vdpa      vhost-vdpa kernel backend support
  live-block-migration   Block migration in the main migration stream
  coroutine-pool  coroutine freelist (better performance)
  tpm             TPM support
  numa            libnuma support
  avx2            AVX2 optimization support
  avx512f         AVX512F optimization support
  replication     replication support
  opengl          opengl support
  xfsctl          xfsctl support
  qom-cast-debug  cast debugging support
  tools           build qemu-io, qemu-nbd and qemu-img tools
  bochs           bochs image format support
  cloop           cloop image format support
  dmg             dmg image format support
  qcow1           qcow v1 image format support
  vdi             vdi image format support
  vvfat           vvfat image format support
  qed             qed image format support
  parallels       parallels image format support
  crypto-afalg    Linux AF_ALG crypto backend driver
  debug-mutex     mutex debugging support
  rng-none        dummy RNG, avoid using /dev/(u)random and getrandom()
  gio             libgio support
  slirp-smbd      use smbd (at path --smbd=*) in slirp networking

NOTE: The object files are built at the place where configure is launched
EOF
exit 0
fi

# Remove old dependency files to make sure that they get properly regenerated
rm -f */config-devices.mak.d

if test -z "$python"
then
    error_exit "Python not found. Use --python=/path/to/python"
fi
if ! has "$make"
then
    error_exit "GNU make ($make) not found"
fi

# Note that if the Python conditional here evaluates True we will exit
# with status 1 which is a shell 'false' value.
if ! $python -c 'import sys; sys.exit(sys.version_info < (3,6))'; then
  error_exit "Cannot use '$python', Python >= 3.6 is required." \
      "Use --python=/path/to/python to specify a supported Python."
fi

# Preserve python version since some functionality is dependent on it
python_version=$($python -c 'import sys; print("%d.%d.%d" % (sys.version_info[0], sys.version_info[1], sys.version_info[2]))' 2>/dev/null)

# Suppress writing compiled files
python="$python -B"

if test -z "$meson"; then
    if test "$explicit_python" = no && has meson && version_ge "$(meson --version)" 0.59.3; then
        meson=meson
    elif test $git_submodules_action != 'ignore' ; then
        meson=git
    elif test -e "${source_path}/meson/meson.py" ; then
        meson=internal
    else
        if test "$explicit_python" = yes; then
            error_exit "--python requires using QEMU's embedded Meson distribution, but it was not found."
        else
            error_exit "Meson not found.  Use --meson=/path/to/meson"
        fi
    fi
else
    # Meson uses its own Python interpreter to invoke other Python scripts,
    # but the user wants to use the one they specified with --python.
    #
    # We do not want to override the distro Python interpreter (and sometimes
    # cannot: for example in Homebrew /usr/bin/meson is a bash script), so
    # just require --meson=git|internal together with --python.
    if test "$explicit_python" = yes; then
        case "$meson" in
            git | internal) ;;
            *) error_exit "--python requires using QEMU's embedded Meson distribution." ;;
        esac
    fi
fi

if test "$meson" = git; then
    git_submodules="${git_submodules} meson"
fi

case "$meson" in
    git | internal)
        meson="$python ${source_path}/meson/meson.py"
        ;;
    *) meson=$(command -v "$meson") ;;
esac

# Probe for ninja

if test -z "$ninja"; then
    for c in ninja ninja-build samu; do
        if has $c; then
            ninja=$(command -v "$c")
            break
        fi
    done
    if test -z "$ninja"; then
      error_exit "Cannot find Ninja"
    fi
fi

# Check that the C compiler works. Doing this here before testing
# the host CPU ensures that we had a valid CC to autodetect the
# $cpu var (and we should bail right here if that's not the case).
# It also allows the help message to be printed without a CC.
write_c_skeleton;
if compile_object ; then
  : C compiler works ok
else
    error_exit "\"$cc\" either does not exist or does not work"
fi
if ! compile_prog ; then
    error_exit "\"$cc\" cannot build an executable (is your linker broken?)"
fi

# Consult white-list to determine whether to enable werror
# by default.  Only enable by default for git builds
if test -z "$werror" ; then
    if test "$git_submodules_action" != "ignore" && \
        { test "$linux" = "yes" || test "$mingw32" = "yes"; }; then
        werror="yes"
    else
        werror="no"
    fi
fi

if test "$targetos" = "bogus"; then
    # Now that we know that we're not printing the help and that
    # the compiler works (so the results of the check_defines we used
    # to identify the OS are reliable), if we didn't recognize the
    # host OS we should stop now.
    error_exit "Unrecognized host OS (uname -s reports '$(uname -s)')"
fi

# Check whether the compiler matches our minimum requirements:
cat > $TMPC << EOF
#if defined(__clang_major__) && defined(__clang_minor__)
# ifdef __apple_build_version__
#  if __clang_major__ < 10 || (__clang_major__ == 10 && __clang_minor__ < 0)
#   error You need at least XCode Clang v10.0 to compile QEMU
#  endif
# else
#  if __clang_major__ < 6 || (__clang_major__ == 6 && __clang_minor__ < 0)
#   error You need at least Clang v6.0 to compile QEMU
#  endif
# endif
#elif defined(__GNUC__) && defined(__GNUC_MINOR__)
# if __GNUC__ < 7 || (__GNUC__ == 7 && __GNUC_MINOR__ < 4)
#  error You need at least GCC v7.4.0 to compile QEMU
# endif
#else
# error You either need GCC or Clang to compiler QEMU
#endif
int main (void) { return 0; }
EOF
if ! compile_prog "" "" ; then
    error_exit "You need at least GCC v7.4 or Clang v6.0 (or XCode Clang v10.0)"
fi

# Accumulate -Wfoo and -Wno-bar separately.
# We will list all of the enable flags first, and the disable flags second.
# Note that we do not add -Werror, because that would enable it for all
# configure tests. If a configure test failed due to -Werror this would
# just silently disable some features, so it's too error prone.

warn_flags=
add_to warn_flags -Wold-style-declaration
add_to warn_flags -Wold-style-definition
add_to warn_flags -Wtype-limits
add_to warn_flags -Wformat-security
add_to warn_flags -Wformat-y2k
add_to warn_flags -Winit-self
add_to warn_flags -Wignored-qualifiers
add_to warn_flags -Wempty-body
add_to warn_flags -Wnested-externs
add_to warn_flags -Wendif-labels
add_to warn_flags -Wexpansion-to-defined
add_to warn_flags -Wimplicit-fallthrough=2

nowarn_flags=
add_to nowarn_flags -Wno-initializer-overrides
add_to nowarn_flags -Wno-missing-include-dirs
add_to nowarn_flags -Wno-shift-negative-value
add_to nowarn_flags -Wno-string-plus-int
add_to nowarn_flags -Wno-typedef-redefinition
add_to nowarn_flags -Wno-tautological-type-limit-compare
add_to nowarn_flags -Wno-psabi

gcc_flags="$warn_flags $nowarn_flags"

cc_has_warning_flag() {
    write_c_skeleton;

    # Use the positive sense of the flag when testing for -Wno-wombat
    # support (gcc will happily accept the -Wno- form of unknown
    # warning options).
    optflag="$(echo $1 | sed -e 's/^-Wno-/-W/')"
    compile_prog "-Werror $optflag" ""
}

for flag in $gcc_flags; do
    if cc_has_warning_flag $flag ; then
        QEMU_CFLAGS="$QEMU_CFLAGS $flag"
    fi
done

if test "$stack_protector" != "no"; then
  cat > $TMPC << EOF
int main(int argc, char *argv[])
{
    char arr[64], *p = arr, *c = argv[0];
    while (*c) {
        *p++ = *c++;
    }
    return 0;
}
EOF
  gcc_flags="-fstack-protector-strong -fstack-protector-all"
  sp_on=0
  for flag in $gcc_flags; do
    # We need to check both a compile and a link, since some compiler
    # setups fail only on a .c->.o compile and some only at link time
    if compile_object "-Werror $flag" &&
       compile_prog "-Werror $flag" ""; then
      QEMU_CFLAGS="$QEMU_CFLAGS $flag"
      QEMU_LDFLAGS="$QEMU_LDFLAGS $flag"
      sp_on=1
      break
    fi
  done
  if test "$stack_protector" = yes; then
    if test $sp_on = 0; then
      error_exit "Stack protector not supported"
    fi
  fi
fi

# Disable -Wmissing-braces on older compilers that warn even for
# the "universal" C zero initializer {0}.
cat > $TMPC << EOF
struct {
  int a[2];
} x = {0};
EOF
if compile_object "-Werror" "" ; then
  :
else
  QEMU_CFLAGS="$QEMU_CFLAGS -Wno-missing-braces"
fi

# Our module code doesn't support Windows
if test "$modules" = "yes" && test "$mingw32" = "yes" ; then
  error_exit "Modules are not available for Windows"
fi

# module_upgrades is only reasonable if modules are enabled
if test "$modules" = "no" && test "$module_upgrades" = "yes" ; then
  error_exit "Can't enable module-upgrades as Modules are not enabled"
fi

# Static linking is not possible with plugins, modules or PIE
if test "$static" = "yes" ; then
  if test "$modules" = "yes" ; then
    error_exit "static and modules are mutually incompatible"
  fi
  if test "$plugins" = "yes"; then
    error_exit "static and plugins are mutually incompatible"
  else
    plugins="no"
  fi
fi

cat > $TMPC << EOF

#ifdef __linux__
#  define THREAD __thread
#else
#  define THREAD
#endif
static THREAD int tls_var;
int main(void) { return tls_var; }
EOF

# Check we support -fno-pie and -no-pie first; we will need the former for
# building ROMs, and both for everything if --disable-pie is passed.
if compile_prog "-Werror -fno-pie" "-no-pie"; then
  CFLAGS_NOPIE="-fno-pie"
  LDFLAGS_NOPIE="-no-pie"
fi

if test "$static" = "yes"; then
  if test "$pie" != "no" && compile_prog "-Werror -fPIE -DPIE" "-static-pie"; then
    CONFIGURE_CFLAGS="-fPIE -DPIE $CONFIGURE_CFLAGS"
    QEMU_LDFLAGS="-static-pie $QEMU_LDFLAGS"
    pie="yes"
  elif test "$pie" = "yes"; then
    error_exit "-static-pie not available due to missing toolchain support"
  else
    QEMU_LDFLAGS="-static $QEMU_LDFLAGS"
    pie="no"
  fi
elif test "$pie" = "no"; then
  CONFIGURE_CFLAGS="$CFLAGS_NOPIE $CONFIGURE_CFLAGS"
  CONFIGURE_LDFLAGS="$LDFLAGS_NOPIE $CONFIGURE_LDFLAGS"
elif compile_prog "-Werror -fPIE -DPIE" "-pie"; then
  CONFIGURE_CFLAGS="-fPIE -DPIE $CONFIGURE_CFLAGS"
  CONFIGURE_LDFLAGS="-pie $CONFIGURE_LDFLAGS"
  pie="yes"
elif test "$pie" = "yes"; then
  error_exit "PIE not available due to missing toolchain support"
else
  echo "Disabling PIE due to missing toolchain support"
  pie="no"
fi

# Detect support for PT_GNU_RELRO + DT_BIND_NOW.
# The combination is known as "full relro", because .got.plt is read-only too.
if compile_prog "" "-Wl,-z,relro -Wl,-z,now" ; then
  QEMU_LDFLAGS="-Wl,-z,relro -Wl,-z,now $QEMU_LDFLAGS"
fi

##########################################
# __sync_fetch_and_and requires at least -march=i486. Many toolchains
# use i686 as default anyway, but for those that don't, an explicit
# specification is necessary

if test "$cpu" = "i386"; then
  cat > $TMPC << EOF
static int sfaa(int *ptr)
{
  return __sync_fetch_and_and(ptr, 0);
}

int main(void)
{
  int val = 42;
  val = __sync_val_compare_and_swap(&val, 0, 1);
  sfaa(&val);
  return val;
}
EOF
  if ! compile_prog "" "" ; then
    QEMU_CFLAGS="-march=i486 $QEMU_CFLAGS"
  fi
fi

if test "$tcg" = "enabled"; then
    git_submodules="$git_submodules tests/fp/berkeley-testfloat-3"
    git_submodules="$git_submodules tests/fp/berkeley-softfloat-3"
fi

if test -z "${target_list+xxx}" ; then
    default_targets=yes
    for target in $default_target_list; do
        target_list="$target_list $target"
    done
    target_list="${target_list# }"
else
    default_targets=no
    target_list=$(echo "$target_list" | sed -e 's/,/ /g')
    for target in $target_list; do
        # Check that we recognised the target name; this allows a more
        # friendly error message than if we let it fall through.
        case " $default_target_list " in
            *" $target "*)
                ;;
            *)
                error_exit "Unknown target name '$target'"
                ;;
        esac
    done
fi

for target in $target_list; do
    # if a deprecated target is enabled we note it here
    if echo "$deprecated_targets_list" | grep -q "$target"; then
        add_to deprecated_features $target
    fi
done

# see if system emulation was really requested
case " $target_list " in
  *"-softmmu "*) softmmu=yes
  ;;
  *) softmmu=no
  ;;
esac

feature_not_found() {
  feature=$1
  remedy=$2

  error_exit "User requested feature $feature" \
      "configure was not able to find it." \
      "$remedy"
}

# ---
# big/little endian test
cat > $TMPC << EOF
#include <stdio.h>
short big_endian[] = { 0x4269, 0x4765, 0x4e64, 0x4961, 0x4e00, 0, };
short little_endian[] = { 0x694c, 0x7454, 0x654c, 0x6e45, 0x6944, 0x6e41, 0, };
int main(int argc, char *argv[])
{
    return printf("%s %s\n", (char *)big_endian, (char *)little_endian);
}
EOF

if compile_prog ; then
    if strings -a $TMPE | grep -q BiGeNdIaN ; then
        bigendian="yes"
    elif strings -a $TMPE | grep -q LiTtLeEnDiAn ; then
        bigendian="no"
    else
        echo big/little test failed
        exit 1
    fi
else
    echo big/little test failed
    exit 1
fi

##########################################
# system tools
if test -z "$want_tools"; then
    if test "$softmmu" = "no"; then
        want_tools=no
    else
        want_tools=yes
    fi
fi

#########################################
# vhost interdependencies and host support

# vhost backends
if test "$vhost_user" = "yes" && test "$linux" != "yes"; then
  error_exit "vhost-user is only available on Linux"
fi
test "$vhost_vdpa" = "" && vhost_vdpa=$linux
if test "$vhost_vdpa" = "yes" && test "$linux" != "yes"; then
  error_exit "vhost-vdpa is only available on Linux"
fi
test "$vhost_kernel" = "" && vhost_kernel=$linux
if test "$vhost_kernel" = "yes" && test "$linux" != "yes"; then
  error_exit "vhost-kernel is only available on Linux"
fi

# vhost-kernel devices
test "$vhost_scsi" = "" && vhost_scsi=$vhost_kernel
if test "$vhost_scsi" = "yes" && test "$vhost_kernel" != "yes"; then
  error_exit "--enable-vhost-scsi requires --enable-vhost-kernel"
fi
test "$vhost_vsock" = "" && vhost_vsock=$vhost_kernel
if test "$vhost_vsock" = "yes" && test "$vhost_kernel" != "yes"; then
  error_exit "--enable-vhost-vsock requires --enable-vhost-kernel"
fi

# vhost-user backends
test "$vhost_net_user" = "" && vhost_net_user=$vhost_user
if test "$vhost_net_user" = "yes" && test "$vhost_user" = "no"; then
  error_exit "--enable-vhost-net-user requires --enable-vhost-user"
fi
test "$vhost_crypto" = "" && vhost_crypto=$vhost_user
if test "$vhost_crypto" = "yes" && test "$vhost_user" = "no"; then
  error_exit "--enable-vhost-crypto requires --enable-vhost-user"
fi
test "$vhost_user_fs" = "" && vhost_user_fs=$vhost_user
if test "$vhost_user_fs" = "yes" && test "$vhost_user" = "no"; then
  error_exit "--enable-vhost-user-fs requires --enable-vhost-user"
fi
#vhost-vdpa backends
test "$vhost_net_vdpa" = "" && vhost_net_vdpa=$vhost_vdpa
if test "$vhost_net_vdpa" = "yes" && test "$vhost_vdpa" = "no"; then
  error_exit "--enable-vhost-net-vdpa requires --enable-vhost-vdpa"
fi

# OR the vhost-kernel, vhost-vdpa and vhost-user values for simplicity
if test "$vhost_net" = ""; then
  test "$vhost_net_user" = "yes" && vhost_net=yes
  test "$vhost_net_vdpa" = "yes" && vhost_net=yes
  test "$vhost_kernel" = "yes" && vhost_net=yes
fi

##########################################
# pkg-config probe

if ! has "$pkg_config_exe"; then
  error_exit "pkg-config binary '$pkg_config_exe' not found"
fi

##########################################
# xen probe

if test "$xen" != "disabled" ; then
  # Check whether Xen library path is specified via --extra-ldflags to avoid
  # overriding this setting with pkg-config output. If not, try pkg-config
  # to obtain all needed flags.

  if ! echo $EXTRA_LDFLAGS | grep tools/libxc > /dev/null && \
     $pkg_config --exists xencontrol ; then
    xen_ctrl_version="$(printf '%d%02d%02d' \
      $($pkg_config --modversion xencontrol | sed 's/\./ /g') )"
    xen=enabled
    xen_pc="xencontrol xenstore xenforeignmemory xengnttab"
    xen_pc="$xen_pc xenevtchn xendevicemodel"
    if $pkg_config --exists xentoolcore; then
      xen_pc="$xen_pc xentoolcore"
    fi
    xen_cflags="$($pkg_config --cflags $xen_pc)"
    xen_libs="$($pkg_config --libs $xen_pc)"
  else

    xen_libs="-lxenstore -lxenctrl"
    xen_stable_libs="-lxenforeignmemory -lxengnttab -lxenevtchn"

    # First we test whether Xen headers and libraries are available.
    # If no, we are done and there is no Xen support.
    # If yes, more tests are run to detect the Xen version.

    # Xen (any)
    cat > $TMPC <<EOF
#include <xenctrl.h>
int main(void) {
  return 0;
}
EOF
    if ! compile_prog "" "$xen_libs" ; then
      # Xen not found
      if test "$xen" = "enabled" ; then
        feature_not_found "xen" "Install xen devel"
      fi
      xen=disabled

    # Xen unstable
    elif
        cat > $TMPC <<EOF &&
#undef XC_WANT_COMPAT_DEVICEMODEL_API
#define __XEN_TOOLS__
#include <xendevicemodel.h>
#include <xenforeignmemory.h>
int main(void) {
  xendevicemodel_handle *xd;
  xenforeignmemory_handle *xfmem;

  xd = xendevicemodel_open(0, 0);
  xendevicemodel_pin_memory_cacheattr(xd, 0, 0, 0, 0);

  xfmem = xenforeignmemory_open(0, 0);
  xenforeignmemory_map_resource(xfmem, 0, 0, 0, 0, 0, NULL, 0, 0);

  return 0;
}
EOF
        compile_prog "" "$xen_libs -lxendevicemodel $xen_stable_libs -lxentoolcore"
      then
      xen_stable_libs="-lxendevicemodel $xen_stable_libs -lxentoolcore"
      xen_ctrl_version=41100
      xen=enabled
    elif
        cat > $TMPC <<EOF &&
#undef XC_WANT_COMPAT_MAP_FOREIGN_API
#include <xenforeignmemory.h>
#include <xentoolcore.h>
int main(void) {
  xenforeignmemory_handle *xfmem;

  xfmem = xenforeignmemory_open(0, 0);
  xenforeignmemory_map2(xfmem, 0, 0, 0, 0, 0, 0, 0);
  xentoolcore_restrict_all(0);

  return 0;
}
EOF
        compile_prog "" "$xen_libs -lxendevicemodel $xen_stable_libs -lxentoolcore"
      then
      xen_stable_libs="-lxendevicemodel $xen_stable_libs -lxentoolcore"
      xen_ctrl_version=41000
      xen=enabled
    elif
        cat > $TMPC <<EOF &&
#undef XC_WANT_COMPAT_DEVICEMODEL_API
#define __XEN_TOOLS__
#include <xendevicemodel.h>
int main(void) {
  xendevicemodel_handle *xd;

  xd = xendevicemodel_open(0, 0);
  xendevicemodel_close(xd);

  return 0;
}
EOF
        compile_prog "" "$xen_libs -lxendevicemodel $xen_stable_libs"
      then
      xen_stable_libs="-lxendevicemodel $xen_stable_libs"
      xen_ctrl_version=40900
      xen=enabled
    elif
        cat > $TMPC <<EOF &&
/*
 * If we have stable libs the we don't want the libxc compat
 * layers, regardless of what CFLAGS we may have been given.
 *
 * Also, check if xengnttab_grant_copy_segment_t is defined and
 * grant copy operation is implemented.
 */
#undef XC_WANT_COMPAT_EVTCHN_API
#undef XC_WANT_COMPAT_GNTTAB_API
#undef XC_WANT_COMPAT_MAP_FOREIGN_API
#include <xenctrl.h>
#include <xenstore.h>
#include <xenevtchn.h>
#include <xengnttab.h>
#include <xenforeignmemory.h>
#include <stdint.h>
#include <xen/hvm/hvm_info_table.h>
#if !defined(HVM_MAX_VCPUS)
# error HVM_MAX_VCPUS not defined
#endif
int main(void) {
  xc_interface *xc = NULL;
  xenforeignmemory_handle *xfmem;
  xenevtchn_handle *xe;
  xengnttab_handle *xg;
  xengnttab_grant_copy_segment_t* seg = NULL;

  xs_daemon_open();

  xc = xc_interface_open(0, 0, 0);
  xc_hvm_set_mem_type(0, 0, HVMMEM_ram_ro, 0, 0);
  xc_domain_add_to_physmap(0, 0, XENMAPSPACE_gmfn, 0, 0);
  xc_hvm_inject_msi(xc, 0, 0xf0000000, 0x00000000);
  xc_hvm_create_ioreq_server(xc, 0, HVM_IOREQSRV_BUFIOREQ_ATOMIC, NULL);

  xfmem = xenforeignmemory_open(0, 0);
  xenforeignmemory_map(xfmem, 0, 0, 0, 0, 0);

  xe = xenevtchn_open(0, 0);
  xenevtchn_fd(xe);

  xg = xengnttab_open(0, 0);
  xengnttab_grant_copy(xg, 0, seg);

  return 0;
}
EOF
        compile_prog "" "$xen_libs $xen_stable_libs"
      then
      xen_ctrl_version=40800
      xen=enabled
    elif
        cat > $TMPC <<EOF &&
/*
 * If we have stable libs the we don't want the libxc compat
 * layers, regardless of what CFLAGS we may have been given.
 */
#undef XC_WANT_COMPAT_EVTCHN_API
#undef XC_WANT_COMPAT_GNTTAB_API
#undef XC_WANT_COMPAT_MAP_FOREIGN_API
#include <xenctrl.h>
#include <xenstore.h>
#include <xenevtchn.h>
#include <xengnttab.h>
#include <xenforeignmemory.h>
#include <stdint.h>
#include <xen/hvm/hvm_info_table.h>
#if !defined(HVM_MAX_VCPUS)
# error HVM_MAX_VCPUS not defined
#endif
int main(void) {
  xc_interface *xc = NULL;
  xenforeignmemory_handle *xfmem;
  xenevtchn_handle *xe;
  xengnttab_handle *xg;

  xs_daemon_open();

  xc = xc_interface_open(0, 0, 0);
  xc_hvm_set_mem_type(0, 0, HVMMEM_ram_ro, 0, 0);
  xc_domain_add_to_physmap(0, 0, XENMAPSPACE_gmfn, 0, 0);
  xc_hvm_inject_msi(xc, 0, 0xf0000000, 0x00000000);
  xc_hvm_create_ioreq_server(xc, 0, HVM_IOREQSRV_BUFIOREQ_ATOMIC, NULL);

  xfmem = xenforeignmemory_open(0, 0);
  xenforeignmemory_map(xfmem, 0, 0, 0, 0, 0);

  xe = xenevtchn_open(0, 0);
  xenevtchn_fd(xe);

  xg = xengnttab_open(0, 0);
  xengnttab_map_grant_ref(xg, 0, 0, 0);

  return 0;
}
EOF
        compile_prog "" "$xen_libs $xen_stable_libs"
      then
      xen_ctrl_version=40701
      xen=enabled

    # Xen 4.6
    elif
        cat > $TMPC <<EOF &&
#include <xenctrl.h>
#include <xenstore.h>
#include <stdint.h>
#include <xen/hvm/hvm_info_table.h>
#if !defined(HVM_MAX_VCPUS)
# error HVM_MAX_VCPUS not defined
#endif
int main(void) {
  xc_interface *xc;
  xs_daemon_open();
  xc = xc_interface_open(0, 0, 0);
  xc_hvm_set_mem_type(0, 0, HVMMEM_ram_ro, 0, 0);
  xc_gnttab_open(NULL, 0);
  xc_domain_add_to_physmap(0, 0, XENMAPSPACE_gmfn, 0, 0);
  xc_hvm_inject_msi(xc, 0, 0xf0000000, 0x00000000);
  xc_hvm_create_ioreq_server(xc, 0, HVM_IOREQSRV_BUFIOREQ_ATOMIC, NULL);
  xc_reserved_device_memory_map(xc, 0, 0, 0, 0, NULL, 0);
  return 0;
}
EOF
        compile_prog "" "$xen_libs"
      then
      xen_ctrl_version=40600
      xen=enabled

    # Xen 4.5
    elif
        cat > $TMPC <<EOF &&
#include <xenctrl.h>
#include <xenstore.h>
#include <stdint.h>
#include <xen/hvm/hvm_info_table.h>
#if !defined(HVM_MAX_VCPUS)
# error HVM_MAX_VCPUS not defined
#endif
int main(void) {
  xc_interface *xc;
  xs_daemon_open();
  xc = xc_interface_open(0, 0, 0);
  xc_hvm_set_mem_type(0, 0, HVMMEM_ram_ro, 0, 0);
  xc_gnttab_open(NULL, 0);
  xc_domain_add_to_physmap(0, 0, XENMAPSPACE_gmfn, 0, 0);
  xc_hvm_inject_msi(xc, 0, 0xf0000000, 0x00000000);
  xc_hvm_create_ioreq_server(xc, 0, 0, NULL);
  return 0;
}
EOF
        compile_prog "" "$xen_libs"
      then
      xen_ctrl_version=40500
      xen=enabled

    elif
        cat > $TMPC <<EOF &&
#include <xenctrl.h>
#include <xenstore.h>
#include <stdint.h>
#include <xen/hvm/hvm_info_table.h>
#if !defined(HVM_MAX_VCPUS)
# error HVM_MAX_VCPUS not defined
#endif
int main(void) {
  xc_interface *xc;
  xs_daemon_open();
  xc = xc_interface_open(0, 0, 0);
  xc_hvm_set_mem_type(0, 0, HVMMEM_ram_ro, 0, 0);
  xc_gnttab_open(NULL, 0);
  xc_domain_add_to_physmap(0, 0, XENMAPSPACE_gmfn, 0, 0);
  xc_hvm_inject_msi(xc, 0, 0xf0000000, 0x00000000);
  return 0;
}
EOF
        compile_prog "" "$xen_libs"
      then
      xen_ctrl_version=40200
      xen=enabled

    else
      if test "$xen" = "enabled" ; then
        feature_not_found "xen (unsupported version)" \
                          "Install a supported xen (xen 4.2 or newer)"
      fi
      xen=disabled
    fi

    if test "$xen" = enabled; then
      if test $xen_ctrl_version -ge 40701  ; then
        xen_libs="$xen_libs $xen_stable_libs "
      fi
    fi
  fi
fi

##########################################
# RDMA needs OpenFabrics libraries
if test "$rdma" != "no" ; then
  cat > $TMPC <<EOF
#include <rdma/rdma_cma.h>
int main(void) { return 0; }
EOF
  rdma_libs="-lrdmacm -libverbs -libumad"
  if compile_prog "" "$rdma_libs" ; then
    rdma="yes"
  else
    if test "$rdma" = "yes" ; then
        error_exit \
            " OpenFabrics librdmacm/libibverbs/libibumad not present." \
            " Your options:" \
            "  (1) Fast: Install infiniband packages (devel) from your distro." \
            "  (2) Cleanest: Install libraries from www.openfabrics.org" \
            "  (3) Also: Install softiwarp if you don't have RDMA hardware"
    fi
    rdma="no"
  fi
fi

##########################################
# PVRDMA detection

cat > $TMPC <<EOF &&
#include <sys/mman.h>

int
main(void)
{
    char buf = 0;
    void *addr = &buf;
    addr = mremap(addr, 0, 1, MREMAP_MAYMOVE | MREMAP_FIXED);

    return 0;
}
EOF

if test "$rdma" = "yes" ; then
    case "$pvrdma" in
    "")
        if compile_prog "" ""; then
            pvrdma="yes"
        else
            pvrdma="no"
        fi
        ;;
    "yes")
        if ! compile_prog "" ""; then
            error_exit "PVRDMA is not supported since mremap is not implemented"
        fi
        pvrdma="yes"
        ;;
    "no")
        pvrdma="no"
        ;;
    esac
else
    if test "$pvrdma" = "yes" ; then
        error_exit "PVRDMA requires rdma suppport"
    fi
    pvrdma="no"
fi

# Let's see if enhanced reg_mr is supported
if test "$pvrdma" = "yes" ; then

cat > $TMPC <<EOF &&
#include <infiniband/verbs.h>

int
main(void)
{
    struct ibv_mr *mr;
    struct ibv_pd *pd = NULL;
    size_t length = 10;
    uint64_t iova = 0;
    int access = 0;
    void *addr = NULL;

    mr = ibv_reg_mr_iova(pd, addr, length, iova, access);

    ibv_dereg_mr(mr);

    return 0;
}
EOF
    if ! compile_prog "" "-libverbs"; then
        QEMU_CFLAGS="$QEMU_CFLAGS -DLEGACY_RDMA_REG_MR"
    fi
fi

##########################################
# xfsctl() probe, used for file-posix.c
if test "$xfs" != "no" ; then
  cat > $TMPC << EOF
#include <stddef.h>  /* NULL */
#include <xfs/xfs.h>
int main(void)
{
    xfsctl(NULL, 0, 0, NULL);
    return 0;
}
EOF
  if compile_prog "" "" ; then
    xfs="yes"
  else
    if test "$xfs" = "yes" ; then
      feature_not_found "xfs" "Install xfsprogs/xfslibs devel"
    fi
    xfs=no
  fi
fi

##########################################
# plugin linker support probe

if test "$plugins" != "no"; then

    #########################################
    # See if --dynamic-list is supported by the linker

    ld_dynamic_list="no"
    cat > $TMPTXT <<EOF
{
  foo;
};
EOF

        cat > $TMPC <<EOF
#include <stdio.h>
void foo(void);

void foo(void)
{
  printf("foo\n");
}

int main(void)
{
  foo();
  return 0;
}
EOF

    if compile_prog "" "-Wl,--dynamic-list=$TMPTXT" ; then
        ld_dynamic_list="yes"
    fi

    #########################################
    # See if -exported_symbols_list is supported by the linker

    ld_exported_symbols_list="no"
    cat > $TMPTXT <<EOF
  _foo
EOF

    if compile_prog "" "-Wl,-exported_symbols_list,$TMPTXT" ; then
        ld_exported_symbols_list="yes"
    fi

    if test "$ld_dynamic_list" = "no" &&
       test "$ld_exported_symbols_list" = "no" ; then
        if test "$plugins" = "yes"; then
            error_exit \
                "Plugin support requires dynamic linking and specifying a set of symbols " \
                "that are exported to plugins. Unfortunately your linker doesn't " \
                "support the flag (--dynamic-list or -exported_symbols_list) used " \
                "for this purpose."
        else
            plugins="no"
        fi
    else
        plugins="yes"
    fi
fi

##########################################
# glib support probe

glib_req_ver=2.56
glib_modules=gthread-2.0
if test "$modules" = yes; then
    glib_modules="$glib_modules gmodule-export-2.0"
elif test "$plugins" = "yes"; then
    glib_modules="$glib_modules gmodule-no-export-2.0"
fi

for i in $glib_modules; do
    if $pkg_config --atleast-version=$glib_req_ver $i; then
        glib_cflags=$($pkg_config --cflags $i)
        glib_libs=$($pkg_config --libs $i)
    else
        error_exit "glib-$glib_req_ver $i is required to compile QEMU"
    fi
done

# This workaround is required due to a bug in pkg-config file for glib as it
# doesn't define GLIB_STATIC_COMPILATION for pkg-config --static

if test "$static" = yes && test "$mingw32" = yes; then
    glib_cflags="-DGLIB_STATIC_COMPILATION $glib_cflags"
fi

if ! test "$gio" = "no"; then
    pass=no
    if $pkg_config --atleast-version=$glib_req_ver gio-2.0; then
        gio_cflags=$($pkg_config --cflags gio-2.0)
        gio_libs=$($pkg_config --libs gio-2.0)
        gdbus_codegen=$($pkg_config --variable=gdbus_codegen gio-2.0)
        if ! has "$gdbus_codegen"; then
            gdbus_codegen=
        fi
        # Check that the libraries actually work -- Ubuntu 18.04 ships
        # with pkg-config --static --libs data for gio-2.0 that is missing
        # -lblkid and will give a link error.
        cat > $TMPC <<EOF
#include <gio/gio.h>
int main(void)
{
    g_dbus_proxy_new_sync(0, 0, 0, 0, 0, 0, 0, 0);
    return 0;
}
EOF
        if compile_prog "$gio_cflags" "$gio_libs" ; then
            pass=yes
        else
            pass=no
        fi

        if test "$pass" = "yes" &&
            $pkg_config --atleast-version=$glib_req_ver gio-unix-2.0; then
            gio_cflags="$gio_cflags $($pkg_config --cflags gio-unix-2.0)"
            gio_libs="$gio_libs $($pkg_config --libs gio-unix-2.0)"
        fi
    fi

    if test "$pass" = "no"; then
        if test "$gio" = "yes"; then
            feature_not_found "gio" "Install libgio >= 2.0"
        else
            gio=no
        fi
    else
        gio=yes
    fi
fi

# Sanity check that the current size_t matches the
# size that glib thinks it should be. This catches
# problems on multi-arch where people try to build
# 32-bit QEMU while pointing at 64-bit glib headers
cat > $TMPC <<EOF
#include <glib.h>
#include <unistd.h>

#define QEMU_BUILD_BUG_ON(x) \
  typedef char qemu_build_bug_on[(x)?-1:1] __attribute__((unused));

int main(void) {
   QEMU_BUILD_BUG_ON(sizeof(size_t) != GLIB_SIZEOF_SIZE_T);
   return 0;
}
EOF

if ! compile_prog "$glib_cflags" "$glib_libs" ; then
    error_exit "sizeof(size_t) doesn't match GLIB_SIZEOF_SIZE_T."\
               "You probably need to set PKG_CONFIG_LIBDIR"\
	       "to point to the right pkg-config files for your"\
	       "build target"
fi

# Silence clang warnings triggered by glib < 2.57.2
cat > $TMPC << EOF
#include <glib.h>
typedef struct Foo {
    int i;
} Foo;
static void foo_free(Foo *f)
{
    g_free(f);
}
G_DEFINE_AUTOPTR_CLEANUP_FUNC(Foo, foo_free);
int main(void) { return 0; }
EOF
if ! compile_prog "$glib_cflags -Werror" "$glib_libs" ; then
    if cc_has_warning_flag "-Wno-unused-function"; then
        glib_cflags="$glib_cflags -Wno-unused-function"
        CONFIGURE_CFLAGS="$CONFIGURE_CFLAGS -Wno-unused-function"
    fi
fi

##########################################
# SHA command probe for modules
if test "$modules" = yes; then
    shacmd_probe="sha1sum sha1 shasum"
    for c in $shacmd_probe; do
        if has $c; then
            shacmd="$c"
            break
        fi
    done
    if test "$shacmd" = ""; then
        error_exit "one of the checksum commands is required to enable modules: $shacmd_probe"
    fi
fi

##########################################
# TPM emulation is only on POSIX

if test "$tpm" = ""; then
  if test "$mingw32" = "yes"; then
    tpm=no
  else
    tpm=yes
  fi
elif test "$tpm" = "yes"; then
  if test "$mingw32" = "yes" ; then
    error_exit "TPM emulation only available on POSIX systems"
  fi
fi

##########################################
# fdt probe

case "$fdt" in
  auto | enabled | internal)
    # Simpler to always update submodule, even if not needed.
    git_submodules="${git_submodules} dtc"
    ;;
esac

##########################################
# opengl probe (for sdl2, gtk)

if test "$opengl" != "no" ; then
  epoxy=no
  if $pkg_config epoxy; then
    cat > $TMPC << EOF
#include <epoxy/egl.h>
int main(void) { return 0; }
EOF
    if compile_prog "" "" ; then
      epoxy=yes
    fi
  fi

  if test "$epoxy" = "yes" ; then
    opengl_cflags="$($pkg_config --cflags epoxy)"
    opengl_libs="$($pkg_config --libs epoxy)"
    opengl=yes
  else
    if test "$opengl" = "yes" ; then
      feature_not_found "opengl" "Please install epoxy with EGL"
    fi
    opengl_cflags=""
    opengl_libs=""
    opengl=no
  fi
fi

##########################################
# libnuma probe

if test "$numa" != "no" ; then
  cat > $TMPC << EOF
#include <numa.h>
int main(void) { return numa_available(); }
EOF

  if compile_prog "" "-lnuma" ; then
    numa=yes
    numa_libs="-lnuma"
  else
    if test "$numa" = "yes" ; then
      feature_not_found "numa" "install numactl devel"
    fi
    numa=no
  fi
fi

# check for usbfs
have_usbfs=no
if test "$linux_user" = "yes"; then
  cat > $TMPC << EOF
#include <linux/usbdevice_fs.h>

#ifndef USBDEVFS_GET_CAPABILITIES
#error "USBDEVFS_GET_CAPABILITIES undefined"
#endif

#ifndef USBDEVFS_DISCONNECT_CLAIM
#error "USBDEVFS_DISCONNECT_CLAIM undefined"
#endif

int main(void)
{
    return 0;
}
EOF
  if compile_prog "" ""; then
    have_usbfs=yes
  fi
fi

##########################################
# check if we have VSS SDK headers for win

if test "$mingw32" = "yes" && test "$guest_agent" != "no" && \
        test "$vss_win32_sdk" != "no" ; then
  case "$vss_win32_sdk" in
    "")   vss_win32_include="-isystem $source_path" ;;
    *\ *) # The SDK is installed in "Program Files" by default, but we cannot
          # handle path with spaces. So we symlink the headers into ".sdk/vss".
          vss_win32_include="-isystem $source_path/.sdk/vss"
	  symlink "$vss_win32_sdk/inc" "$source_path/.sdk/vss/inc"
	  ;;
    *)    vss_win32_include="-isystem $vss_win32_sdk"
  esac
  cat > $TMPC << EOF
#define __MIDL_user_allocate_free_DEFINED__
#include <inc/win2003/vss.h>
int main(void) { return VSS_CTX_BACKUP; }
EOF
  if compile_prog "$vss_win32_include" "" ; then
    guest_agent_with_vss="yes"
    QEMU_CFLAGS="$QEMU_CFLAGS $vss_win32_include"
    libs_qga="-lole32 -loleaut32 -lshlwapi -lstdc++ -Wl,--enable-stdcall-fixup $libs_qga"
    qga_vss_provider="qga/vss-win32/qga-vss.dll qga/vss-win32/qga-vss.tlb"
  else
    if test "$vss_win32_sdk" != "" ; then
      echo "ERROR: Please download and install Microsoft VSS SDK:"
      echo "ERROR:   http://www.microsoft.com/en-us/download/details.aspx?id=23490"
      echo "ERROR: On POSIX-systems, you can extract the SDK headers by:"
      echo "ERROR:   scripts/extract-vsssdk-headers setup.exe"
      echo "ERROR: The headers are extracted in the directory \`inc'."
      feature_not_found "VSS support"
    fi
    guest_agent_with_vss="no"
  fi
fi

##########################################
# lookup Windows platform SDK (if not specified)
# The SDK is needed only to build .tlb (type library) file of guest agent
# VSS provider from the source. It is usually unnecessary because the
# pre-compiled .tlb file is included.

if test "$mingw32" = "yes" && test "$guest_agent" != "no" && \
        test "$guest_agent_with_vss" = "yes" ; then
  if test -z "$win_sdk"; then
    programfiles="$PROGRAMFILES"
    test -n "$PROGRAMW6432" && programfiles="$PROGRAMW6432"
    if test -n "$programfiles"; then
      win_sdk=$(ls -d "$programfiles/Microsoft SDKs/Windows/v"* | tail -1) 2>/dev/null
    else
      feature_not_found "Windows SDK"
    fi
  elif test "$win_sdk" = "no"; then
    win_sdk=""
  fi
fi

##########################################
# check if mingw environment provides a recent ntddscsi.h
if test "$mingw32" = "yes" && test "$guest_agent" != "no"; then
  cat > $TMPC << EOF
#include <windows.h>
#include <ntddscsi.h>
int main(void) {
#if !defined(IOCTL_SCSI_GET_ADDRESS)
#error Missing required ioctl definitions
#endif
  SCSI_ADDRESS addr = { .Lun = 0, .TargetId = 0, .PathId = 0 };
  return addr.Lun;
}
EOF
  if compile_prog "" "" ; then
    guest_agent_ntddscsi=yes
    libs_qga="-lsetupapi -lcfgmgr32 $libs_qga"
  fi
fi

##########################################
# capstone

case "$capstone" in
  auto | enabled | internal)
    # Simpler to always update submodule, even if not needed.
    git_submodules="${git_submodules} capstone"
    ;;
esac

##########################################
# check and set a backend for coroutine

# We prefer ucontext, but it's not always possible. The fallback
# is sigcontext. On Windows the only valid backend is the Windows
# specific one.

ucontext_works=no
if test "$darwin" != "yes"; then
  cat > $TMPC << EOF
#include <ucontext.h>
#ifdef __stub_makecontext
#error Ignoring glibc stub makecontext which will always fail
#endif
int main(void) { makecontext(0, 0, 0); return 0; }
EOF
  if compile_prog "" "" ; then
    ucontext_works=yes
  fi
fi

if test "$coroutine" = ""; then
  if test "$mingw32" = "yes"; then
    coroutine=win32
  elif test "$ucontext_works" = "yes"; then
    coroutine=ucontext
  else
    coroutine=sigaltstack
  fi
else
  case $coroutine in
  windows)
    if test "$mingw32" != "yes"; then
      error_exit "'windows' coroutine backend only valid for Windows"
    fi
    # Unfortunately the user visible backend name doesn't match the
    # coroutine-*.c filename for this case, so we have to adjust it here.
    coroutine=win32
    ;;
  ucontext)
    if test "$ucontext_works" != "yes"; then
      feature_not_found "ucontext"
    fi
    ;;
  sigaltstack)
    if test "$mingw32" = "yes"; then
      error_exit "only the 'windows' coroutine backend is valid for Windows"
    fi
    ;;
  *)
    error_exit "unknown coroutine backend $coroutine"
    ;;
  esac
fi

if test "$coroutine_pool" = ""; then
  coroutine_pool=yes
fi

if test "$debug_stack_usage" = "yes"; then
  if test "$coroutine_pool" = "yes"; then
    echo "WARN: disabling coroutine pool for stack usage debugging"
    coroutine_pool=no
  fi
fi

##################################################
# SafeStack


if test "$safe_stack" = "yes"; then
cat > $TMPC << EOF
int main(int argc, char *argv[])
{
#if ! __has_feature(safe_stack)
#error SafeStack Disabled
#endif
    return 0;
}
EOF
  flag="-fsanitize=safe-stack"
  # Check that safe-stack is supported and enabled.
  if compile_prog "-Werror $flag" "$flag"; then
    # Flag needed both at compilation and at linking
    QEMU_CFLAGS="$QEMU_CFLAGS $flag"
    QEMU_LDFLAGS="$QEMU_LDFLAGS $flag"
  else
    error_exit "SafeStack not supported by your compiler"
  fi
  if test "$coroutine" != "ucontext"; then
    error_exit "SafeStack is only supported by the coroutine backend ucontext"
  fi
else
cat > $TMPC << EOF
int main(int argc, char *argv[])
{
#if defined(__has_feature)
#if __has_feature(safe_stack)
#error SafeStack Enabled
#endif
#endif
    return 0;
}
EOF
if test "$safe_stack" = "no"; then
  # Make sure that safe-stack is disabled
  if ! compile_prog "-Werror" ""; then
    # SafeStack was already enabled, try to explicitly remove the feature
    flag="-fno-sanitize=safe-stack"
    if ! compile_prog "-Werror $flag" "$flag"; then
      error_exit "Configure cannot disable SafeStack"
    fi
    QEMU_CFLAGS="$QEMU_CFLAGS $flag"
    QEMU_LDFLAGS="$QEMU_LDFLAGS $flag"
  fi
else # "$safe_stack" = ""
  # Set safe_stack to yes or no based on pre-existing flags
  if compile_prog "-Werror" ""; then
    safe_stack="no"
  else
    safe_stack="yes"
    if test "$coroutine" != "ucontext"; then
      error_exit "SafeStack is only supported by the coroutine backend ucontext"
    fi
  fi
fi
fi

########################################
# check if cpuid.h is usable.

cat > $TMPC << EOF
#include <cpuid.h>
int main(void) {
    unsigned a, b, c, d;
    int max = __get_cpuid_max(0, 0);

    if (max >= 1) {
        __cpuid(1, a, b, c, d);
    }

    if (max >= 7) {
        __cpuid_count(7, 0, a, b, c, d);
    }

    return 0;
}
EOF
if compile_prog "" "" ; then
    cpuid_h=yes
fi

##########################################
# avx2 optimization requirement check
#
# There is no point enabling this if cpuid.h is not usable,
# since we won't be able to select the new routines.

if test "$cpuid_h" = "yes" && test "$avx2_opt" != "no"; then
  cat > $TMPC << EOF
#pragma GCC push_options
#pragma GCC target("avx2")
#include <cpuid.h>
#include <immintrin.h>
static int bar(void *a) {
    __m256i x = *(__m256i *)a;
    return _mm256_testz_si256(x, x);
}
int main(int argc, char *argv[]) { return bar(argv[0]); }
EOF
  if compile_object "-Werror" ; then
    avx2_opt="yes"
  else
    avx2_opt="no"
  fi
fi

##########################################
# avx512f optimization requirement check
#
# There is no point enabling this if cpuid.h is not usable,
# since we won't be able to select the new routines.
# by default, it is turned off.
# if user explicitly want to enable it, check environment

if test "$cpuid_h" = "yes" && test "$avx512f_opt" = "yes"; then
  cat > $TMPC << EOF
#pragma GCC push_options
#pragma GCC target("avx512f")
#include <cpuid.h>
#include <immintrin.h>
static int bar(void *a) {
    __m512i x = *(__m512i *)a;
    return _mm512_test_epi64_mask(x, x);
}
int main(int argc, char *argv[])
{
	return bar(argv[0]);
}
EOF
  if ! compile_object "-Werror" ; then
    avx512f_opt="no"
  fi
else
  avx512f_opt="no"
fi

########################################
# check if __[u]int128_t is usable.

int128=no
cat > $TMPC << EOF
__int128_t a;
__uint128_t b;
int main (void) {
  a = a + b;
  b = a * b;
  a = a * a;
  return 0;
}
EOF
if compile_prog "" "" ; then
    int128=yes
fi

#########################################
# See if 128-bit atomic operations are supported.

atomic128=no
if test "$int128" = "yes"; then
  cat > $TMPC << EOF
int main(void)
{
  unsigned __int128 x = 0, y = 0;
  y = __atomic_load(&x, 0);
  __atomic_store(&x, y, 0);
  __atomic_compare_exchange(&x, &y, x, 0, 0, 0);
  return 0;
}
EOF
  if compile_prog "" "" ; then
    atomic128=yes
  fi
fi

cmpxchg128=no
if test "$int128" = yes && test "$atomic128" = no; then
  cat > $TMPC << EOF
int main(void)
{
  unsigned __int128 x = 0, y = 0;
  __sync_val_compare_and_swap_16(&x, y, x);
  return 0;
}
EOF
  if compile_prog "" "" ; then
    cmpxchg128=yes
  fi
fi

########################################
# check if ccache is interfering with
# semantic analysis of macros

unset CCACHE_CPP2
ccache_cpp2=no
cat > $TMPC << EOF
static const int Z = 1;
#define fn() ({ Z; })
#define TAUT(X) ((X) == Z)
#define PAREN(X, Y) (X == Y)
#define ID(X) (X)
int main(int argc, char *argv[])
{
    int x = 0, y = 0;
    x = ID(x);
    x = fn();
    fn();
    if (PAREN(x, y)) return 0;
    if (TAUT(Z)) return 0;
    return 0;
}
EOF

if ! compile_object "-Werror"; then
    ccache_cpp2=yes
fi

#################################################
# clang does not support glibc + FORTIFY_SOURCE.

if test "$fortify_source" != "no"; then
  if echo | $cc -dM -E - | grep __clang__ > /dev/null 2>&1 ; then
    fortify_source="no";
  elif test -n "$cxx" && has $cxx &&
       echo | $cxx -dM -E - | grep __clang__ >/dev/null 2>&1 ; then
    fortify_source="no";
  else
    fortify_source="yes"
  fi
fi

##########################################
# check for usable membarrier system call
if test "$membarrier" = "yes"; then
    have_membarrier=no
    if test "$mingw32" = "yes" ; then
        have_membarrier=yes
    elif test "$linux" = "yes" ; then
        cat > $TMPC << EOF
    #include <linux/membarrier.h>
    #include <sys/syscall.h>
    #include <unistd.h>
    #include <stdlib.h>
    int main(void) {
        syscall(__NR_membarrier, MEMBARRIER_CMD_QUERY, 0);
        syscall(__NR_membarrier, MEMBARRIER_CMD_SHARED, 0);
	exit(0);
    }
EOF
        if compile_prog "" "" ; then
            have_membarrier=yes
        fi
    fi
    if test "$have_membarrier" = "no"; then
      feature_not_found "membarrier" "membarrier system call not available"
    fi
else
    # Do not enable it by default even for Mingw32, because it doesn't
    # work on Wine.
    membarrier=no
fi

##########################################
# check for usable AF_ALG environment
have_afalg=no
cat > $TMPC << EOF
#include <errno.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <linux/if_alg.h>
int main(void) {
    int sock;
    sock = socket(AF_ALG, SOCK_SEQPACKET, 0);
    return sock;
}
EOF
if compile_prog "" "" ; then
    have_afalg=yes
fi
if test "$crypto_afalg" = "yes"
then
    if test "$have_afalg" != "yes"
    then
	error_exit "AF_ALG requested but could not be detected"
    fi
fi


##########################################
# checks for sanitizers

have_asan=no
have_ubsan=no
have_asan_iface_h=no
have_asan_iface_fiber=no

if test "$sanitizers" = "yes" ; then
  write_c_skeleton
  if compile_prog "$CPU_CFLAGS -Werror -fsanitize=address" ""; then
      have_asan=yes
  fi

  # we could use a simple skeleton for flags checks, but this also
  # detect the static linking issue of ubsan, see also:
  # https://gcc.gnu.org/bugzilla/show_bug.cgi?id=84285
  cat > $TMPC << EOF
#include <stdlib.h>
int main(void) {
    void *tmp = malloc(10);
    if (tmp != NULL) {
        return *(int *)(tmp + 2);
    }
    return 1;
}
EOF
  if compile_prog "$CPU_CFLAGS -Werror -fsanitize=undefined" ""; then
      have_ubsan=yes
  fi

  if check_include "sanitizer/asan_interface.h" ; then
      have_asan_iface_h=yes
  fi

  cat > $TMPC << EOF
#include <sanitizer/asan_interface.h>
int main(void) {
  __sanitizer_start_switch_fiber(0, 0, 0);
  return 0;
}
EOF
  if compile_prog "$CPU_CFLAGS -Werror -fsanitize=address" "" ; then
      have_asan_iface_fiber=yes
  fi
fi

# Thread sanitizer is, for now, much noisier than the other sanitizers;
# keep it separate until that is not the case.
if test "$tsan" = "yes" && test "$sanitizers" = "yes"; then
  error_exit "TSAN is not supported with other sanitiziers."
fi
have_tsan=no
have_tsan_iface_fiber=no
if test "$tsan" = "yes" ; then
  write_c_skeleton
  if compile_prog "$CPU_CFLAGS -Werror -fsanitize=thread" "" ; then
      have_tsan=yes
  fi
  cat > $TMPC << EOF
#include <sanitizer/tsan_interface.h>
int main(void) {
  __tsan_create_fiber(0);
  return 0;
}
EOF
  if compile_prog "$CPU_CFLAGS -Werror -fsanitize=thread" "" ; then
      have_tsan_iface_fiber=yes
  fi
fi

##########################################
# check for slirp

case "$slirp" in
  auto | enabled | internal)
    # Simpler to always update submodule, even if not needed.
    git_submodules="${git_submodules} slirp"
    ;;
esac

# Check for slirp smbd dupport
: ${smbd=${SMBD-/usr/sbin/smbd}}
if test "$slirp_smbd" != "no" ; then
  if test "$mingw32" = "yes" ; then
    if test "$slirp_smbd" = "yes" ; then
      error_exit "Host smbd not supported on this platform."
    fi
    slirp_smbd=no
  else
    slirp_smbd=yes
  fi
fi

##########################################
# check for usable __NR_keyctl syscall

if test "$linux" = "yes" ; then

    have_keyring=no
    cat > $TMPC << EOF
#include <errno.h>
#include <asm/unistd.h>
#include <linux/keyctl.h>
#include <unistd.h>
int main(void) {
    return syscall(__NR_keyctl, KEYCTL_READ, 0, NULL, NULL, 0);
}
EOF
    if compile_prog "" "" ; then
        have_keyring=yes
    fi
fi
if test "$secret_keyring" != "no"
then
    if test "$have_keyring" = "yes"
    then
	secret_keyring=yes
    else
	if test "$secret_keyring" = "yes"
	then
	    error_exit "syscall __NR_keyctl requested, \
but not implemented on your system"
	else
	    secret_keyring=no
	fi
    fi
fi

##########################################
# End of CC checks
# After here, no more $cc or $ld runs

write_c_skeleton

if test "$gcov" = "yes" ; then
  :
elif test "$fortify_source" = "yes" ; then
  QEMU_CFLAGS="-U_FORTIFY_SOURCE -D_FORTIFY_SOURCE=2 $QEMU_CFLAGS"
  debug=no
fi

case "$ARCH" in
alpha)
  # Ensure there's only a single GP
  QEMU_CFLAGS="-msmall-data $QEMU_CFLAGS"
;;
esac

if test "$gprof" = "yes" ; then
  QEMU_CFLAGS="-p $QEMU_CFLAGS"
  QEMU_LDFLAGS="-p $QEMU_LDFLAGS"
fi

if test "$have_asan" = "yes"; then
  QEMU_CFLAGS="-fsanitize=address $QEMU_CFLAGS"
  QEMU_LDFLAGS="-fsanitize=address $QEMU_LDFLAGS"
  if test "$have_asan_iface_h" = "no" ; then
      echo "ASAN build enabled, but ASAN header missing." \
           "Without code annotation, the report may be inferior."
  elif test "$have_asan_iface_fiber" = "no" ; then
      echo "ASAN build enabled, but ASAN header is too old." \
           "Without code annotation, the report may be inferior."
  fi
fi
if test "$have_tsan" = "yes" ; then
  if test "$have_tsan_iface_fiber" = "yes" ; then
    QEMU_CFLAGS="-fsanitize=thread $QEMU_CFLAGS"
    QEMU_LDFLAGS="-fsanitize=thread $QEMU_LDFLAGS"
  else
    error_exit "Cannot enable TSAN due to missing fiber annotation interface."
  fi
elif test "$tsan" = "yes" ; then
  error_exit "Cannot enable TSAN due to missing sanitize thread interface."
fi
if test "$have_ubsan" = "yes"; then
  QEMU_CFLAGS="-fsanitize=undefined $QEMU_CFLAGS"
  QEMU_LDFLAGS="-fsanitize=undefined $QEMU_LDFLAGS"
fi

##########################################

# Exclude --warn-common with TSan to suppress warnings from the TSan libraries.
if test "$solaris" = "no" && test "$tsan" = "no"; then
    if $ld --version 2>/dev/null | grep "GNU ld" >/dev/null 2>/dev/null ; then
        QEMU_LDFLAGS="-Wl,--warn-common $QEMU_LDFLAGS"
    fi
fi

# Use ASLR, no-SEH and DEP if available
if test "$mingw32" = "yes" ; then
    flags="--no-seh --nxcompat"

    # Disable ASLR for debug builds to allow debugging with gdb
    if test "$debug" = "no" ; then
        flags="--dynamicbase $flags"
    fi

    for flag in $flags; do
        if ld_has $flag ; then
            QEMU_LDFLAGS="-Wl,$flag $QEMU_LDFLAGS"
        fi
    done
fi

# Probe for guest agent support/options

if [ "$guest_agent" != "no" ]; then
  if [ "$softmmu" = no -a "$want_tools" = no ] ; then
      guest_agent=no
  elif [ "$linux" = "yes" -o "$bsd" = "yes" -o "$solaris" = "yes" -o "$mingw32" = "yes" ] ; then
      guest_agent=yes
  elif [ "$guest_agent" != yes ]; then
      guest_agent=no
  else
      error_exit "Guest agent is not supported on this platform"
  fi
fi

# Guest agent Windows MSI package

if test "$QEMU_GA_MANUFACTURER" = ""; then
  QEMU_GA_MANUFACTURER=QEMU
fi
if test "$QEMU_GA_DISTRO" = ""; then
  QEMU_GA_DISTRO=Linux
fi
if test "$QEMU_GA_VERSION" = ""; then
    QEMU_GA_VERSION=$(cat $source_path/VERSION)
fi

QEMU_GA_MSI_MINGW_DLL_PATH="$($pkg_config --variable=prefix glib-2.0)/bin"

# Mac OS X ships with a broken assembler
roms=
if { test "$cpu" = "i386" || test "$cpu" = "x86_64"; } && \
        test "$targetos" != "darwin" && test "$targetos" != "sunos" && \
        test "$targetos" != "haiku" && test "$softmmu" = yes ; then
    # Different host OS linkers have different ideas about the name of the ELF
    # emulation. Linux and OpenBSD/amd64 use 'elf_i386'; FreeBSD uses the _fbsd
    # variant; OpenBSD/i386 uses the _obsd variant; and Windows uses i386pe.
    for emu in elf_i386 elf_i386_fbsd elf_i386_obsd i386pe; do
        if "$ld" -verbose 2>&1 | grep -q "^[[:space:]]*$emu[[:space:]]*$"; then
            ld_i386_emulation="$emu"
            roms="optionrom"
            break
        fi
    done
fi

# Only build s390-ccw bios if we're on s390x and the compiler has -march=z900
# or -march=z10 (which is the lowest architecture level that Clang supports)
if test "$cpu" = "s390x" ; then
  write_c_skeleton
  compile_prog "-march=z900" ""
  has_z900=$?
  if [ $has_z900 = 0 ] || compile_object "-march=z10 -msoft-float -Werror"; then
    if [ $has_z900 != 0 ]; then
      echo "WARNING: Your compiler does not support the z900!"
      echo "         The s390-ccw bios will only work with guest CPUs >= z10."
    fi
    roms="$roms s390-ccw"
    # SLOF is required for building the s390-ccw firmware on s390x,
    # since it is using the libnet code from SLOF for network booting.
    git_submodules="${git_submodules} roms/SLOF"
  fi
fi

# Check that the C++ compiler exists and works with the C compiler.
# All the QEMU_CXXFLAGS are based on QEMU_CFLAGS. Keep this at the end to don't miss any other that could be added.
if has $cxx; then
    cat > $TMPC <<EOF
int c_function(void);
int main(void) { return c_function(); }
EOF

    compile_object

    cat > $TMPCXX <<EOF
extern "C" {
   int c_function(void);
}
int c_function(void) { return 42; }
EOF

    update_cxxflags

    if do_cxx $CXXFLAGS $EXTRA_CXXFLAGS $CONFIGURE_CXXFLAGS $QEMU_CXXFLAGS -o $TMPE $TMPCXX $TMPO $QEMU_LDFLAGS; then
        # C++ compiler $cxx works ok with C compiler $cc
        :
    else
        echo "C++ compiler $cxx does not work with C compiler $cc"
        echo "Disabling C++ specific optional code"
        cxx=
    fi
else
    echo "No C++ compiler available; disabling C++ specific optional code"
    cxx=
fi

if !(GIT="$git" "$source_path/scripts/git-submodule.sh" "$git_submodules_action" "$git_submodules"); then
    exit 1
fi

config_host_mak="config-host.mak"

echo "# Automatically generated by configure - do not modify" > $config_host_mak
echo >> $config_host_mak

echo all: >> $config_host_mak
echo "GIT=$git" >> $config_host_mak
echo "GIT_SUBMODULES=$git_submodules" >> $config_host_mak
echo "GIT_SUBMODULES_ACTION=$git_submodules_action" >> $config_host_mak

if test "$debug_tcg" = "yes" ; then
  echo "CONFIG_DEBUG_TCG=y" >> $config_host_mak
fi
if test "$strip_opt" = "yes" ; then
  echo "STRIP=${strip}" >> $config_host_mak
fi
if test "$mingw32" = "yes" ; then
  echo "CONFIG_WIN32=y" >> $config_host_mak
  if test "$guest_agent_with_vss" = "yes" ; then
    echo "CONFIG_QGA_VSS=y" >> $config_host_mak
    echo "QGA_VSS_PROVIDER=$qga_vss_provider" >> $config_host_mak
    echo "WIN_SDK=\"$win_sdk\"" >> $config_host_mak
  fi
  if test "$guest_agent_ntddscsi" = "yes" ; then
    echo "CONFIG_QGA_NTDDSCSI=y" >> $config_host_mak
  fi
  echo "QEMU_GA_MSI_MINGW_DLL_PATH=${QEMU_GA_MSI_MINGW_DLL_PATH}" >> $config_host_mak
  echo "QEMU_GA_MANUFACTURER=${QEMU_GA_MANUFACTURER}" >> $config_host_mak
  echo "QEMU_GA_DISTRO=${QEMU_GA_DISTRO}" >> $config_host_mak
  echo "QEMU_GA_VERSION=${QEMU_GA_VERSION}" >> $config_host_mak
else
  echo "CONFIG_POSIX=y" >> $config_host_mak
fi

if test "$linux" = "yes" ; then
  echo "CONFIG_LINUX=y" >> $config_host_mak
fi

if test "$darwin" = "yes" ; then
  echo "CONFIG_DARWIN=y" >> $config_host_mak
fi

if test "$solaris" = "yes" ; then
  echo "CONFIG_SOLARIS=y" >> $config_host_mak
fi
if test "$static" = "yes" ; then
  echo "CONFIG_STATIC=y" >> $config_host_mak
fi
if test "$profiler" = "yes" ; then
  echo "CONFIG_PROFILER=y" >> $config_host_mak
fi
if test "$want_tools" = "yes" ; then
  echo "CONFIG_TOOLS=y" >> $config_host_mak
fi
if test "$guest_agent" = "yes" ; then
  echo "CONFIG_GUEST_AGENT=y" >> $config_host_mak
fi
if test "$slirp_smbd" = "yes" ; then
  echo "CONFIG_SLIRP_SMBD=y" >> $config_host_mak
  echo "CONFIG_SMBD_COMMAND=\"$smbd\"" >> $config_host_mak
fi
if test "$gprof" = "yes" ; then
  echo "CONFIG_GPROF=y" >> $config_host_mak
fi
echo "CONFIG_BDRV_RW_WHITELIST=$block_drv_rw_whitelist" >> $config_host_mak
echo "CONFIG_BDRV_RO_WHITELIST=$block_drv_ro_whitelist" >> $config_host_mak
if test "$block_drv_whitelist_tools" = "yes" ; then
  echo "CONFIG_BDRV_WHITELIST_TOOLS=y" >> $config_host_mak
fi
if test "$xfs" = "yes" ; then
  echo "CONFIG_XFS=y" >> $config_host_mak
fi
qemu_version=$(head $source_path/VERSION)
echo "PKGVERSION=$pkgversion" >>$config_host_mak
echo "SRC_PATH=$source_path" >> $config_host_mak
echo "TARGET_DIRS=$target_list" >> $config_host_mak
if test "$modules" = "yes"; then
  # $shacmd can generate a hash started with digit, which the compiler doesn't
  # like as an symbol. So prefix it with an underscore
  echo "CONFIG_STAMP=_$( (echo $qemu_version; echo $pkgversion; cat $0) | $shacmd - | cut -f1 -d\ )" >> $config_host_mak
  echo "CONFIG_MODULES=y" >> $config_host_mak
fi
if test "$module_upgrades" = "yes"; then
  echo "CONFIG_MODULE_UPGRADES=y" >> $config_host_mak
fi
if test "$have_usbfs" = "yes" ; then
  echo "CONFIG_USBFS=y" >> $config_host_mak
fi
if test "$gio" = "yes" ; then
    echo "CONFIG_GIO=y" >> $config_host_mak
    echo "GIO_CFLAGS=$gio_cflags" >> $config_host_mak
    echo "GIO_LIBS=$gio_libs" >> $config_host_mak
fi
if test "$gdbus_codegen" != "" ; then
    echo "GDBUS_CODEGEN=$gdbus_codegen" >> $config_host_mak
fi
echo "CONFIG_TLS_PRIORITY=\"$tls_priority\"" >> $config_host_mak

if test "$xen" = "enabled" ; then
  echo "CONFIG_XEN_BACKEND=y" >> $config_host_mak
  echo "CONFIG_XEN_CTRL_INTERFACE_VERSION=$xen_ctrl_version" >> $config_host_mak
  echo "XEN_CFLAGS=$xen_cflags" >> $config_host_mak
  echo "XEN_LIBS=$xen_libs" >> $config_host_mak
fi
if test "$vhost_scsi" = "yes" ; then
  echo "CONFIG_VHOST_SCSI=y" >> $config_host_mak
fi
if test "$vhost_net" = "yes" ; then
  echo "CONFIG_VHOST_NET=y" >> $config_host_mak
fi
if test "$vhost_net_user" = "yes" ; then
  echo "CONFIG_VHOST_NET_USER=y" >> $config_host_mak
fi
if test "$vhost_net_vdpa" = "yes" ; then
  echo "CONFIG_VHOST_NET_VDPA=y" >> $config_host_mak
fi
if test "$vhost_crypto" = "yes" ; then
  echo "CONFIG_VHOST_CRYPTO=y" >> $config_host_mak
fi
if test "$vhost_vsock" = "yes" ; then
  echo "CONFIG_VHOST_VSOCK=y" >> $config_host_mak
  if test "$vhost_user" = "yes" ; then
    echo "CONFIG_VHOST_USER_VSOCK=y" >> $config_host_mak
  fi
fi
if test "$vhost_kernel" = "yes" ; then
  echo "CONFIG_VHOST_KERNEL=y" >> $config_host_mak
fi
if test "$vhost_user" = "yes" ; then
  echo "CONFIG_VHOST_USER=y" >> $config_host_mak
fi
if test "$vhost_vdpa" = "yes" ; then
  echo "CONFIG_VHOST_VDPA=y" >> $config_host_mak
fi
if test "$vhost_user_fs" = "yes" ; then
  echo "CONFIG_VHOST_USER_FS=y" >> $config_host_mak
fi
if test "$membarrier" = "yes" ; then
  echo "CONFIG_MEMBARRIER=y" >> $config_host_mak
fi
if test "$tcg" = "enabled" -a "$tcg_interpreter" = "true" ; then
  echo "CONFIG_TCG_INTERPRETER=y" >> $config_host_mak
fi

if test "$opengl" = "yes" ; then
  echo "CONFIG_OPENGL=y" >> $config_host_mak
  echo "OPENGL_CFLAGS=$opengl_cflags" >> $config_host_mak
  echo "OPENGL_LIBS=$opengl_libs" >> $config_host_mak
fi

if test "$avx2_opt" = "yes" ; then
  echo "CONFIG_AVX2_OPT=y" >> $config_host_mak
fi

if test "$avx512f_opt" = "yes" ; then
  echo "CONFIG_AVX512F_OPT=y" >> $config_host_mak
fi

# XXX: suppress that
if [ "$bsd" = "yes" ] ; then
  echo "CONFIG_BSD=y" >> $config_host_mak
fi

if test "$qom_cast_debug" = "yes" ; then
  echo "CONFIG_QOM_CAST_DEBUG=y" >> $config_host_mak
fi

echo "CONFIG_COROUTINE_BACKEND=$coroutine" >> $config_host_mak
if test "$coroutine_pool" = "yes" ; then
  echo "CONFIG_COROUTINE_POOL=1" >> $config_host_mak
else
  echo "CONFIG_COROUTINE_POOL=0" >> $config_host_mak
fi

if test "$debug_stack_usage" = "yes" ; then
  echo "CONFIG_DEBUG_STACK_USAGE=y" >> $config_host_mak
fi

if test "$crypto_afalg" = "yes" ; then
  echo "CONFIG_AF_ALG=y" >> $config_host_mak
fi

if test "$have_asan_iface_fiber" = "yes" ; then
    echo "CONFIG_ASAN_IFACE_FIBER=y" >> $config_host_mak
fi

if test "$have_tsan" = "yes" && test "$have_tsan_iface_fiber" = "yes" ; then
    echo "CONFIG_TSAN=y" >> $config_host_mak
fi

if test "$cpuid_h" = "yes" ; then
  echo "CONFIG_CPUID_H=y" >> $config_host_mak
fi

if test "$int128" = "yes" ; then
  echo "CONFIG_INT128=y" >> $config_host_mak
fi

if test "$atomic128" = "yes" ; then
  echo "CONFIG_ATOMIC128=y" >> $config_host_mak
fi

if test "$cmpxchg128" = "yes" ; then
  echo "CONFIG_CMPXCHG128=y" >> $config_host_mak
fi

if test "$live_block_migration" = "yes" ; then
  echo "CONFIG_LIVE_BLOCK_MIGRATION=y" >> $config_host_mak
fi

if test "$tpm" = "yes"; then
  echo 'CONFIG_TPM=y' >> $config_host_mak
fi

if test "$rdma" = "yes" ; then
  echo "CONFIG_RDMA=y" >> $config_host_mak
  echo "RDMA_LIBS=$rdma_libs" >> $config_host_mak
fi

if test "$pvrdma" = "yes" ; then
  echo "CONFIG_PVRDMA=y" >> $config_host_mak
fi

if test "$replication" = "yes" ; then
  echo "CONFIG_REPLICATION=y" >> $config_host_mak
fi

if test "$debug_mutex" = "yes" ; then
  echo "CONFIG_DEBUG_MUTEX=y" >> $config_host_mak
fi

if test "$bochs" = "yes" ; then
  echo "CONFIG_BOCHS=y" >> $config_host_mak
fi
if test "$cloop" = "yes" ; then
  echo "CONFIG_CLOOP=y" >> $config_host_mak
fi
if test "$dmg" = "yes" ; then
  echo "CONFIG_DMG=y" >> $config_host_mak
fi
if test "$qcow1" = "yes" ; then
  echo "CONFIG_QCOW1=y" >> $config_host_mak
fi
if test "$vdi" = "yes" ; then
  echo "CONFIG_VDI=y" >> $config_host_mak
fi
if test "$vvfat" = "yes" ; then
  echo "CONFIG_VVFAT=y" >> $config_host_mak
fi
if test "$qed" = "yes" ; then
  echo "CONFIG_QED=y" >> $config_host_mak
fi
if test "$parallels" = "yes" ; then
  echo "CONFIG_PARALLELS=y" >> $config_host_mak
fi

if test "$plugins" = "yes" ; then
    echo "CONFIG_PLUGIN=y" >> $config_host_mak
    # Copy the export object list to the build dir
    if test "$ld_dynamic_list" = "yes" ; then
	echo "CONFIG_HAS_LD_DYNAMIC_LIST=yes" >> $config_host_mak
	ld_symbols=qemu-plugins-ld.symbols
	cp "$source_path/plugins/qemu-plugins.symbols" $ld_symbols
    elif test "$ld_exported_symbols_list" = "yes" ; then
	echo "CONFIG_HAS_LD_EXPORTED_SYMBOLS_LIST=yes" >> $config_host_mak
	ld64_symbols=qemu-plugins-ld64.symbols
	echo "# Automatically generated by configure - do not modify" > $ld64_symbols
	grep 'qemu_' "$source_path/plugins/qemu-plugins.symbols" | sed 's/;//g' | \
	    sed -E 's/^[[:space:]]*(.*)/_\1/' >> $ld64_symbols
    else
	error_exit \
	    "If \$plugins=yes, either \$ld_dynamic_list or " \
	    "\$ld_exported_symbols_list should have been set to 'yes'."
    fi
fi

if test -n "$gdb_bin"; then
    gdb_version=$($gdb_bin --version | head -n 1)
    if version_ge ${gdb_version##* } 9.1; then
        echo "HAVE_GDB_BIN=$gdb_bin" >> $config_host_mak
    fi
fi

if test "$secret_keyring" = "yes" ; then
  echo "CONFIG_SECRET_KEYRING=y" >> $config_host_mak
fi

echo "ROMS=$roms" >> $config_host_mak
echo "MAKE=$make" >> $config_host_mak
echo "PYTHON=$python" >> $config_host_mak
echo "GENISOIMAGE=$genisoimage" >> $config_host_mak
echo "MESON=$meson" >> $config_host_mak
echo "NINJA=$ninja" >> $config_host_mak
echo "CC=$cc" >> $config_host_mak
echo "HOST_CC=$host_cc" >> $config_host_mak
if $iasl -h > /dev/null 2>&1; then
  echo "CONFIG_IASL=$iasl" >> $config_host_mak
fi
echo "AR=$ar" >> $config_host_mak
echo "AS=$as" >> $config_host_mak
echo "CCAS=$ccas" >> $config_host_mak
echo "CPP=$cpp" >> $config_host_mak
echo "OBJCOPY=$objcopy" >> $config_host_mak
echo "LD=$ld" >> $config_host_mak
echo "CFLAGS_NOPIE=$CFLAGS_NOPIE" >> $config_host_mak
echo "QEMU_CFLAGS=$QEMU_CFLAGS" >> $config_host_mak
echo "QEMU_CXXFLAGS=$QEMU_CXXFLAGS" >> $config_host_mak
echo "GLIB_CFLAGS=$glib_cflags" >> $config_host_mak
echo "GLIB_LIBS=$glib_libs" >> $config_host_mak
echo "GLIB_VERSION=$(pkg-config --modversion glib-2.0)" >> $config_host_mak
echo "QEMU_LDFLAGS=$QEMU_LDFLAGS" >> $config_host_mak
echo "LD_I386_EMULATION=$ld_i386_emulation" >> $config_host_mak
echo "EXESUF=$EXESUF" >> $config_host_mak
echo "LIBS_QGA=$libs_qga" >> $config_host_mak

if test "$rng_none" = "yes"; then
  echo "CONFIG_RNG_NONE=y" >> $config_host_mak
fi

# use included Linux headers
if test "$linux" = "yes" ; then
  mkdir -p linux-headers
  case "$cpu" in
  i386|x86_64)
    linux_arch=x86
    ;;
  ppc|ppc64)
    linux_arch=powerpc
    ;;
  s390x)
    linux_arch=s390
    ;;
  aarch64)
    linux_arch=arm64
    ;;
  loongarch*)
    linux_arch=loongarch
    ;;
  mips64)
    linux_arch=mips
    ;;
  *)
    # For most CPUs the kernel architecture name and QEMU CPU name match.
    linux_arch="$cpu"
    ;;
  esac
    # For non-KVM architectures we will not have asm headers
    if [ -e "$source_path/linux-headers/asm-$linux_arch" ]; then
      symlink "$source_path/linux-headers/asm-$linux_arch" linux-headers/asm
    fi
fi

for target in $target_list; do
    target_dir="$target"
    target_name=$(echo $target | cut -d '-' -f 1)$EXESUF
    mkdir -p $target_dir
    case $target in
        *-user) symlink "../qemu-$target_name" "$target_dir/qemu-$target_name" ;;
        *) symlink "../qemu-system-$target_name" "$target_dir/qemu-system-$target_name" ;;
    esac
done

echo "CONFIG_QEMU_INTERP_PREFIX=$interp_prefix" | sed 's/%M/@0@/' >> $config_host_mak
if test "$default_targets" = "yes"; then
  echo "CONFIG_DEFAULT_TARGETS=y" >> $config_host_mak
fi

if test "$numa" = "yes"; then
  echo "CONFIG_NUMA=y" >> $config_host_mak
  echo "NUMA_LIBS=$numa_libs" >> $config_host_mak
fi

if test "$ccache_cpp2" = "yes"; then
  echo "export CCACHE_CPP2=y" >> $config_host_mak
fi

if test "$safe_stack" = "yes"; then
  echo "CONFIG_SAFESTACK=y" >> $config_host_mak
fi

# If we're using a separate build tree, set it up now.
# LINKS are things to symlink back into the source tree
# (these can be both files and directories).
# Caution: do not add files or directories here using wildcards. This
# will result in problems later if a new file matching the wildcard is
# added to the source tree -- nothing will cause configure to be rerun
# so the build tree will be missing the link back to the new file, and
# tests might fail. Prefer to keep the relevant files in their own
# directory and symlink the directory instead.
# UNLINK is used to remove symlinks from older development versions
# that might get into the way when doing "git update" without doing
# a "make distclean" in between.
LINKS="Makefile"
LINKS="$LINKS tests/tcg/Makefile.target"
LINKS="$LINKS pc-bios/optionrom/Makefile"
LINKS="$LINKS pc-bios/s390-ccw/Makefile"
LINKS="$LINKS roms/seabios/Makefile"
LINKS="$LINKS pc-bios/qemu-icon.bmp"
LINKS="$LINKS .gdbinit scripts" # scripts needed by relative path in .gdbinit
LINKS="$LINKS tests/avocado tests/data"
LINKS="$LINKS tests/qemu-iotests/check"
LINKS="$LINKS python"
LINKS="$LINKS contrib/plugins/Makefile "
UNLINK="pc-bios/keymaps"
for bios_file in \
    $source_path/pc-bios/*.bin \
    $source_path/pc-bios/*.elf \
    $source_path/pc-bios/*.lid \
    $source_path/pc-bios/*.rom \
    $source_path/pc-bios/*.dtb \
    $source_path/pc-bios/*.img \
    $source_path/pc-bios/openbios-* \
    $source_path/pc-bios/u-boot.* \
    $source_path/pc-bios/palcode-* \
    $source_path/pc-bios/qemu_vga.ndrv

do
    LINKS="$LINKS pc-bios/$(basename $bios_file)"
done
for f in $LINKS ; do
    if [ -e "$source_path/$f" ]; then
        mkdir -p `dirname ./$f`
        symlink "$source_path/$f" "$f"
    fi
done
for f in $UNLINK ; do
    if [ -L "$f" ]; then
        rm -f "$f"
    fi
done

(for i in $cross_cc_vars; do
  export $i
done
export target_list source_path use_containers cpu
$source_path/tests/tcg/configure.sh)

# temporary config to build submodules
for rom in seabios; do
    config_mak=roms/$rom/config.mak
    echo "# Automatically generated by configure - do not modify" > $config_mak
    echo "SRC_PATH=$source_path/roms/$rom" >> $config_mak
    echo "AS=$as" >> $config_mak
    echo "CCAS=$ccas" >> $config_mak
    echo "CC=$cc" >> $config_mak
    echo "BCC=bcc" >> $config_mak
    echo "CPP=$cpp" >> $config_mak
    echo "OBJCOPY=objcopy" >> $config_mak
    echo "IASL=$iasl" >> $config_mak
    echo "LD=$ld" >> $config_mak
    echo "RANLIB=$ranlib" >> $config_mak
done

config_mak=pc-bios/optionrom/config.mak
echo "# Automatically generated by configure - do not modify" > $config_mak
echo "TOPSRC_DIR=$source_path" >> $config_mak

if test "$skip_meson" = no; then
  cross="config-meson.cross.new"
  meson_quote() {
    test $# = 0 && return
    echo "'$(echo $* | sed "s/ /','/g")'"
  }

  echo "# Automatically generated by configure - do not modify" > $cross
  echo "[properties]" >> $cross

  # unroll any custom device configs
  for a in $device_archs; do
      eval "c=\$devices_${a}"
      echo "${a}-softmmu = '$c'" >> $cross
  done

  test -z "$cxx" && echo "link_language = 'c'" >> $cross
  echo "[built-in options]" >> $cross
  echo "c_args = [$(meson_quote $CFLAGS $EXTRA_CFLAGS)]" >> $cross
  echo "cpp_args = [$(meson_quote $CXXFLAGS $EXTRA_CXXFLAGS)]" >> $cross
  echo "c_link_args = [$(meson_quote $CFLAGS $LDFLAGS $EXTRA_CFLAGS $EXTRA_LDFLAGS)]" >> $cross
  echo "cpp_link_args = [$(meson_quote $CXXFLAGS $LDFLAGS $EXTRA_CXXFLAGS $EXTRA_LDFLAGS)]" >> $cross
  echo "[binaries]" >> $cross
  echo "c = [$(meson_quote $cc $CPU_CFLAGS)]" >> $cross
  test -n "$cxx" && echo "cpp = [$(meson_quote $cxx $CPU_CFLAGS)]" >> $cross
  test -n "$objcc" && echo "objc = [$(meson_quote $objcc $CPU_CFLAGS)]" >> $cross
  echo "ar = [$(meson_quote $ar)]" >> $cross
  echo "nm = [$(meson_quote $nm)]" >> $cross
  echo "pkgconfig = [$(meson_quote $pkg_config_exe)]" >> $cross
  echo "ranlib = [$(meson_quote $ranlib)]" >> $cross
  if has $sdl2_config; then
    echo "sdl2-config = [$(meson_quote $sdl2_config)]" >> $cross
  fi
  echo "strip = [$(meson_quote $strip)]" >> $cross
  echo "windres = [$(meson_quote $windres)]" >> $cross
  if test "$cross_compile" = "yes"; then
    cross_arg="--cross-file config-meson.cross"
    echo "[host_machine]" >> $cross
    echo "system = '$targetos'" >> $cross
    case "$cpu" in
        i386)
            echo "cpu_family = 'x86'" >> $cross
            ;;
        *)
            echo "cpu_family = '$cpu'" >> $cross
            ;;
    esac
    echo "cpu = '$cpu'" >> $cross
    if test "$bigendian" = "yes" ; then
        echo "endian = 'big'" >> $cross
    else
        echo "endian = 'little'" >> $cross
    fi
  else
    cross_arg="--native-file config-meson.cross"
  fi
  mv $cross config-meson.cross

  rm -rf meson-private meson-info meson-logs
  run_meson() {
    NINJA=$ninja $meson setup \
        --prefix "$prefix" \
        --libdir "$libdir" \
        --libexecdir "$libexecdir" \
        --bindir "$bindir" \
        --includedir "$includedir" \
        --datadir "$datadir" \
        --mandir "$mandir" \
        --sysconfdir "$sysconfdir" \
        --localedir "$localedir" \
        --localstatedir "$local_statedir" \
        -Daudio_drv_list=$audio_drv_list \
        -Ddefault_devices=$default_devices \
        -Ddocdir="$docdir" \
        -Dqemu_firmwarepath="$firmwarepath" \
        -Dqemu_suffix="$qemu_suffix" \
        -Dsphinx_build="$sphinx_build" \
        -Dtrace_file="$trace_file" \
        -Doptimization=$(if test "$debug" = yes; then echo 0; else echo 2; fi) \
        -Ddebug=$(if test "$debug_info" = yes; then echo true; else echo false; fi) \
        -Dwerror=$(if test "$werror" = yes; then echo true; else echo false; fi) \
        -Dstrip=$(if test "$strip_opt" = yes; then echo true; else echo false; fi) \
        -Db_pie=$(if test "$pie" = yes; then echo true; else echo false; fi) \
        -Db_coverage=$(if test "$gcov" = yes; then echo true; else echo false; fi) \
        -Db_lto=$lto -Dcfi=$cfi -Dtcg=$tcg -Dxen=$xen \
        -Dcapstone=$capstone -Dfdt=$fdt -Dslirp=$slirp \
        $(test -n "${LIB_FUZZING_ENGINE+xxx}" && echo "-Dfuzzing_engine=$LIB_FUZZING_ENGINE") \
        $(if test "$default_feature" = no; then echo "-Dauto_features=disabled"; fi) \
        "$@" $cross_arg "$PWD" "$source_path"
  }
  eval run_meson $meson_options
  if test "$?" -ne 0 ; then
      error_exit "meson setup failed"
  fi
else
  if test -f meson-private/cmd_line.txt; then
    # Adjust old command line options whose type was changed
    # Avoids having to use "setup --wipe" when Meson is upgraded
    perl -i -ne '
      s/^gettext = true$/gettext = auto/;
      s/^gettext = false$/gettext = disabled/;
      /^b_staticpic/ && next;
      print;' meson-private/cmd_line.txt
  fi
fi

if test -n "${deprecated_features}"; then
    echo "Warning, deprecated features enabled."
    echo "Please see docs/about/deprecated.rst"
    echo "  features: ${deprecated_features}"
fi

# Create list of config switches that should be poisoned in common code...
# but filter out CONFIG_TCG and CONFIG_USER_ONLY which are special.
target_configs_h=$(ls *-config-devices.h *-config-target.h 2>/dev/null)
if test -n "$target_configs_h" ; then
    sed -n -e '/CONFIG_TCG/d' -e '/CONFIG_USER_ONLY/d' \
        -e '/^#define / { s///; s/ .*//; s/^/#pragma GCC poison /p; }' \
        $target_configs_h | sort -u > config-poison.h
else
    :> config-poison.h
fi

# Save the configure command line for later reuse.
cat <<EOD >config.status
#!/bin/sh
# Generated by configure.
# Run this file to recreate the current configuration.
# Compiler output produced by configure, useful for debugging
# configure, is in config.log if it exists.
EOD

preserve_env() {
    envname=$1

    eval envval=\$$envname

    if test -n "$envval"
    then
	echo "$envname='$envval'" >> config.status
	echo "export $envname" >> config.status
    else
	echo "unset $envname" >> config.status
    fi
}

# Preserve various env variables that influence what
# features/build target configure will detect
preserve_env AR
preserve_env AS
preserve_env CC
preserve_env CPP
preserve_env CFLAGS
preserve_env CXX
preserve_env CXXFLAGS
preserve_env INSTALL
preserve_env LD
preserve_env LDFLAGS
preserve_env LD_LIBRARY_PATH
preserve_env LIBTOOL
preserve_env MAKE
preserve_env NM
preserve_env OBJCOPY
preserve_env PATH
preserve_env PKG_CONFIG
preserve_env PKG_CONFIG_LIBDIR
preserve_env PKG_CONFIG_PATH
preserve_env PYTHON
preserve_env SDL2_CONFIG
preserve_env SMBD
preserve_env STRIP
preserve_env WINDRES

printf "exec" >>config.status
for i in "$0" "$@"; do
  test "$i" = --skip-meson || printf " %s" "$(quote_sh "$i")" >>config.status
done
echo ' "$@"' >>config.status
chmod +x config.status

rm -r "$TMPDIR1"
