#!/bin/sh
#
# qemu configure script (c) 2003 Fabrice Bellard
#
# set temporary file name
if test ! -z "$TMPDIR" ; then
    TMPDIR1="${TMPDIR}"
elif test ! -z "$TEMPDIR" ; then
    TMPDIR1="${TEMPDIR}"
else
    TMPDIR1="/tmp"
fi

TMPC="${TMPDIR1}/qemu-conf-${RANDOM}-$$-${RANDOM}.c"
TMPO="${TMPDIR1}/qemu-conf-${RANDOM}-$$-${RANDOM}.o"
TMPE="${TMPDIR1}/qemu-conf-${RANDOM}-$$-${RANDOM}.exe"

# NB: do not call "exit" in the trap handler; this is buggy with some shells;
# see <1285349658-3122-1-git-send-email-loic.minier@linaro.org>
trap "rm -f $TMPC $TMPO $TMPE" EXIT INT QUIT TERM
rm -f config.log

compile_object() {
  echo $cc $QEMU_CFLAGS -c -o $TMPO $TMPC >> config.log
  $cc $QEMU_CFLAGS -c -o $TMPO $TMPC >> config.log 2>&1
}

compile_prog() {
  local_cflags="$1"
  local_ldflags="$2"
  echo $cc $QEMU_CFLAGS $local_cflags -o $TMPE $TMPC $LDFLAGS $local_ldflags >> config.log
  $cc $QEMU_CFLAGS $local_cflags -o $TMPE $TMPC $LDFLAGS $local_ldflags >> config.log 2>&1
}

# symbolically link $1 to $2.  Portable version of "ln -sf".
symlink() {
  rm -f $2
  ln -s $1 $2
}

# check whether a command is available to this shell (may be either an
# executable or a builtin)
has() {
    type "$1" >/dev/null 2>&1
}

# search for an executable in PATH
path_of() {
    local_command="$1"
    local_ifs="$IFS"
    local_dir=""

    # pathname has a dir component?
    if [ "${local_command#*/}" != "$local_command" ]; then
        if [ -x "$local_command" ] && [ ! -d "$local_command" ]; then
            echo "$local_command"
            return 0
        fi
    fi
    if [ -z "$local_command" ]; then
        return 1
    fi

    IFS=:
    for local_dir in $PATH; do
        if [ -x "$local_dir/$local_command" ] && [ ! -d "$local_dir/$local_command" ]; then
            echo "$local_dir/$local_command"
            IFS="${local_ifs:-$(printf ' \t\n')}"
            return 0
        fi
    done
    # not found
    IFS="${local_ifs:-$(printf ' \t\n')}"
    return 1
}

# default parameters
source_path=`dirname "$0"`
cpu=""
interp_prefix="/usr/gnemul/qemu-%M"
static="no"
sparc_cpu=""
cross_prefix=""
audio_drv_list=""
audio_card_list="ac97 es1370 sb16 hda"
audio_possible_cards="ac97 es1370 sb16 cs4231a adlib gus hda"
block_drv_whitelist=""
host_cc="gcc"
helper_cflags=""
libs_softmmu=""
libs_tools=""
audio_pt_int=""
audio_win_int=""
cc_i386=i386-pc-linux-gnu-gcc

target_list=""

# Default value for a variable defining feature "foo".
#  * foo="no"  feature will only be used if --enable-foo arg is given
#  * foo=""    feature will be searched for, and if found, will be used
#              unless --disable-foo is given
#  * foo="yes" this value will only be set by --enable-foo flag.
#              feature will searched for,
#              if not found, configure exits with error
#
# Always add --enable-foo and --disable-foo command line args.
# Distributions want to ensure that several features are compiled in, and it
# is impossible without a --enable-foo that exits if a feature is not found.

bluez=""
brlapi=""
curl=""
curses=""
docs=""
fdt=""
kvm=""
kvm_para=""
nptl=""
sdl=""
vnc="yes"
sparse="no"
uuid=""
vde=""
vnc_tls=""
vnc_sasl=""
vnc_jpeg=""
vnc_png=""
vnc_thread="no"
xen=""
xen_ctrl_version=""
linux_aio=""
attr=""
vhost_net=""
xfs=""

gprof="no"
debug_tcg="no"
debug_mon="no"
debug="no"
strip_opt="yes"
bigendian="no"
mingw32="no"
EXESUF=""
prefix="/usr/local"
mandir="\${prefix}/share/man"
datadir="\${prefix}/share/qemu"
docdir="\${prefix}/share/doc/qemu"
bindir="\${prefix}/bin"
sysconfdir="\${prefix}/etc"
confsuffix="/qemu"
slirp="yes"
fmod_lib=""
fmod_inc=""
oss_lib=""
bsd="no"
linux="no"
solaris="no"
profiler="no"
cocoa="no"
softmmu="yes"
linux_user="no"
darwin_user="no"
bsd_user="no"
guest_base=""
uname_release=""
io_thread="no"
mixemu="no"
kerneldir=""
aix="no"
blobs="yes"
pkgversion=""
check_utests="no"
user_pie="no"
zero_malloc=""
trace_backend="nop"
trace_file="trace"
spice=""
rbd=""
smartcard=""
smartcard_nss=""
opengl=""

# parse CC options first
for opt do
  optarg=`expr "x$opt" : 'x[^=]*=\(.*\)'`
  case "$opt" in
  --cross-prefix=*) cross_prefix="$optarg"
  ;;
  --cc=*) CC="$optarg"
  ;;
  --source-path=*) source_path="$optarg"
  ;;
  --cpu=*) cpu="$optarg"
  ;;
  --extra-cflags=*) QEMU_CFLAGS="$optarg $QEMU_CFLAGS"
  ;;
  --extra-ldflags=*) LDFLAGS="$optarg $LDFLAGS"
  ;;
  --sparc_cpu=*)
    sparc_cpu="$optarg"
    case $sparc_cpu in
    v7|v8|v8plus|v8plusa)
      cpu="sparc"
    ;;
    v9)
      cpu="sparc64"
    ;;
    *)
      echo "undefined SPARC architecture. Exiting";
      exit 1
    ;;
    esac
  ;;
  esac
done
# OS specific
# Using uname is really, really broken.  Once we have the right set of checks
# we can eliminate it's usage altogether

cc="${cross_prefix}${CC-gcc}"
ar="${cross_prefix}${AR-ar}"
objcopy="${cross_prefix}${OBJCOPY-objcopy}"
ld="${cross_prefix}${LD-ld}"
strip="${cross_prefix}${STRIP-strip}"
windres="${cross_prefix}${WINDRES-windres}"
pkg_config="${cross_prefix}${PKG_CONFIG-pkg-config}"
sdl_config="${cross_prefix}${SDL_CONFIG-sdl-config}"

# default flags for all hosts
QEMU_CFLAGS="-fno-strict-aliasing $QEMU_CFLAGS"
CFLAGS="-g $CFLAGS"
QEMU_CFLAGS="-Wall -Wundef -Wendif-labels -Wwrite-strings -Wmissing-prototypes $QEMU_CFLAGS"
QEMU_CFLAGS="-Wstrict-prototypes -Wredundant-decls $QEMU_CFLAGS"
QEMU_CFLAGS="-D_GNU_SOURCE -D_FILE_OFFSET_BITS=64 -D_LARGEFILE_SOURCE $QEMU_CFLAGS"
QEMU_CFLAGS="-D_FORTIFY_SOURCE=2 $QEMU_CFLAGS"
QEMU_INCLUDES="-I. -I\$(SRC_PATH)"
LDFLAGS="-g $LDFLAGS"

# make source path absolute
source_path=`cd "$source_path"; pwd`

check_define() {
cat > $TMPC <<EOF
#if !defined($1)
#error Not defined
#endif
int main(void) { return 0; }
EOF
  compile_object
}

if test ! -z "$cpu" ; then
  # command line argument
  :
elif check_define __i386__ ; then
  cpu="i386"
elif check_define __x86_64__ ; then
  cpu="x86_64"
elif check_define __sparc__ ; then
  # We can't check for 64 bit (when gcc is biarch) or V8PLUSA
  # They must be specified using --sparc_cpu
  if check_define __arch64__ ; then
    cpu="sparc64"
  else
    cpu="sparc"
  fi
elif check_define _ARCH_PPC ; then
  if check_define _ARCH_PPC64 ; then
    cpu="ppc64"
  else
    cpu="ppc"
  fi
elif check_define __mips__ ; then
  cpu="mips"
elif check_define __ia64__ ; then
  cpu="ia64"
elif check_define __s390__ ; then
  if check_define __s390x__ ; then
    cpu="s390x"
  else
    cpu="s390"
  fi
else
  cpu=`uname -m`
fi

case "$cpu" in
  alpha|cris|ia64|lm32|m68k|microblaze|ppc|ppc64|sparc64|unicore32)
    cpu="$cpu"
  ;;
  i386|i486|i586|i686|i86pc|BePC)
    cpu="i386"
  ;;
  x86_64|amd64)
    cpu="x86_64"
  ;;
  armv*b)
    cpu="armv4b"
  ;;
  armv*l)
    cpu="armv4l"
  ;;
  parisc|parisc64)
    cpu="hppa"
  ;;
  mips*)
    cpu="mips"
  ;;
  s390)
    cpu="s390"
  ;;
  s390x)
    cpu="s390x"
  ;;
  sparc|sun4[cdmuv])
    cpu="sparc"
  ;;
  *)
    echo "Unsupported CPU = $cpu"
    exit 1
  ;;
esac

# OS specific
if check_define __linux__ ; then
  targetos="Linux"
elif check_define _WIN32 ; then
  targetos='MINGW32'
elif check_define __OpenBSD__ ; then
  targetos='OpenBSD'
elif check_define __sun__ ; then
  targetos='SunOS'
elif check_define __HAIKU__ ; then
  targetos='Haiku'
else
  targetos=`uname -s`
fi

case $targetos in
CYGWIN*)
  mingw32="yes"
  QEMU_CFLAGS="-mno-cygwin $QEMU_CFLAGS"
  audio_possible_drivers="winwave sdl"
  audio_drv_list="winwave"
;;
MINGW32*)
  mingw32="yes"
  audio_possible_drivers="winwave dsound sdl fmod"
  audio_drv_list="winwave"
;;
GNU/kFreeBSD)
  bsd="yes"
  audio_drv_list="oss"
  audio_possible_drivers="oss sdl esd pa"
;;
FreeBSD)
  bsd="yes"
  make="${MAKE-gmake}"
  audio_drv_list="oss"
  audio_possible_drivers="oss sdl esd pa"
  # needed for kinfo_getvmmap(3) in libutil.h
  LIBS="-lutil $LIBS"
;;
DragonFly)
  bsd="yes"
  make="${MAKE-gmake}"
  audio_drv_list="oss"
  audio_possible_drivers="oss sdl esd pa"
;;
NetBSD)
  bsd="yes"
  make="${MAKE-gmake}"
  audio_drv_list="oss"
  audio_possible_drivers="oss sdl esd"
  oss_lib="-lossaudio"
;;
OpenBSD)
  bsd="yes"
  make="${MAKE-gmake}"
  audio_drv_list="oss"
  audio_possible_drivers="oss sdl esd"
  oss_lib="-lossaudio"
;;
Darwin)
  bsd="yes"
  darwin="yes"
  # on Leopard most of the system is 32-bit, so we have to ask the kernel it if we can
  # run 64-bit userspace code
  if [ "$cpu" = "i386" ] ; then
    is_x86_64=`sysctl -n hw.optional.x86_64`
    [ "$is_x86_64" = "1" ] && cpu=x86_64
  fi
  if [ "$cpu" = "x86_64" ] ; then
    QEMU_CFLAGS="-arch x86_64 $QEMU_CFLAGS"
    LDFLAGS="-arch x86_64 $LDFLAGS"
  else
    QEMU_CFLAGS="-mdynamic-no-pic $QEMU_CFLAGS"
  fi
  darwin_user="yes"
  cocoa="yes"
  audio_drv_list="coreaudio"
  audio_possible_drivers="coreaudio sdl fmod"
  LDFLAGS="-framework CoreFoundation -framework IOKit $LDFLAGS"
  libs_softmmu="-F/System/Library/Frameworks -framework Cocoa -framework IOKit $libs_softmmu"
;;
SunOS)
  solaris="yes"
  make="${MAKE-gmake}"
  install="${INSTALL-ginstall}"
  ld="gld"
  needs_libsunmath="no"
  solarisrev=`uname -r | cut -f2 -d.`
  # have to select again, because `uname -m` returns i86pc
  # even on an x86_64 box.
  solariscpu=`isainfo -k`
  if test "${solariscpu}" = "amd64" ; then
    cpu="x86_64"
  fi
  if [ "$cpu" = "i386" -o "$cpu" = "x86_64" ] ; then
    if test "$solarisrev" -le 9 ; then
      if test -f /opt/SUNWspro/prod/lib/libsunmath.so.1; then
        needs_libsunmath="yes"
        QEMU_CFLAGS="-I/opt/SUNWspro/prod/include/cc $QEMU_CFLAGS"
        LDFLAGS="-L/opt/SUNWspro/prod/lib -R/opt/SUNWspro/prod/lib $LDFLAGS"
        LIBS="-lsunmath $LIBS"
      else
        echo "QEMU will not link correctly on Solaris 8/X86 or 9/x86 without"
        echo "libsunmath from the Sun Studio compilers tools, due to a lack of"
        echo "C99 math features in libm.so in Solaris 8/x86 and Solaris 9/x86"
        echo "Studio 11 can be downloaded from www.sun.com."
        exit 1
      fi
    fi
  fi
  if test -f /usr/include/sys/soundcard.h ; then
    audio_drv_list="oss"
  fi
  audio_possible_drivers="oss sdl"
# needed for CMSG_ macros in sys/socket.h
  QEMU_CFLAGS="-D_XOPEN_SOURCE=600 $QEMU_CFLAGS"
# needed for TIOCWIN* defines in termios.h
  QEMU_CFLAGS="-D__EXTENSIONS__ $QEMU_CFLAGS"
  QEMU_CFLAGS="-std=gnu99 $QEMU_CFLAGS"
  LIBS="-lsocket -lnsl -lresolv $LIBS"
;;
AIX)
  aix="yes"
  make="${MAKE-gmake}"
;;
Haiku)
  haiku="yes"
  QEMU_CFLAGS="-DB_USE_POSITIVE_POSIX_ERRORS $QEMU_CFLAGS"
  LIBS="-lposix_error_mapper -lnetwork $LIBS"
;;
*)
  audio_drv_list="oss"
  audio_possible_drivers="oss alsa sdl esd pa"
  linux="yes"
  linux_user="yes"
  usb="linux"
  if [ "$cpu" = "i386" -o "$cpu" = "x86_64" ] ; then
    audio_possible_drivers="$audio_possible_drivers fmod"
  fi
;;
esac

if [ "$bsd" = "yes" ] ; then
  if [ "$darwin" != "yes" ] ; then
    usb="bsd"
  fi
  bsd_user="yes"
fi

: ${make=${MAKE-make}}
: ${install=${INSTALL-install}}

if test "$mingw32" = "yes" ; then
  EXESUF=".exe"
  QEMU_CFLAGS="-DWIN32_LEAN_AND_MEAN -DWINVER=0x501 $QEMU_CFLAGS"
  # enable C99/POSIX format strings (needs mingw32-runtime 3.15 or later)
  QEMU_CFLAGS="-D__USE_MINGW_ANSI_STDIO=1 $QEMU_CFLAGS"
  LIBS="-lwinmm -lws2_32 -liberty -liphlpapi $LIBS"
  prefix="c:/Program Files/Qemu"
  mandir="\${prefix}"
  datadir="\${prefix}"
  docdir="\${prefix}"
  bindir="\${prefix}"
  sysconfdir="\${prefix}"
  confsuffix=""
fi

werror=""

for opt do
  optarg=`expr "x$opt" : 'x[^=]*=\(.*\)'`
  case "$opt" in
  --help|-h) show_help=yes
  ;;
  --version|-V) exec cat $source_path/VERSION
  ;;
  --prefix=*) prefix="$optarg"
  ;;
  --interp-prefix=*) interp_prefix="$optarg"
  ;;
  --source-path=*)
  ;;
  --cross-prefix=*)
  ;;
  --cc=*)
  ;;
  --host-cc=*) host_cc="$optarg"
  ;;
  --make=*) make="$optarg"
  ;;
  --install=*) install="$optarg"
  ;;
  --extra-cflags=*)
  ;;
  --extra-ldflags=*)
  ;;
  --cpu=*)
  ;;
  --target-list=*) target_list="$optarg"
  ;;
  --enable-trace-backend=*) trace_backend="$optarg"
  ;;
  --with-trace-file=*) trace_file="$optarg"
  ;;
  --enable-gprof) gprof="yes"
  ;;
  --static)
    static="yes"
    LDFLAGS="-static $LDFLAGS"
  ;;
  --mandir=*) mandir="$optarg"
  ;;
  --bindir=*) bindir="$optarg"
  ;;
  --datadir=*) datadir="$optarg"
  ;;
  --docdir=*) docdir="$optarg"
  ;;
  --sysconfdir=*) sysconfdir="$optarg"
  ;;
  --disable-sdl) sdl="no"
  ;;
  --enable-sdl) sdl="yes"
  ;;
  --disable-vnc) vnc="no"
  ;;
  --enable-vnc) vnc="yes"
  ;;
  --fmod-lib=*) fmod_lib="$optarg"
  ;;
  --fmod-inc=*) fmod_inc="$optarg"
  ;;
  --oss-lib=*) oss_lib="$optarg"
  ;;
  --audio-card-list=*) audio_card_list=`echo "$optarg" | sed -e 's/,/ /g'`
  ;;
  --audio-drv-list=*) audio_drv_list="$optarg"
  ;;
  --block-drv-whitelist=*) block_drv_whitelist=`echo "$optarg" | sed -e 's/,/ /g'`
  ;;
  --enable-debug-tcg) debug_tcg="yes"
  ;;
  --disable-debug-tcg) debug_tcg="no"
  ;;
  --enable-debug-mon) debug_mon="yes"
  ;;
  --disable-debug-mon) debug_mon="no"
  ;;
  --enable-debug)
      # Enable debugging options that aren't excessively noisy
      debug_tcg="yes"
      debug_mon="yes"
      debug="yes"
      strip_opt="no"
  ;;
  --enable-sparse) sparse="yes"
  ;;
  --disable-sparse) sparse="no"
  ;;
  --disable-strip) strip_opt="no"
  ;;
  --disable-vnc-tls) vnc_tls="no"
  ;;
  --enable-vnc-tls) vnc_tls="yes"
  ;;
  --disable-vnc-sasl) vnc_sasl="no"
  ;;
  --enable-vnc-sasl) vnc_sasl="yes"
  ;;
  --disable-vnc-jpeg) vnc_jpeg="no"
  ;;
  --enable-vnc-jpeg) vnc_jpeg="yes"
  ;;
  --disable-vnc-png) vnc_png="no"
  ;;
  --enable-vnc-png) vnc_png="yes"
  ;;
  --disable-vnc-thread) vnc_thread="no"
  ;;
  --enable-vnc-thread) vnc_thread="yes"
  ;;
  --disable-slirp) slirp="no"
  ;;
  --disable-uuid) uuid="no"
  ;;
  --enable-uuid) uuid="yes"
  ;;
  --disable-vde) vde="no"
  ;;
  --enable-vde) vde="yes"
  ;;
  --disable-xen) xen="no"
  ;;
  --enable-xen) xen="yes"
  ;;
  --disable-brlapi) brlapi="no"
  ;;
  --enable-brlapi) brlapi="yes"
  ;;
  --disable-bluez) bluez="no"
  ;;
  --enable-bluez) bluez="yes"
  ;;
  --disable-kvm) kvm="no"
  ;;
  --enable-kvm) kvm="yes"
  ;;
  --disable-spice) spice="no"
  ;;
  --enable-spice) spice="yes"
  ;;
  --enable-profiler) profiler="yes"
  ;;
  --enable-cocoa)
      cocoa="yes" ;
      sdl="no" ;
      audio_drv_list="coreaudio `echo $audio_drv_list | sed s,coreaudio,,g`"
  ;;
  --disable-system) softmmu="no"
  ;;
  --enable-system) softmmu="yes"
  ;;
  --disable-user)
      linux_user="no" ;
      bsd_user="no" ;
      darwin_user="no"
  ;;
  --enable-user) ;;
  --disable-linux-user) linux_user="no"
  ;;
  --enable-linux-user) linux_user="yes"
  ;;
  --disable-darwin-user) darwin_user="no"
  ;;
  --enable-darwin-user) darwin_user="yes"
  ;;
  --disable-bsd-user) bsd_user="no"
  ;;
  --enable-bsd-user) bsd_user="yes"
  ;;
  --enable-guest-base) guest_base="yes"
  ;;
  --disable-guest-base) guest_base="no"
  ;;
  --enable-user-pie) user_pie="yes"
  ;;
  --disable-user-pie) user_pie="no"
  ;;
  --enable-uname-release=*) uname_release="$optarg"
  ;;
  --sparc_cpu=*)
  ;;
  --enable-werror) werror="yes"
  ;;
  --disable-werror) werror="no"
  ;;
  --disable-curses) curses="no"
  ;;
  --enable-curses) curses="yes"
  ;;
  --disable-curl) curl="no"
  ;;
  --enable-curl) curl="yes"
  ;;
  --disable-fdt) fdt="no"
  ;;
  --enable-fdt) fdt="yes"
  ;;
  --disable-check-utests) check_utests="no"
  ;;
  --enable-check-utests) check_utests="yes"
  ;;
  --disable-nptl) nptl="no"
  ;;
  --enable-nptl) nptl="yes"
  ;;
  --enable-mixemu) mixemu="yes"
  ;;
  --disable-linux-aio) linux_aio="no"
  ;;
  --enable-linux-aio) linux_aio="yes"
  ;;
  --disable-attr) attr="no"
  ;;
  --enable-attr) attr="yes"
  ;;
  --enable-io-thread) io_thread="yes"
  ;;
  --disable-blobs) blobs="no"
  ;;
  --kerneldir=*) kerneldir="$optarg"
  ;;
  --with-pkgversion=*) pkgversion=" ($optarg)"
  ;;
  --disable-docs) docs="no"
  ;;
  --enable-docs) docs="yes"
  ;;
  --disable-vhost-net) vhost_net="no"
  ;;
  --enable-vhost-net) vhost_net="yes"
  ;;
  --disable-opengl) opengl="no"
  ;;
  --enable-opengl) opengl="yes"
  ;;
  --*dir)
  ;;
  --disable-rbd) rbd="no"
  ;;
  --enable-rbd) rbd="yes"
  ;;
  --disable-smartcard) smartcard="no"
  ;;
  --enable-smartcard) smartcard="yes"
  ;;
  --disable-smartcard-nss) smartcard_nss="no"
  ;;
  --enable-smartcard-nss) smartcard_nss="yes"
  ;;
  *) echo "ERROR: unknown option $opt"; show_help="yes"
  ;;
  esac
done

#
# If cpu ~= sparc and  sparc_cpu hasn't been defined, plug in the right
# QEMU_CFLAGS/LDFLAGS (assume sparc_v8plus for 32-bit and sparc_v9 for 64-bit)
#
host_guest_base="no"
case "$cpu" in
    sparc) case $sparc_cpu in
           v7|v8)
             QEMU_CFLAGS="-mcpu=${sparc_cpu} -D__sparc_${sparc_cpu}__ $QEMU_CFLAGS"
           ;;
           v8plus|v8plusa)
             QEMU_CFLAGS="-mcpu=ultrasparc -D__sparc_${sparc_cpu}__ $QEMU_CFLAGS"
           ;;
           *) # sparc_cpu not defined in the command line
             QEMU_CFLAGS="-mcpu=ultrasparc -D__sparc_v8plus__ $QEMU_CFLAGS"
           esac
           LDFLAGS="-m32 $LDFLAGS"
           QEMU_CFLAGS="-m32 -ffixed-g2 -ffixed-g3 $QEMU_CFLAGS"
           if test "$solaris" = "no" ; then
             QEMU_CFLAGS="-ffixed-g1 -ffixed-g6 $QEMU_CFLAGS"
             helper_cflags="-ffixed-i0"
           fi
           ;;
    sparc64)
           QEMU_CFLAGS="-m64 -mcpu=ultrasparc -D__sparc_v9__ $QEMU_CFLAGS"
           LDFLAGS="-m64 $LDFLAGS"
           QEMU_CFLAGS="-ffixed-g5 -ffixed-g6 -ffixed-g7 $QEMU_CFLAGS"
           if test "$solaris" != "no" ; then
             QEMU_CFLAGS="-ffixed-g1 $QEMU_CFLAGS"
           fi
           ;;
    s390)
           QEMU_CFLAGS="-m31 -march=z990 $QEMU_CFLAGS"
           LDFLAGS="-m31 $LDFLAGS"
           host_guest_base="yes"
           ;;
    s390x)
           QEMU_CFLAGS="-m64 -march=z990 $QEMU_CFLAGS"
           LDFLAGS="-m64 $LDFLAGS"
           host_guest_base="yes"
           ;;
    i386)
           QEMU_CFLAGS="-m32 $QEMU_CFLAGS"
           LDFLAGS="-m32 $LDFLAGS"
           cc_i386='$(CC) -m32'
           helper_cflags="-fomit-frame-pointer"
           host_guest_base="yes"
           ;;
    x86_64)
           QEMU_CFLAGS="-m64 $QEMU_CFLAGS"
           LDFLAGS="-m64 $LDFLAGS"
           cc_i386='$(CC) -m32'
           host_guest_base="yes"
           ;;
    arm*)
           host_guest_base="yes"
           ;;
    ppc*)
           host_guest_base="yes"
           ;;
    mips*)
           host_guest_base="yes"
           ;;
    ia64*)
           host_guest_base="yes"
           ;;
    hppa*)
           host_guest_base="yes"
           ;;
    unicore32*)
           host_guest_base="yes"
           ;;
esac

[ -z "$guest_base" ] && guest_base="$host_guest_base"


default_target_list=""

# these targets are portable
if [ "$softmmu" = "yes" ] ; then
    default_target_list="\
i386-softmmu \
x86_64-softmmu \
arm-softmmu \
cris-softmmu \
lm32-softmmu \
m68k-softmmu \
microblaze-softmmu \
microblazeel-softmmu \
mips-softmmu \
mipsel-softmmu \
mips64-softmmu \
mips64el-softmmu \
ppc-softmmu \
ppcemb-softmmu \
ppc64-softmmu \
sh4-softmmu \
sh4eb-softmmu \
sparc-softmmu \
sparc64-softmmu \
s390x-softmmu \
"
fi
# the following are Linux specific
if [ "$linux_user" = "yes" ] ; then
    default_target_list="${default_target_list}\
i386-linux-user \
x86_64-linux-user \
alpha-linux-user \
arm-linux-user \
armeb-linux-user \
cris-linux-user \
m68k-linux-user \
microblaze-linux-user \
microblazeel-linux-user \
mips-linux-user \
mipsel-linux-user \
ppc-linux-user \
ppc64-linux-user \
ppc64abi32-linux-user \
sh4-linux-user \
sh4eb-linux-user \
sparc-linux-user \
sparc64-linux-user \
sparc32plus-linux-user \
unicore32-linux-user \
s390x-linux-user \
"
fi
# the following are Darwin specific
if [ "$darwin_user" = "yes" ] ; then
    default_target_list="$default_target_list i386-darwin-user ppc-darwin-user "
fi
# the following are BSD specific
if [ "$bsd_user" = "yes" ] ; then
    default_target_list="${default_target_list}\
i386-bsd-user \
x86_64-bsd-user \
sparc-bsd-user \
sparc64-bsd-user \
"
fi

if test x"$show_help" = x"yes" ; then
cat << EOF

Usage: configure [options]
Options: [defaults in brackets after descriptions]

EOF
echo "Standard options:"
echo "  --help                   print this message"
echo "  --prefix=PREFIX          install in PREFIX [$prefix]"
echo "  --interp-prefix=PREFIX   where to find shared libraries, etc."
echo "                           use %M for cpu name [$interp_prefix]"
echo "  --target-list=LIST       set target list (default: build everything)"
echo "Available targets: $default_target_list" | \
    fold -s -w 53 | sed -e 's/^/                           /'
echo ""
echo "Advanced options (experts only):"
echo "  --source-path=PATH       path of source code [$source_path]"
echo "  --cross-prefix=PREFIX    use PREFIX for compile tools [$cross_prefix]"
echo "  --cc=CC                  use C compiler CC [$cc]"
echo "  --host-cc=CC             use C compiler CC [$host_cc] for code run at"
echo "                           build time"
echo "  --extra-cflags=CFLAGS    append extra C compiler flags QEMU_CFLAGS"
echo "  --extra-ldflags=LDFLAGS  append extra linker flags LDFLAGS"
echo "  --make=MAKE              use specified make [$make]"
echo "  --install=INSTALL        use specified install [$install]"
echo "  --static                 enable static build [$static]"
echo "  --mandir=PATH            install man pages in PATH"
echo "  --datadir=PATH           install firmware in PATH"
echo "  --docdir=PATH            install documentation in PATH"
echo "  --bindir=PATH            install binaries in PATH"
echo "  --sysconfdir=PATH        install config in PATH/qemu"
echo "  --enable-debug-tcg       enable TCG debugging"
echo "  --disable-debug-tcg      disable TCG debugging (default)"
echo "  --enable-debug           enable common debug build options"
echo "  --enable-sparse          enable sparse checker"
echo "  --disable-sparse         disable sparse checker (default)"
echo "  --disable-strip          disable stripping binaries"
echo "  --disable-werror         disable compilation abort on warning"
echo "  --disable-sdl            disable SDL"
echo "  --enable-sdl             enable SDL"
echo "  --disable-vnc            disable VNC"
echo "  --enable-vnc             enable VNC"
echo "  --enable-cocoa           enable COCOA (Mac OS X only)"
echo "  --audio-drv-list=LIST    set audio drivers list:"
echo "                           Available drivers: $audio_possible_drivers"
echo "  --audio-card-list=LIST   set list of emulated audio cards [$audio_card_list]"
echo "                           Available cards: $audio_possible_cards"
echo "  --block-drv-whitelist=L  set block driver whitelist"
echo "                           (affects only QEMU, not qemu-img)"
echo "  --enable-mixemu          enable mixer emulation"
echo "  --disable-xen            disable xen backend driver support"
echo "  --enable-xen             enable xen backend driver support"
echo "  --disable-brlapi         disable BrlAPI"
echo "  --enable-brlapi          enable BrlAPI"
echo "  --disable-vnc-tls        disable TLS encryption for VNC server"
echo "  --enable-vnc-tls         enable TLS encryption for VNC server"
echo "  --disable-vnc-sasl       disable SASL encryption for VNC server"
echo "  --enable-vnc-sasl        enable SASL encryption for VNC server"
echo "  --disable-vnc-jpeg       disable JPEG lossy compression for VNC server"
echo "  --enable-vnc-jpeg        enable JPEG lossy compression for VNC server"
echo "  --disable-vnc-png        disable PNG compression for VNC server (default)"
echo "  --enable-vnc-png         enable PNG compression for VNC server"
echo "  --disable-vnc-thread     disable threaded VNC server"
echo "  --enable-vnc-thread      enable threaded VNC server"
echo "  --disable-curses         disable curses output"
echo "  --enable-curses          enable curses output"
echo "  --disable-curl           disable curl connectivity"
echo "  --enable-curl            enable curl connectivity"
echo "  --disable-fdt            disable fdt device tree"
echo "  --enable-fdt             enable fdt device tree"
echo "  --disable-check-utests   disable check unit-tests"
echo "  --enable-check-utests    enable check unit-tests"
echo "  --disable-bluez          disable bluez stack connectivity"
echo "  --enable-bluez           enable bluez stack connectivity"
echo "  --disable-kvm            disable KVM acceleration support"
echo "  --enable-kvm             enable KVM acceleration support"
echo "  --disable-nptl           disable usermode NPTL support"
echo "  --enable-nptl            enable usermode NPTL support"
echo "  --enable-system          enable all system emulation targets"
echo "  --disable-system         disable all system emulation targets"
echo "  --enable-user            enable supported user emulation targets"
echo "  --disable-user           disable all user emulation targets"
echo "  --enable-linux-user      enable all linux usermode emulation targets"
echo "  --disable-linux-user     disable all linux usermode emulation targets"
echo "  --enable-darwin-user     enable all darwin usermode emulation targets"
echo "  --disable-darwin-user    disable all darwin usermode emulation targets"
echo "  --enable-bsd-user        enable all BSD usermode emulation targets"
echo "  --disable-bsd-user       disable all BSD usermode emulation targets"
echo "  --enable-guest-base      enable GUEST_BASE support for usermode"
echo "                           emulation targets"
echo "  --disable-guest-base     disable GUEST_BASE support"
echo "  --enable-user-pie        build usermode emulation targets as PIE"
echo "  --disable-user-pie       do not build usermode emulation targets as PIE"
echo "  --fmod-lib               path to FMOD library"
echo "  --fmod-inc               path to FMOD includes"
echo "  --oss-lib                path to OSS library"
echo "  --enable-uname-release=R Return R for uname -r in usermode emulation"
echo "  --sparc_cpu=V            Build qemu for Sparc architecture v7, v8, v8plus, v8plusa, v9"
echo "  --disable-uuid           disable uuid support"
echo "  --enable-uuid            enable uuid support"
echo "  --disable-vde            disable support for vde network"
echo "  --enable-vde             enable support for vde network"
echo "  --disable-linux-aio      disable Linux AIO support"
echo "  --enable-linux-aio       enable Linux AIO support"
echo "  --disable-attr           disables attr and xattr support"
echo "  --enable-attr            enable attr and xattr support"
echo "  --enable-io-thread       enable IO thread"
echo "  --disable-blobs          disable installing provided firmware blobs"
echo "  --kerneldir=PATH         look for kernel includes in PATH"
echo "  --enable-docs            enable documentation build"
echo "  --disable-docs           disable documentation build"
echo "  --disable-vhost-net      disable vhost-net acceleration support"
echo "  --enable-vhost-net       enable vhost-net acceleration support"
echo "  --enable-trace-backend=B Set trace backend"
echo "                           Available backends:" $("$source_path"/scripts/tracetool --list-backends)
echo "  --with-trace-file=NAME   Full PATH,NAME of file to store traces"
echo "                           Default:trace-<pid>"
echo "  --disable-spice          disable spice"
echo "  --enable-spice           enable spice"
echo "  --enable-rbd             enable building the rados block device (rbd)"
echo "  --disable-smartcard      disable smartcard support"
echo "  --enable-smartcard       enable smartcard support"
echo "  --disable-smartcard-nss  disable smartcard nss support"
echo "  --enable-smartcard-nss   enable smartcard nss support"
echo ""
echo "NOTE: The object files are built at the place where configure is launched"
exit 1
fi

# check that the C compiler works.
cat > $TMPC <<EOF
int main(void) {}
EOF

if compile_object ; then
  : C compiler works ok
else
    echo "ERROR: \"$cc\" either does not exist or does not work"
    exit 1
fi

gcc_flags="-Wold-style-declaration -Wold-style-definition -Wtype-limits"
gcc_flags="-Wformat-security -Wformat-y2k -Winit-self -Wignored-qualifiers $gcc_flags"
gcc_flags="-Wmissing-include-dirs -Wempty-body -Wnested-externs $gcc_flags"
gcc_flags="-fstack-protector-all $gcc_flags"
cat > $TMPC << EOF
int main(void) { return 0; }
EOF
for flag in $gcc_flags; do
    if compile_prog "-Werror $QEMU_CFLAGS" "-Werror $flag" ; then
	QEMU_CFLAGS="$QEMU_CFLAGS $flag"
    fi
done

#
# Solaris specific configure tool chain decisions
#
if test "$solaris" = "yes" ; then
  if has $install; then
    :
  else
    echo "Solaris install program not found. Use --install=/usr/ucb/install or"
    echo "install fileutils from www.blastwave.org using pkg-get -i fileutils"
    echo "to get ginstall which is used by default (which lives in /opt/csw/bin)"
    exit 1
  fi
  if test "`path_of $install`" = "/usr/sbin/install" ; then
    echo "Error: Solaris /usr/sbin/install is not an appropriate install program."
    echo "try ginstall from the GNU fileutils available from www.blastwave.org"
    echo "using pkg-get -i fileutils, or use --install=/usr/ucb/install"
    exit 1
  fi
  if has ar; then
    :
  else
    echo "Error: No path includes ar"
    if test -f /usr/ccs/bin/ar ; then
      echo "Add /usr/ccs/bin to your path and rerun configure"
    fi
    exit 1
  fi
fi

if test -z "$target_list" ; then
    target_list="$default_target_list"
else
    target_list=`echo "$target_list" | sed -e 's/,/ /g'`
fi
if test -z "$target_list" ; then
    echo "No targets enabled"
    exit 1
fi
# see if system emulation was really requested
case " $target_list " in
  *"-softmmu "*) softmmu=yes
  ;;
  *) softmmu=no
  ;;
esac

feature_not_found() {
  feature=$1

  echo "ERROR"
  echo "ERROR: User requested feature $feature"
  echo "ERROR: configure was not able to find it"
  echo "ERROR"
  exit 1;
}

if test -z "$cross_prefix" ; then

# ---
# big/little endian test
cat > $TMPC << EOF
#include <inttypes.h>
int main(int argc, char ** argv){
        volatile uint32_t i=0x01234567;
        return (*((uint8_t*)(&i))) == 0x67;
}
EOF

if compile_prog "" "" ; then
$TMPE && bigendian="yes"
else
echo big/little test failed
fi

else

# if cross compiling, cannot launch a program, so make a static guess
case "$cpu" in
  armv4b|hppa|m68k|mips|mips64|ppc|ppc64|s390|s390x|sparc|sparc64)
    bigendian=yes
  ;;
esac

fi

# host long bits test, actually a pointer size test
cat > $TMPC << EOF
int sizeof_pointer_is_8[sizeof(void *) == 8 ? 1 : -1];
EOF
if compile_object; then
hostlongbits=64
else
hostlongbits=32
fi


##########################################
# NPTL probe

if test "$nptl" != "no" ; then
  cat > $TMPC <<EOF
#include <sched.h>
#include <linux/futex.h>
void foo()
{
#if !defined(CLONE_SETTLS) || !defined(FUTEX_WAIT)
#error bork
#endif
}
EOF

  if compile_object ; then
    nptl=yes
  else
    if test "$nptl" = "yes" ; then
      feature_not_found "nptl"
    fi
    nptl=no
  fi
fi

##########################################
# zlib check

cat > $TMPC << EOF
#include <zlib.h>
int main(void) { zlibVersion(); return 0; }
EOF
if compile_prog "" "-lz" ; then
    :
else
    echo
    echo "Error: zlib check failed"
    echo "Make sure to have the zlib libs and headers installed."
    echo
    exit 1
fi

##########################################
# xen probe

if test "$xen" != "no" ; then
  xen_libs="-lxenstore -lxenctrl -lxenguest"

  # Xen unstable
  cat > $TMPC <<EOF
#include <xenctrl.h>
#include <xs.h>
#include <stdint.h>
#include <xen/hvm/hvm_info_table.h>
#if !defined(HVM_MAX_VCPUS)
# error HVM_MAX_VCPUS not defined
#endif
int main(void) {
  xc_interface *xc;
  xs_daemon_open();
  xc = xc_interface_open(0, 0, 0);
  xc_hvm_set_mem_type(0, 0, HVMMEM_ram_ro, 0, 0);
  xc_gnttab_open(NULL, 0);
  return 0;
}
EOF
  if compile_prog "" "$xen_libs" ; then
    xen_ctrl_version=410
    xen=yes

  # Xen 4.0.0
  elif (
      cat > $TMPC <<EOF
#include <xenctrl.h>
#include <xs.h>
#include <stdint.h>
#include <xen/hvm/hvm_info_table.h>
#if !defined(HVM_MAX_VCPUS)
# error HVM_MAX_VCPUS not defined
#endif
int main(void) {
  xs_daemon_open();
  xc_interface_open();
  xc_gnttab_open();
  xc_hvm_set_mem_type(0, 0, HVMMEM_ram_ro, 0, 0);
  return 0;
}
EOF
      compile_prog "" "$xen_libs"
    ) ; then
    xen_ctrl_version=400
    xen=yes

  # Xen 3.3.0, 3.4.0
  elif (
      cat > $TMPC <<EOF
#include <xenctrl.h>
#include <xs.h>
int main(void) {
  xs_daemon_open();
  xc_interface_open();
  xc_gnttab_open();
  xc_hvm_set_mem_type(0, 0, HVMMEM_ram_ro, 0, 0);
  return 0;
}
EOF
      compile_prog "" "$xen_libs"
    ) ; then
    xen_ctrl_version=330
    xen=yes

  # Xen not found or unsupported
  else
    if test "$xen" = "yes" ; then
      feature_not_found "xen"
    fi
    xen=no
  fi

  if test "$xen" = yes; then
    libs_softmmu="$xen_libs $libs_softmmu"
  fi
fi

##########################################
# pkg-config probe

if ! has $pkg_config; then
  echo warning: proceeding without "$pkg_config" >&2
  pkg_config=/bin/false
fi

##########################################
# Sparse probe
if test "$sparse" != "no" ; then
  if has cgcc; then
    sparse=yes
  else
    if test "$sparse" = "yes" ; then
      feature_not_found "sparse"
    fi
    sparse=no
  fi
fi

##########################################
# SDL probe

# Look for sdl configuration program (pkg-config or sdl-config).  Try
# sdl-config even without cross prefix, and favour pkg-config over sdl-config.
if test "`basename $sdl_config`" != sdl-config && ! has ${sdl_config}; then
  sdl_config=sdl-config
fi

if $pkg_config sdl --modversion >/dev/null 2>&1; then
  sdlconfig="$pkg_config sdl"
  _sdlversion=`$sdlconfig --modversion 2>/dev/null | sed 's/[^0-9]//g'`
elif has ${sdl_config}; then
  sdlconfig="$sdl_config"
  _sdlversion=`$sdlconfig --version | sed 's/[^0-9]//g'`
else
  if test "$sdl" = "yes" ; then
    feature_not_found "sdl"
  fi
  sdl=no
fi
if test -n "$cross_prefix" && test "$(basename "$sdlconfig")" = sdl-config; then
  echo warning: using "\"$sdlconfig\"" to detect cross-compiled sdl >&2
fi

sdl_too_old=no
if test "$sdl" != "no" ; then
  cat > $TMPC << EOF
#include <SDL.h>
#undef main /* We don't want SDL to override our main() */
int main( void ) { return SDL_Init (SDL_INIT_VIDEO); }
EOF
  sdl_cflags=`$sdlconfig --cflags 2> /dev/null`
  if test "$static" = "yes" ; then
    sdl_libs=`$sdlconfig --static-libs 2>/dev/null`
  else
    sdl_libs=`$sdlconfig --libs 2> /dev/null`
  fi
  if compile_prog "$sdl_cflags" "$sdl_libs" ; then
    if test "$_sdlversion" -lt 121 ; then
      sdl_too_old=yes
    else
      if test "$cocoa" = "no" ; then
        sdl=yes
      fi
    fi

    # static link with sdl ? (note: sdl.pc's --static --libs is broken)
    if test "$sdl" = "yes" -a "$static" = "yes" ; then
      if test $? = 0 && echo $sdl_libs | grep -- -laa > /dev/null; then
         sdl_libs="$sdl_libs `aalib-config --static-libs 2>/dev/null`"
         sdl_cflags="$sdl_cflags `aalib-config --cflags 2>/dev/null`"
      fi
      if compile_prog "$sdl_cflags" "$sdl_libs" ; then
	:
      else
        sdl=no
      fi
    fi # static link
  else # sdl not found
    if test "$sdl" = "yes" ; then
      feature_not_found "sdl"
    fi
    sdl=no
  fi # sdl compile test
fi

if test "$sdl" = "yes" ; then
  cat > $TMPC <<EOF
#include <SDL.h>
#if defined(SDL_VIDEO_DRIVER_X11)
#include <X11/XKBlib.h>
#else
#error No x11 support
#endif
int main(void) { return 0; }
EOF
  if compile_prog "$sdl_cflags" "$sdl_libs" ; then
    sdl_libs="$sdl_libs -lX11"
  fi
  if test "$mingw32" = "yes" ; then
    sdl_libs="`echo $sdl_libs | sed s/-mwindows//g` -mconsole"
  fi
  libs_softmmu="$sdl_libs $libs_softmmu"
fi

##########################################
# VNC TLS detection
if test "$vnc" = "yes" -a "$vnc_tls" != "no" ; then
  cat > $TMPC <<EOF
#include <gnutls/gnutls.h>
int main(void) { gnutls_session_t s; gnutls_init(&s, GNUTLS_SERVER); return 0; }
EOF
  vnc_tls_cflags=`$pkg_config --cflags gnutls 2> /dev/null`
  vnc_tls_libs=`$pkg_config --libs gnutls 2> /dev/null`
  if compile_prog "$vnc_tls_cflags" "$vnc_tls_libs" ; then
    vnc_tls=yes
    libs_softmmu="$vnc_tls_libs $libs_softmmu"
  else
    if test "$vnc_tls" = "yes" ; then
      feature_not_found "vnc-tls"
    fi
    vnc_tls=no
  fi
fi

##########################################
# VNC SASL detection
if test "$vnc" = "yes" -a "$vnc_sasl" != "no" ; then
  cat > $TMPC <<EOF
#include <sasl/sasl.h>
#include <stdio.h>
int main(void) { sasl_server_init(NULL, "qemu"); return 0; }
EOF
  # Assuming Cyrus-SASL installed in /usr prefix
  vnc_sasl_cflags=""
  vnc_sasl_libs="-lsasl2"
  if compile_prog "$vnc_sasl_cflags" "$vnc_sasl_libs" ; then
    vnc_sasl=yes
    libs_softmmu="$vnc_sasl_libs $libs_softmmu"
  else
    if test "$vnc_sasl" = "yes" ; then
      feature_not_found "vnc-sasl"
    fi
    vnc_sasl=no
  fi
fi

##########################################
# VNC JPEG detection
if test "$vnc" = "yes" -a "$vnc_jpeg" != "no" ; then
cat > $TMPC <<EOF
#include <stdio.h>
#include <jpeglib.h>
int main(void) { struct jpeg_compress_struct s; jpeg_create_compress(&s); return 0; }
EOF
    vnc_jpeg_cflags=""
    vnc_jpeg_libs="-ljpeg"
  if compile_prog "$vnc_jpeg_cflags" "$vnc_jpeg_libs" ; then
    vnc_jpeg=yes
    libs_softmmu="$vnc_jpeg_libs $libs_softmmu"
  else
    if test "$vnc_jpeg" = "yes" ; then
      feature_not_found "vnc-jpeg"
    fi
    vnc_jpeg=no
  fi
fi

##########################################
# VNC PNG detection
if test "$vnc" = "yes" -a "$vnc_png" != "no" ; then
cat > $TMPC <<EOF
//#include <stdio.h>
#include <png.h>
#include <stddef.h>
int main(void) {
    png_structp png_ptr;
    png_ptr = png_create_write_struct(PNG_LIBPNG_VER_STRING, NULL, NULL, NULL);
    return 0;
}
EOF
    vnc_png_cflags=""
    vnc_png_libs="-lpng"
  if compile_prog "$vnc_png_cflags" "$vnc_png_libs" ; then
    vnc_png=yes
    libs_softmmu="$vnc_png_libs $libs_softmmu"
  else
    if test "$vnc_png" = "yes" ; then
      feature_not_found "vnc-png"
    fi
    vnc_png=no
  fi
fi

##########################################
# fnmatch() probe, used for ACL routines
fnmatch="no"
cat > $TMPC << EOF
#include <fnmatch.h>
int main(void)
{
    fnmatch("foo", "foo", 0);
    return 0;
}
EOF
if compile_prog "" "" ; then
   fnmatch="yes"
fi

##########################################
# uuid_generate() probe, used for vdi block driver
if test "$uuid" != "no" ; then
  uuid_libs="-luuid"
  cat > $TMPC << EOF
#include <uuid/uuid.h>
int main(void)
{
    uuid_t my_uuid;
    uuid_generate(my_uuid);
    return 0;
}
EOF
  if compile_prog "" "$uuid_libs" ; then
    uuid="yes"
    libs_softmmu="$uuid_libs $libs_softmmu"
    libs_tools="$uuid_libs $libs_tools"
  else
    if test "$uuid" = "yes" ; then
      feature_not_found "uuid"
    fi
    uuid=no
  fi
fi

##########################################
# xfsctl() probe, used for raw-posix
if test "$xfs" != "no" ; then
  cat > $TMPC << EOF
#include <xfs/xfs.h>
int main(void)
{
    xfsctl(NULL, 0, 0, NULL);
    return 0;
}
EOF
  if compile_prog "" "" ; then
    xfs="yes"
  else
    if test "$xfs" = "yes" ; then
      feature_not_found "xfs"
    fi
    xfs=no
  fi
fi

##########################################
# vde libraries probe
if test "$vde" != "no" ; then
  vde_libs="-lvdeplug"
  cat > $TMPC << EOF
#include <libvdeplug.h>
int main(void)
{
    struct vde_open_args a = {0, 0, 0};
    vde_open("", "", &a);
    return 0;
}
EOF
  if compile_prog "" "$vde_libs" ; then
    vde=yes
    libs_softmmu="$vde_libs $libs_softmmu"
    libs_tools="$vde_libs $libs_tools"
  else
    if test "$vde" = "yes" ; then
      feature_not_found "vde"
    fi
    vde=no
  fi
fi

##########################################
# Sound support libraries probe

audio_drv_probe()
{
    drv=$1
    hdr=$2
    lib=$3
    exp=$4
    cfl=$5
        cat > $TMPC << EOF
#include <$hdr>
int main(void) { $exp }
EOF
    if compile_prog "$cfl" "$lib" ; then
        :
    else
        echo
        echo "Error: $drv check failed"
        echo "Make sure to have the $drv libs and headers installed."
        echo
        exit 1
    fi
}

audio_drv_list=`echo "$audio_drv_list" | sed -e 's/,/ /g'`
for drv in $audio_drv_list; do
    case $drv in
    alsa)
    audio_drv_probe $drv alsa/asoundlib.h -lasound \
        "snd_pcm_t **handle; return snd_pcm_close(*handle);"
    libs_softmmu="-lasound $libs_softmmu"
    ;;

    fmod)
    if test -z $fmod_lib || test -z $fmod_inc; then
        echo
        echo "Error: You must specify path to FMOD library and headers"
        echo "Example: --fmod-inc=/path/include/fmod --fmod-lib=/path/lib/libfmod-3.74.so"
        echo
        exit 1
    fi
    audio_drv_probe $drv fmod.h $fmod_lib "return FSOUND_GetVersion();" "-I $fmod_inc"
    libs_softmmu="$fmod_lib $libs_softmmu"
    ;;

    esd)
    audio_drv_probe $drv esd.h -lesd 'return esd_play_stream(0, 0, "", 0);'
    libs_softmmu="-lesd $libs_softmmu"
    audio_pt_int="yes"
    ;;

    pa)
    audio_drv_probe $drv pulse/simple.h "-lpulse-simple -lpulse" \
        "pa_simple *s = NULL; pa_simple_free(s); return 0;"
    libs_softmmu="-lpulse -lpulse-simple $libs_softmmu"
    audio_pt_int="yes"
    ;;

    coreaudio)
      libs_softmmu="-framework CoreAudio $libs_softmmu"
    ;;

    dsound)
      libs_softmmu="-lole32 -ldxguid $libs_softmmu"
      audio_win_int="yes"
    ;;

    oss)
      libs_softmmu="$oss_lib $libs_softmmu"
    ;;

    sdl|wav)
    # XXX: Probes for CoreAudio, DirectSound, SDL(?)
    ;;

    winwave)
      libs_softmmu="-lwinmm $libs_softmmu"
      audio_win_int="yes"
    ;;

    *)
    echo "$audio_possible_drivers" | grep -q "\<$drv\>" || {
        echo
        echo "Error: Unknown driver '$drv' selected"
        echo "Possible drivers are: $audio_possible_drivers"
        echo
        exit 1
    }
    ;;
    esac
done

##########################################
# BrlAPI probe

if test "$brlapi" != "no" ; then
  brlapi_libs="-lbrlapi"
  cat > $TMPC << EOF
#include <brlapi.h>
#include <stddef.h>
int main( void ) { return brlapi__openConnection (NULL, NULL, NULL); }
EOF
  if compile_prog "" "$brlapi_libs" ; then
    brlapi=yes
    libs_softmmu="$brlapi_libs $libs_softmmu"
  else
    if test "$brlapi" = "yes" ; then
      feature_not_found "brlapi"
    fi
    brlapi=no
  fi
fi

##########################################
# curses probe
if test "$mingw32" = "yes" ; then
    curses_list="-lpdcurses"
else
    curses_list="-lncurses -lcurses"
fi

if test "$curses" != "no" ; then
  curses_found=no
  cat > $TMPC << EOF
#include <curses.h>
#ifdef __OpenBSD__
#define resize_term resizeterm
#endif
int main(void) { resize_term(0, 0); return curses_version(); }
EOF
  for curses_lib in $curses_list; do
    if compile_prog "" "$curses_lib" ; then
      curses_found=yes
      libs_softmmu="$curses_lib $libs_softmmu"
      break
    fi
  done
  if test "$curses_found" = "yes" ; then
    curses=yes
  else
    if test "$curses" = "yes" ; then
      feature_not_found "curses"
    fi
    curses=no
  fi
fi

##########################################
# curl probe

if $pkg_config libcurl --modversion >/dev/null 2>&1; then
  curlconfig="$pkg_config libcurl"
else
  curlconfig=curl-config
fi

if test "$curl" != "no" ; then
  cat > $TMPC << EOF
#include <curl/curl.h>
int main(void) { return curl_easy_init(); }
EOF
  curl_cflags=`$curlconfig --cflags 2>/dev/null`
  curl_libs=`$curlconfig --libs 2>/dev/null`
  if compile_prog "$curl_cflags" "$curl_libs" ; then
    curl=yes
    libs_tools="$curl_libs $libs_tools"
    libs_softmmu="$curl_libs $libs_softmmu"
  else
    if test "$curl" = "yes" ; then
      feature_not_found "curl"
    fi
    curl=no
  fi
fi # test "$curl"

##########################################
# check framework probe

if test "$check_utests" != "no" ; then
  cat > $TMPC << EOF
#include <check.h>
int main(void) { suite_create("qemu test"); return 0; }
EOF
  check_libs=`$pkg_config --libs check`
  if compile_prog "" $check_libs ; then
    check_utests=yes
    libs_tools="$check_libs $libs_tools"
  else
    if test "$check_utests" = "yes" ; then
      feature_not_found "check"
    fi
    check_utests=no
  fi
fi # test "$check_utests"

##########################################
# bluez support probe
if test "$bluez" != "no" ; then
  cat > $TMPC << EOF
#include <bluetooth/bluetooth.h>
int main(void) { return bt_error(0); }
EOF
  bluez_cflags=`$pkg_config --cflags bluez 2> /dev/null`
  bluez_libs=`$pkg_config --libs bluez 2> /dev/null`
  if compile_prog "$bluez_cflags" "$bluez_libs" ; then
    bluez=yes
    libs_softmmu="$bluez_libs $libs_softmmu"
  else
    if test "$bluez" = "yes" ; then
      feature_not_found "bluez"
    fi
    bluez="no"
  fi
fi

##########################################
# kvm probe
if test "$kvm" != "no" ; then
    cat > $TMPC <<EOF
#include <linux/kvm.h>
#if !defined(KVM_API_VERSION) || KVM_API_VERSION < 12 || KVM_API_VERSION > 12
#error Invalid KVM version
#endif
EOF
    must_have_caps="KVM_CAP_USER_MEMORY \
                    KVM_CAP_DESTROY_MEMORY_REGION_WORKS \
                    KVM_CAP_COALESCED_MMIO \
                    KVM_CAP_SYNC_MMU \
                   "
    if test \( "$cpu" = "i386" -o "$cpu" = "x86_64" \) ; then
      must_have_caps="$caps \
                      KVM_CAP_SET_TSS_ADDR \
                      KVM_CAP_EXT_CPUID \
                      KVM_CAP_CLOCKSOURCE \
                      KVM_CAP_NOP_IO_DELAY \
                      KVM_CAP_PV_MMU \
                      KVM_CAP_MP_STATE \
                      KVM_CAP_USER_NMI \
                     "
    fi
    for c in $must_have_caps ; do
      cat >> $TMPC <<EOF
#if !defined($c)
#error Missing KVM capability $c
#endif
EOF
    done
    cat >> $TMPC <<EOF
int main(void) { return 0; }
EOF
  if test "$kerneldir" != "" ; then
      kvm_cflags=-I"$kerneldir"/include
      if test \( "$cpu" = "i386" -o "$cpu" = "x86_64" \) \
         -a -d "$kerneldir/arch/x86/include" ; then
            kvm_cflags="$kvm_cflags -I$kerneldir/arch/x86/include"
	elif test "$cpu" = "ppc" -a -d "$kerneldir/arch/powerpc/include" ; then
	    kvm_cflags="$kvm_cflags -I$kerneldir/arch/powerpc/include"
	elif test "$cpu" = "s390x" -a -d "$kerneldir/arch/s390/include" ; then
	    kvm_cflags="$kvm_cflags -I$kerneldir/arch/s390/include"
        elif test -d "$kerneldir/arch/$cpu/include" ; then
            kvm_cflags="$kvm_cflags -I$kerneldir/arch/$cpu/include"
      fi
  else
    kvm_cflags=`$pkg_config --cflags kvm-kmod 2>/dev/null`
  fi
  if compile_prog "$kvm_cflags" "" ; then
    kvm=yes
    cat > $TMPC <<EOF
#include <linux/kvm_para.h>
int main(void) { return 0; }
EOF
    if compile_prog "$kvm_cflags" "" ; then
      kvm_para=yes
    fi
  else
    if test "$kvm" = "yes" ; then
      if has awk && has grep; then
        kvmerr=`LANG=C $cc $QEMU_CFLAGS -o $TMPE $kvm_cflags $TMPC 2>&1 \
	| grep "error: " \
	| awk -F "error: " '{if (NR>1) printf(", "); printf("%s",$2);}'`
        if test "$kvmerr" != "" ; then
          echo -e "${kvmerr}\n\
NOTE: To enable KVM support, update your kernel to 2.6.29+ or install \
recent kvm-kmod from http://sourceforge.net/projects/kvm."
        fi
      fi
      feature_not_found "kvm"
    fi
    kvm=no
  fi
fi

##########################################
# test for ppc kvm pvr setting

if test "$kvm" = "yes" && test "$cpu" = "ppc" -o "$cpu" = "ppc64"; then
            cat > $TMPC <<EOF
    #include <asm/kvm.h>
    int main(void) { struct kvm_sregs s; s.pvr = 0; return 0; }
EOF
    if compile_prog "$kvm_cflags" "" ; then
        kvm_ppc_pvr=yes
    else
        kvm_ppc_pvr=no
    fi
fi

##########################################
# test for vhost net

if test "$vhost_net" != "no"; then
    if test "$kvm" != "no"; then
            cat > $TMPC <<EOF
    #include <linux/vhost.h>
    int main(void) { return 0; }
EOF
            if compile_prog "$kvm_cflags" "" ; then
                vhost_net=yes
            else
                if test "$vhost_net" = "yes" ; then
                    feature_not_found "vhost-net"
                fi
                vhost_net=no
            fi
    else
            if test "$vhost_net" = "yes" ; then
                echo "NOTE: vhost-net feature requires KVM (--enable-kvm)."
                feature_not_found "vhost-net"
            fi
            vhost_net=no
    fi
fi

##########################################
# pthread probe
PTHREADLIBS_LIST="-lpthread -lpthreadGC2"

pthread=no
cat > $TMPC << EOF
#include <pthread.h>
int main(void) { pthread_create(0,0,0,0); return 0; }
EOF
if compile_prog "" "" ; then
  pthread=yes
else
  for pthread_lib in $PTHREADLIBS_LIST; do
    if compile_prog "" "$pthread_lib" ; then
      pthread=yes
      LIBS="$pthread_lib $LIBS"
      break
    fi
  done
fi

if test "$mingw32" != yes -a "$pthread" = no; then
  echo
  echo "Error: pthread check failed"
  echo "Make sure to have the pthread libs and headers installed."
  echo
  exit 1
fi

##########################################
# rbd probe
if test "$rbd" != "no" ; then
  cat > $TMPC <<EOF
#include <stdio.h>
#include <rados/librados.h>
int main(void) { rados_initialize(0, NULL); return 0; }
EOF
  rbd_libs="-lrados"
  if compile_prog "" "$rbd_libs" ; then
    librados_too_old=no
    cat > $TMPC <<EOF
#include <stdio.h>
#include <rados/librados.h>
#ifndef CEPH_OSD_TMAP_SET
#error missing CEPH_OSD_TMAP_SET
#endif
int main(void) {
    int (*func)(const rados_pool_t pool, uint64_t *snapid) = rados_selfmanaged_snap_create;
    rados_initialize(0, NULL);
    return 0;
}
EOF
    if compile_prog "" "$rbd_libs" ; then
      rbd=yes
      libs_tools="$rbd_libs $libs_tools"
      libs_softmmu="$rbd_libs $libs_softmmu"
    else
      rbd=no
      librados_too_old=yes
    fi
  else
    if test "$rbd" = "yes" ; then
      feature_not_found "rados block device"
    fi
    rbd=no
  fi
  if test "$librados_too_old" = "yes" ; then
    echo "-> Your librados version is too old - upgrade needed to have rbd support"
  fi
fi

##########################################
# linux-aio probe

if test "$linux_aio" != "no" ; then
  cat > $TMPC <<EOF
#include <libaio.h>
#include <sys/eventfd.h>
#include <stddef.h>
int main(void) { io_setup(0, NULL); io_set_eventfd(NULL, 0); eventfd(0, 0); return 0; }
EOF
  if compile_prog "" "-laio" ; then
    linux_aio=yes
    libs_softmmu="$libs_softmmu -laio"
    libs_tools="$libs_tools -laio"
  else
    if test "$linux_aio" = "yes" ; then
      feature_not_found "linux AIO"
    fi
    linux_aio=no
  fi
fi

##########################################
# attr probe

if test "$attr" != "no" ; then
  cat > $TMPC <<EOF
#include <stdio.h>
#include <sys/types.h>
#include <attr/xattr.h>
int main(void) { getxattr(NULL, NULL, NULL, 0); setxattr(NULL, NULL, NULL, 0, 0); return 0; }
EOF
  if compile_prog "" "-lattr" ; then
    attr=yes
    LIBS="-lattr $LIBS"
  else
    if test "$attr" = "yes" ; then
      feature_not_found "ATTR"
    fi
    attr=no
  fi
fi

##########################################
# iovec probe
cat > $TMPC <<EOF
#include <sys/types.h>
#include <sys/uio.h>
#include <unistd.h>
int main(void) { struct iovec iov; return 0; }
EOF
iovec=no
if compile_prog "" "" ; then
  iovec=yes
fi

##########################################
# preadv probe
cat > $TMPC <<EOF
#include <sys/types.h>
#include <sys/uio.h>
#include <unistd.h>
int main(void) { preadv; }
EOF
preadv=no
if compile_prog "" "" ; then
  preadv=yes
fi

##########################################
# fdt probe
if test "$fdt" != "no" ; then
  fdt_libs="-lfdt"
  cat > $TMPC << EOF
int main(void) { return 0; }
EOF
  if compile_prog "" "$fdt_libs" ; then
    fdt=yes
  else
    if test "$fdt" = "yes" ; then
      feature_not_found "fdt"
    fi
    fdt_libs=
    fdt=no
  fi
fi

##########################################
# opengl probe, used by milkymist-tmu2
if test "$opengl" != "no" ; then
  opengl_libs="-lGL"
  cat > $TMPC << EOF
#include <X11/Xlib.h>
#include <GL/gl.h>
#include <GL/glx.h>
int main(void) { GL_VERSION; return 0; }
EOF
  if compile_prog "" "-lGL" ; then
    opengl=yes
  else
    if test "$opengl" = "yes" ; then
      feature_not_found "opengl"
    fi
    opengl_libs=
    opengl=no
  fi
fi

#
# Check for xxxat() functions when we are building linux-user
# emulator.  This is done because older glibc versions don't
# have syscall stubs for these implemented.
#
atfile=no
cat > $TMPC << EOF
#define _ATFILE_SOURCE
#include <sys/types.h>
#include <fcntl.h>
#include <unistd.h>

int
main(void)
{
	/* try to unlink nonexisting file */
	return (unlinkat(AT_FDCWD, "nonexistent_file", 0));
}
EOF
if compile_prog "" "" ; then
  atfile=yes
fi

# Check for inotify functions when we are building linux-user
# emulator.  This is done because older glibc versions don't
# have syscall stubs for these implemented.  In that case we
# don't provide them even if kernel supports them.
#
inotify=no
cat > $TMPC << EOF
#include <sys/inotify.h>

int
main(void)
{
	/* try to start inotify */
	return inotify_init();
}
EOF
if compile_prog "" "" ; then
  inotify=yes
fi

inotify1=no
cat > $TMPC << EOF
#include <sys/inotify.h>

int
main(void)
{
    /* try to start inotify */
    return inotify_init1(0);
}
EOF
if compile_prog "" "" ; then
  inotify1=yes
fi

# check if utimensat and futimens are supported
utimens=no
cat > $TMPC << EOF
#define _ATFILE_SOURCE
#include <stddef.h>
#include <fcntl.h>

int main(void)
{
    utimensat(AT_FDCWD, "foo", NULL, 0);
    futimens(0, NULL);
    return 0;
}
EOF
if compile_prog "" "" ; then
  utimens=yes
fi

# check if pipe2 is there
pipe2=no
cat > $TMPC << EOF
#include <unistd.h>
#include <fcntl.h>

int main(void)
{
    int pipefd[2];
    pipe2(pipefd, O_CLOEXEC);
    return 0;
}
EOF
if compile_prog "" "" ; then
  pipe2=yes
fi

# check if accept4 is there
accept4=no
cat > $TMPC << EOF
#include <sys/socket.h>
#include <stddef.h>

int main(void)
{
    accept4(0, NULL, NULL, SOCK_CLOEXEC);
    return 0;
}
EOF
if compile_prog "" "" ; then
  accept4=yes
fi

# check if tee/splice is there. vmsplice was added same time.
splice=no
cat > $TMPC << EOF
#include <unistd.h>
#include <fcntl.h>
#include <limits.h>

int main(void)
{
    int len, fd;
    len = tee(STDIN_FILENO, STDOUT_FILENO, INT_MAX, SPLICE_F_NONBLOCK);
    splice(STDIN_FILENO, NULL, fd, NULL, len, SPLICE_F_MOVE);
    return 0;
}
EOF
if compile_prog "" "" ; then
  splice=yes
fi

##########################################
# signalfd probe
signalfd="no"
cat > $TMPC << EOF
#define _GNU_SOURCE
#include <unistd.h>
#include <sys/syscall.h>
#include <signal.h>
int main(void) { return syscall(SYS_signalfd, -1, NULL, _NSIG / 8); }
EOF

if compile_prog "" "" ; then
  signalfd=yes
elif test "$kvm" = "yes" -a "$io_thread" != "yes"; then
  echo
  echo "ERROR: Host kernel lacks signalfd() support,"
  echo "but KVM depends on it when the IO thread is disabled."
  echo
  exit 1
fi

# check if eventfd is supported
eventfd=no
cat > $TMPC << EOF
#include <sys/eventfd.h>

int main(void)
{
    int efd = eventfd(0, 0);
    return 0;
}
EOF
if compile_prog "" "" ; then
  eventfd=yes
fi

# check for fallocate
fallocate=no
cat > $TMPC << EOF
#include <fcntl.h>

int main(void)
{
    fallocate(0, 0, 0, 0);
    return 0;
}
EOF
if compile_prog "$ARCH_CFLAGS" "" ; then
  fallocate=yes
fi

# check for sync_file_range
sync_file_range=no
cat > $TMPC << EOF
#include <fcntl.h>

int main(void)
{
    sync_file_range(0, 0, 0, 0);
    return 0;
}
EOF
if compile_prog "$ARCH_CFLAGS" "" ; then
  sync_file_range=yes
fi

# check for linux/fiemap.h and FS_IOC_FIEMAP
fiemap=no
cat > $TMPC << EOF
#include <sys/ioctl.h>
#include <linux/fs.h>
#include <linux/fiemap.h>

int main(void)
{
    ioctl(0, FS_IOC_FIEMAP, 0);
    return 0;
}
EOF
if compile_prog "$ARCH_CFLAGS" "" ; then
  fiemap=yes
fi

# check for dup3
dup3=no
cat > $TMPC << EOF
#include <unistd.h>

int main(void)
{
    dup3(0, 0, 0);
    return 0;
}
EOF
if compile_prog "" "" ; then
  dup3=yes
fi

# check for epoll support
epoll=no
cat > $TMPC << EOF
#include <sys/epoll.h>

int main(void)
{
    epoll_create(0);
    return 0;
}
EOF
if compile_prog "$ARCH_CFLAGS" "" ; then
  epoll=yes
fi

# epoll_create1 and epoll_pwait are later additions
# so we must check separately for their presence
epoll_create1=no
cat > $TMPC << EOF
#include <sys/epoll.h>

int main(void)
{
    /* Note that we use epoll_create1 as a value, not as
     * a function being called. This is necessary so that on
     * old SPARC glibc versions where the function was present in
     * the library but not declared in the header file we will
     * fail the configure check. (Otherwise we will get a compiler
     * warning but not an error, and will proceed to fail the
     * qemu compile where we compile with -Werror.)
     */
    epoll_create1;
    return 0;
}
EOF
if compile_prog "$ARCH_CFLAGS" "" ; then
  epoll_create1=yes
fi

epoll_pwait=no
cat > $TMPC << EOF
#include <sys/epoll.h>

int main(void)
{
    epoll_pwait(0, 0, 0, 0, 0);
    return 0;
}
EOF
if compile_prog "$ARCH_CFLAGS" "" ; then
  epoll_pwait=yes
fi

# Check if tools are available to build documentation.
if test "$docs" != "no" ; then
  if has makeinfo && has pod2man; then
    docs=yes
  else
    if test "$docs" = "yes" ; then
      feature_not_found "docs"
    fi
    docs=no
  fi
fi

# Search for bswap_32 function
byteswap_h=no
cat > $TMPC << EOF
#include <byteswap.h>
int main(void) { return bswap_32(0); }
EOF
if compile_prog "" "" ; then
  byteswap_h=yes
fi

# Search for bswap_32 function
bswap_h=no
cat > $TMPC << EOF
#include <sys/endian.h>
#include <sys/types.h>
#include <machine/bswap.h>
int main(void) { return bswap32(0); }
EOF
if compile_prog "" "" ; then
  bswap_h=yes
fi

##########################################
# Do we need librt
cat > $TMPC <<EOF
#include <signal.h>
#include <time.h>
int main(void) { clockid_t id; return clock_gettime(id, NULL); }
EOF

if compile_prog "" "" ; then
  :
elif compile_prog "" "-lrt" ; then
  LIBS="-lrt $LIBS"
fi

if test "$darwin" != "yes" -a "$mingw32" != "yes" -a "$solaris" != yes -a \
        "$aix" != "yes" -a "$haiku" != "yes" ; then
    libs_softmmu="-lutil $libs_softmmu"
fi

##########################################
# check if the compiler defines offsetof

need_offsetof=yes
cat > $TMPC << EOF
#include <stddef.h>
int main(void) { struct s { int f; }; return offsetof(struct s, f); }
EOF
if compile_prog "" "" ; then
    need_offsetof=no
fi

##########################################
# check if the compiler understands attribute warn_unused_result
#
# This could be smarter, but gcc -Werror does not error out even when warning
# about attribute warn_unused_result

gcc_attribute_warn_unused_result=no
cat > $TMPC << EOF
#if defined(__GNUC__) && (__GNUC__ < 4) && defined(__GNUC_MINOR__) && (__GNUC__ < 4)
#error gcc 3.3 or older
#endif
int main(void) { return 0;}
EOF
if compile_prog "" ""; then
    gcc_attribute_warn_unused_result=yes
fi

# spice probe
if test "$spice" != "no" ; then
  cat > $TMPC << EOF
#include <spice.h>
int main(void) { spice_server_new(); return 0; }
EOF
  spice_cflags=$($pkg_config --cflags spice-protocol spice-server 2>/dev/null)
  spice_libs=$($pkg_config --libs spice-protocol spice-server 2>/dev/null)
  if $pkg_config --atleast-version=0.5.3 spice-server >/dev/null 2>&1 && \
     compile_prog "$spice_cflags" "$spice_libs" ; then
    spice="yes"
    libs_softmmu="$libs_softmmu $spice_libs"
    QEMU_CFLAGS="$QEMU_CFLAGS $spice_cflags"
  else
    if test "$spice" = "yes" ; then
      feature_not_found "spice"
    fi
    spice="no"
  fi
fi

# check for libcacard for smartcard support
if test "$smartcard" != "no" ; then
    smartcard="yes"
    smartcard_cflags=""
    # TODO - what's the minimal nss version we support?
    if test "$smartcard_nss" != "no"; then
        if $pkg_config --atleast-version=3.12.8 nss >/dev/null 2>&1 ; then
            smartcard_nss="yes"
            smartcard_cflags="-I\$(SRC_PATH)/libcacard"
            libcacard_libs=$($pkg_config --libs nss 2>/dev/null)
            libcacard_cflags=$($pkg_config --cflags nss 2>/dev/null)
            QEMU_CFLAGS="$QEMU_CFLAGS $smartcard_cflags $libcacard_cflags"
            LIBS="$libcacard_libs $LIBS"
        else
            if test "$smartcard_nss" = "yes"; then
                feature_not_found "nss"
            fi
            smartcard_nss="no"
        fi
    fi
fi
if test "$smartcard" = "no" ; then
    smartcard_nss="no"
fi

##########################################

##########################################
# check if we have fdatasync

fdatasync=no
cat > $TMPC << EOF
#include <unistd.h>
int main(void) { return fdatasync(0); }
EOF
if compile_prog "" "" ; then
    fdatasync=yes
fi

##########################################
# check if we have madvise

madvise=no
cat > $TMPC << EOF
#include <sys/types.h>
#include <sys/mman.h>
#include <stddef.h>
int main(void) { return madvise(NULL, 0, MADV_DONTNEED); }
EOF
if compile_prog "" "" ; then
    madvise=yes
fi

##########################################
# check if we have posix_madvise

posix_madvise=no
cat > $TMPC << EOF
#include <sys/mman.h>
#include <stddef.h>
int main(void) { return posix_madvise(NULL, 0, POSIX_MADV_DONTNEED); }
EOF
if compile_prog "" "" ; then
    posix_madvise=yes
fi

##########################################
# check if trace backend exists

sh "$source_path/scripts/tracetool" "--$trace_backend" --check-backend > /dev/null 2> /dev/null
if test "$?" -ne 0 ; then
  echo
  echo "Error: invalid trace backend"
  echo "Please choose a supported trace backend."
  echo
  exit 1
fi

##########################################
# For 'ust' backend, test if ust headers are present
if test "$trace_backend" = "ust"; then
  cat > $TMPC << EOF
#include <ust/tracepoint.h>
#include <ust/marker.h>
int main(void) { return 0; }
EOF
  if compile_prog "" "" ; then
    LIBS="-lust $LIBS"
  else
    echo
    echo "Error: Trace backend 'ust' missing libust header files"
    echo
    exit 1
  fi
fi

##########################################
# For 'dtrace' backend, test if 'dtrace' command is present
if test "$trace_backend" = "dtrace"; then
  if ! has 'dtrace' ; then
    echo
    echo "Error: dtrace command is not found in PATH $PATH"
    echo
    exit 1
  fi
  trace_backend_stap="no"
  if has 'stap' ; then
    trace_backend_stap="yes"
  fi
fi

##########################################
# End of CC checks
# After here, no more $cc or $ld runs

if test "$debug" = "no" ; then
  CFLAGS="-O2 $CFLAGS"
fi

# Consult white-list to determine whether to enable werror
# by default.  Only enable by default for git builds
z_version=`cut -f3 -d. $source_path/VERSION`

if test -z "$werror" ; then
    if test "$z_version" = "50" -a \
        "$linux" = "yes" ; then
        werror="yes"
    else
        werror="no"
    fi
fi

# Disable zero malloc errors for official releases unless explicitly told to
# enable/disable
if test -z "$zero_malloc" ; then
    if test "$z_version" = "50" ; then
	zero_malloc="no"
    else
	zero_malloc="yes"
    fi
fi

if test "$werror" = "yes" ; then
    QEMU_CFLAGS="-Werror $QEMU_CFLAGS"
fi

if test "$solaris" = "no" ; then
    if $ld --version 2>/dev/null | grep "GNU ld" >/dev/null 2>/dev/null ; then
        LDFLAGS="-Wl,--warn-common $LDFLAGS"
    fi
fi

# Use ASLR, no-SEH and DEP if available
if test "$mingw32" = "yes" ; then
    for flag in --dynamicbase --no-seh --nxcompat; do
        if $ld --help 2>/dev/null | grep ".$flag" >/dev/null 2>/dev/null ; then
            LDFLAGS="-Wl,$flag $LDFLAGS"
        fi
    done
fi

confdir=$sysconfdir$confsuffix

tools=
if test "$softmmu" = yes ; then
  tools="qemu-img\$(EXESUF) qemu-io\$(EXESUF) $tools"
  if [ "$linux" = "yes" -o "$bsd" = "yes" -o "$solaris" = "yes" ] ; then
      tools="qemu-nbd\$(EXESUF) $tools"
    if [ "$check_utests" = "yes" ]; then
      tools="check-qint check-qstring check-qdict check-qlist $tools"
      tools="check-qfloat check-qjson $tools"
    fi
  fi
fi

# Mac OS X ships with a broken assembler
roms=
if test \( "$cpu" = "i386" -o "$cpu" = "x86_64" \) -a \
        "$targetos" != "Darwin" -a "$targetos" != "SunOS" -a \
        "$softmmu" = yes ; then
  roms="optionrom"
fi
if test "$cpu" = "ppc64" -a "$targetos" != "Darwin" ; then
  roms="$roms spapr-rtas"
fi

echo "Install prefix    $prefix"
echo "BIOS directory    `eval echo $datadir`"
echo "binary directory  `eval echo $bindir`"
echo "config directory  `eval echo $sysconfdir`"
if test "$mingw32" = "no" ; then
echo "Manual directory  `eval echo $mandir`"
echo "ELF interp prefix $interp_prefix"
fi
echo "Source path       $source_path"
echo "C compiler        $cc"
echo "Host C compiler   $host_cc"
echo "CFLAGS            $CFLAGS"
echo "QEMU_CFLAGS       $QEMU_CFLAGS"
echo "LDFLAGS           $LDFLAGS"
echo "make              $make"
echo "install           $install"
echo "host CPU          $cpu"
echo "host big endian   $bigendian"
echo "target list       $target_list"
echo "tcg debug enabled $debug_tcg"
echo "Mon debug enabled $debug_mon"
echo "gprof enabled     $gprof"
echo "sparse enabled    $sparse"
echo "strip binaries    $strip_opt"
echo "profiler          $profiler"
echo "static build      $static"
echo "-Werror enabled   $werror"
if test "$darwin" = "yes" ; then
    echo "Cocoa support     $cocoa"
fi
echo "SDL support       $sdl"
echo "curses support    $curses"
echo "curl support      $curl"
echo "check support     $check_utests"
echo "mingw32 support   $mingw32"
echo "Audio drivers     $audio_drv_list"
echo "Extra audio cards $audio_card_list"
echo "Block whitelist   $block_drv_whitelist"
echo "Mixer emulation   $mixemu"
echo "VNC support       $vnc"
if test "$vnc" = "yes" ; then
    echo "VNC TLS support   $vnc_tls"
    echo "VNC SASL support  $vnc_sasl"
    echo "VNC JPEG support  $vnc_jpeg"
    echo "VNC PNG support   $vnc_png"
    echo "VNC thread        $vnc_thread"
fi
if test -n "$sparc_cpu"; then
    echo "Target Sparc Arch $sparc_cpu"
fi
echo "xen support       $xen"
echo "brlapi support    $brlapi"
echo "bluez  support    $bluez"
echo "Documentation     $docs"
[ ! -z "$uname_release" ] && \
echo "uname -r          $uname_release"
echo "NPTL support      $nptl"
echo "GUEST_BASE        $guest_base"
echo "PIE user targets  $user_pie"
echo "vde support       $vde"
echo "IO thread         $io_thread"
echo "Linux AIO support $linux_aio"
echo "ATTR/XATTR support $attr"
echo "Install blobs     $blobs"
echo "KVM support       $kvm"
echo "fdt support       $fdt"
echo "preadv support    $preadv"
echo "fdatasync         $fdatasync"
echo "madvise           $madvise"
echo "posix_madvise     $posix_madvise"
echo "uuid support      $uuid"
echo "vhost-net support $vhost_net"
echo "Trace backend     $trace_backend"
echo "Trace output file $trace_file-<pid>"
echo "spice support     $spice"
echo "rbd support       $rbd"
echo "xfsctl support    $xfs"
echo "nss used          $smartcard_nss"
echo "OpenGL support    $opengl"

if test $sdl_too_old = "yes"; then
echo "-> Your SDL version is too old - please upgrade to have SDL support"
fi

config_host_mak="config-host.mak"
config_host_ld="config-host.ld"

echo "# Automatically generated by configure - do not modify" > $config_host_mak
printf "# Configured with:" >> $config_host_mak
printf " '%s'" "$0" "$@" >> $config_host_mak
echo >> $config_host_mak

echo all: >> $config_host_mak
echo "prefix=$prefix" >> $config_host_mak
echo "bindir=$bindir" >> $config_host_mak
echo "mandir=$mandir" >> $config_host_mak
echo "datadir=$datadir" >> $config_host_mak
echo "sysconfdir=$sysconfdir" >> $config_host_mak
echo "docdir=$docdir" >> $config_host_mak
echo "confdir=$confdir" >> $config_host_mak

case "$cpu" in
  i386|x86_64|alpha|cris|hppa|ia64|lm32|m68k|microblaze|mips|mips64|ppc|ppc64|s390|s390x|sparc|sparc64|unicore32)
    ARCH=$cpu
  ;;
  armv4b|armv4l)
    ARCH=arm
  ;;
esac
echo "ARCH=$ARCH" >> $config_host_mak
if test "$debug_tcg" = "yes" ; then
  echo "CONFIG_DEBUG_TCG=y" >> $config_host_mak
fi
if test "$debug_mon" = "yes" ; then
  echo "CONFIG_DEBUG_MONITOR=y" >> $config_host_mak
fi
if test "$debug" = "yes" ; then
  echo "CONFIG_DEBUG_EXEC=y" >> $config_host_mak
fi
if test "$strip_opt" = "yes" ; then
  echo "STRIP=${strip}" >> $config_host_mak
fi
if test "$bigendian" = "yes" ; then
  echo "HOST_WORDS_BIGENDIAN=y" >> $config_host_mak
fi
echo "HOST_LONG_BITS=$hostlongbits" >> $config_host_mak
if test "$mingw32" = "yes" ; then
  echo "CONFIG_WIN32=y" >> $config_host_mak
  rc_version=`cat $source_path/VERSION`
  version_major=${rc_version%%.*}
  rc_version=${rc_version#*.}
  version_minor=${rc_version%%.*}
  rc_version=${rc_version#*.}
  version_subminor=${rc_version%%.*}
  version_micro=0
  echo "CONFIG_FILEVERSION=$version_major,$version_minor,$version_subminor,$version_micro" >> $config_host_mak
  echo "CONFIG_PRODUCTVERSION=$version_major,$version_minor,$version_subminor,$version_micro" >> $config_host_mak
else
  echo "CONFIG_POSIX=y" >> $config_host_mak
fi

if test "$linux" = "yes" ; then
  echo "CONFIG_LINUX=y" >> $config_host_mak
fi

if test "$darwin" = "yes" ; then
  echo "CONFIG_DARWIN=y" >> $config_host_mak
fi

if test "$aix" = "yes" ; then
  echo "CONFIG_AIX=y" >> $config_host_mak
fi

if test "$solaris" = "yes" ; then
  echo "CONFIG_SOLARIS=y" >> $config_host_mak
  echo "CONFIG_SOLARIS_VERSION=$solarisrev" >> $config_host_mak
  if test "$needs_libsunmath" = "yes" ; then
    echo "CONFIG_NEEDS_LIBSUNMATH=y" >> $config_host_mak
  fi
fi
if test "$haiku" = "yes" ; then
  echo "CONFIG_HAIKU=y" >> $config_host_mak
fi
if test "$static" = "yes" ; then
  echo "CONFIG_STATIC=y" >> $config_host_mak
fi
if test $profiler = "yes" ; then
  echo "CONFIG_PROFILER=y" >> $config_host_mak
fi
if test "$slirp" = "yes" ; then
  echo "CONFIG_SLIRP=y" >> $config_host_mak
  QEMU_INCLUDES="-I\$(SRC_PATH)/slirp $QEMU_INCLUDES"
fi
if test "$vde" = "yes" ; then
  echo "CONFIG_VDE=y" >> $config_host_mak
fi
for card in $audio_card_list; do
    def=CONFIG_`echo $card | tr '[:lower:]' '[:upper:]'`
    echo "$def=y" >> $config_host_mak
done
echo "CONFIG_AUDIO_DRIVERS=$audio_drv_list" >> $config_host_mak
for drv in $audio_drv_list; do
    def=CONFIG_`echo $drv | tr '[:lower:]' '[:upper:]'`
    echo "$def=y" >> $config_host_mak
    if test "$drv" = "fmod"; then
        echo "FMOD_CFLAGS=-I$fmod_inc" >> $config_host_mak
    fi
done
if test "$audio_pt_int" = "yes" ; then
  echo "CONFIG_AUDIO_PT_INT=y" >> $config_host_mak
fi
if test "$audio_win_int" = "yes" ; then
  echo "CONFIG_AUDIO_WIN_INT=y" >> $config_host_mak
fi
echo "CONFIG_BDRV_WHITELIST=$block_drv_whitelist" >> $config_host_mak
if test "$mixemu" = "yes" ; then
  echo "CONFIG_MIXEMU=y" >> $config_host_mak
fi
if test "$vnc" = "yes" ; then
  echo "CONFIG_VNC=y" >> $config_host_mak
fi
if test "$vnc_tls" = "yes" ; then
  echo "CONFIG_VNC_TLS=y" >> $config_host_mak
  echo "VNC_TLS_CFLAGS=$vnc_tls_cflags" >> $config_host_mak
fi
if test "$vnc_sasl" = "yes" ; then
  echo "CONFIG_VNC_SASL=y" >> $config_host_mak
  echo "VNC_SASL_CFLAGS=$vnc_sasl_cflags" >> $config_host_mak
fi
if test "$vnc_jpeg" = "yes" ; then
  echo "CONFIG_VNC_JPEG=y" >> $config_host_mak
  echo "VNC_JPEG_CFLAGS=$vnc_jpeg_cflags" >> $config_host_mak
fi
if test "$vnc_png" = "yes" ; then
  echo "CONFIG_VNC_PNG=y" >> $config_host_mak
  echo "VNC_PNG_CFLAGS=$vnc_png_cflags" >> $config_host_mak
fi
if test "$vnc_thread" = "yes" ; then
  echo "CONFIG_VNC_THREAD=y" >> $config_host_mak
fi
if test "$fnmatch" = "yes" ; then
  echo "CONFIG_FNMATCH=y" >> $config_host_mak
fi
if test "$uuid" = "yes" ; then
  echo "CONFIG_UUID=y" >> $config_host_mak
fi
if test "$xfs" = "yes" ; then
  echo "CONFIG_XFS=y" >> $config_host_mak
fi
qemu_version=`head $source_path/VERSION`
echo "VERSION=$qemu_version" >>$config_host_mak
echo "PKGVERSION=$pkgversion" >>$config_host_mak
echo "SRC_PATH=$source_path" >> $config_host_mak
echo "TARGET_DIRS=$target_list" >> $config_host_mak
if [ "$docs" = "yes" ] ; then
  echo "BUILD_DOCS=yes" >> $config_host_mak
fi
if test "$sdl" = "yes" ; then
  echo "CONFIG_SDL=y" >> $config_host_mak
  echo "SDL_CFLAGS=$sdl_cflags" >> $config_host_mak
fi
if test "$cocoa" = "yes" ; then
  echo "CONFIG_COCOA=y" >> $config_host_mak
fi
if test "$curses" = "yes" ; then
  echo "CONFIG_CURSES=y" >> $config_host_mak
fi
if test "$atfile" = "yes" ; then
  echo "CONFIG_ATFILE=y" >> $config_host_mak
fi
if test "$utimens" = "yes" ; then
  echo "CONFIG_UTIMENSAT=y" >> $config_host_mak
fi
if test "$pipe2" = "yes" ; then
  echo "CONFIG_PIPE2=y" >> $config_host_mak
fi
if test "$accept4" = "yes" ; then
  echo "CONFIG_ACCEPT4=y" >> $config_host_mak
fi
if test "$splice" = "yes" ; then
  echo "CONFIG_SPLICE=y" >> $config_host_mak
fi
if test "$eventfd" = "yes" ; then
  echo "CONFIG_EVENTFD=y" >> $config_host_mak
fi
if test "$fallocate" = "yes" ; then
  echo "CONFIG_FALLOCATE=y" >> $config_host_mak
fi
if test "$sync_file_range" = "yes" ; then
  echo "CONFIG_SYNC_FILE_RANGE=y" >> $config_host_mak
fi
if test "$fiemap" = "yes" ; then
  echo "CONFIG_FIEMAP=y" >> $config_host_mak
fi
if test "$dup3" = "yes" ; then
  echo "CONFIG_DUP3=y" >> $config_host_mak
fi
if test "$epoll" = "yes" ; then
  echo "CONFIG_EPOLL=y" >> $config_host_mak
fi
if test "$epoll_create1" = "yes" ; then
  echo "CONFIG_EPOLL_CREATE1=y" >> $config_host_mak
fi
if test "$epoll_pwait" = "yes" ; then
  echo "CONFIG_EPOLL_PWAIT=y" >> $config_host_mak
fi
if test "$inotify" = "yes" ; then
  echo "CONFIG_INOTIFY=y" >> $config_host_mak
fi
if test "$inotify1" = "yes" ; then
  echo "CONFIG_INOTIFY1=y" >> $config_host_mak
fi
if test "$byteswap_h" = "yes" ; then
  echo "CONFIG_BYTESWAP_H=y" >> $config_host_mak
fi
if test "$bswap_h" = "yes" ; then
  echo "CONFIG_MACHINE_BSWAP_H=y" >> $config_host_mak
fi
if test "$curl" = "yes" ; then
  echo "CONFIG_CURL=y" >> $config_host_mak
  echo "CURL_CFLAGS=$curl_cflags" >> $config_host_mak
fi
if test "$brlapi" = "yes" ; then
  echo "CONFIG_BRLAPI=y" >> $config_host_mak
fi
if test "$bluez" = "yes" ; then
  echo "CONFIG_BLUEZ=y" >> $config_host_mak
  echo "BLUEZ_CFLAGS=$bluez_cflags" >> $config_host_mak
fi
if test "$xen" = "yes" ; then
  echo "CONFIG_XEN=y" >> $config_host_mak
  echo "CONFIG_XEN_CTRL_INTERFACE_VERSION=$xen_ctrl_version" >> $config_host_mak
fi
if test "$io_thread" = "yes" ; then
  echo "CONFIG_IOTHREAD=y" >> $config_host_mak
fi
if test "$linux_aio" = "yes" ; then
  echo "CONFIG_LINUX_AIO=y" >> $config_host_mak
fi
if test "$attr" = "yes" ; then
  echo "CONFIG_ATTR=y" >> $config_host_mak
fi
if test "$linux" = "yes" ; then
  if test "$attr" = "yes" ; then
    echo "CONFIG_VIRTFS=y" >> $config_host_mak
  fi
fi
if test "$blobs" = "yes" ; then
  echo "INSTALL_BLOBS=yes" >> $config_host_mak
fi
if test "$iovec" = "yes" ; then
  echo "CONFIG_IOVEC=y" >> $config_host_mak
fi
if test "$preadv" = "yes" ; then
  echo "CONFIG_PREADV=y" >> $config_host_mak
fi
if test "$fdt" = "yes" ; then
  echo "CONFIG_FDT=y" >> $config_host_mak
fi
if test "$signalfd" = "yes" ; then
  echo "CONFIG_SIGNALFD=y" >> $config_host_mak
fi
if test "$need_offsetof" = "yes" ; then
  echo "CONFIG_NEED_OFFSETOF=y" >> $config_host_mak
fi
if test "$gcc_attribute_warn_unused_result" = "yes" ; then
  echo "CONFIG_GCC_ATTRIBUTE_WARN_UNUSED_RESULT=y" >> $config_host_mak
fi
if test "$fdatasync" = "yes" ; then
  echo "CONFIG_FDATASYNC=y" >> $config_host_mak
fi
if test "$madvise" = "yes" ; then
  echo "CONFIG_MADVISE=y" >> $config_host_mak
fi
if test "$posix_madvise" = "yes" ; then
  echo "CONFIG_POSIX_MADVISE=y" >> $config_host_mak
fi

if test "$spice" = "yes" ; then
  echo "CONFIG_SPICE=y" >> $config_host_mak
fi

if test "$smartcard" = "yes" ; then
  echo "CONFIG_SMARTCARD=y" >> $config_host_mak
fi

if test "$smartcard_nss" = "yes" ; then
  echo "CONFIG_SMARTCARD_NSS=y" >> $config_host_mak
fi

if test "$opengl" = "yes" ; then
  echo "CONFIG_OPENGL=y" >> $config_host_mak
fi

# XXX: suppress that
if [ "$bsd" = "yes" ] ; then
  echo "CONFIG_BSD=y" >> $config_host_mak
fi

echo "CONFIG_UNAME_RELEASE=\"$uname_release\"" >> $config_host_mak

if test "$zero_malloc" = "yes" ; then
  echo "CONFIG_ZERO_MALLOC=y" >> $config_host_mak
fi
if test "$rbd" = "yes" ; then
  echo "CONFIG_RBD=y" >> $config_host_mak
fi

# USB host support
case "$usb" in
linux)
  echo "HOST_USB=linux" >> $config_host_mak
;;
bsd)
  echo "HOST_USB=bsd" >> $config_host_mak
;;
*)
  echo "HOST_USB=stub" >> $config_host_mak
;;
esac

echo "TRACE_BACKEND=$trace_backend" >> $config_host_mak
if test "$trace_backend" = "simple"; then
  echo "CONFIG_SIMPLE_TRACE=y" >> $config_host_mak
fi
# Set the appropriate trace file.
if test "$trace_backend" = "simple"; then
  trace_file="\"$trace_file-%u\""
fi
if test "$trace_backend" = "dtrace" -a "$trace_backend_stap" = "yes" ; then
  echo "CONFIG_SYSTEMTAP_TRACE=y" >> $config_host_mak
fi
echo "CONFIG_TRACE_FILE=$trace_file" >> $config_host_mak

echo "TOOLS=$tools" >> $config_host_mak
echo "ROMS=$roms" >> $config_host_mak
echo "MAKE=$make" >> $config_host_mak
echo "INSTALL=$install" >> $config_host_mak
echo "INSTALL_DIR=$install -d -m0755 -p" >> $config_host_mak
echo "INSTALL_DATA=$install -m0644 -p" >> $config_host_mak
echo "INSTALL_PROG=$install -m0755 -p" >> $config_host_mak
echo "CC=$cc" >> $config_host_mak
echo "CC_I386=$cc_i386" >> $config_host_mak
echo "HOST_CC=$host_cc" >> $config_host_mak
echo "AR=$ar" >> $config_host_mak
echo "OBJCOPY=$objcopy" >> $config_host_mak
echo "LD=$ld" >> $config_host_mak
echo "WINDRES=$windres" >> $config_host_mak
echo "CFLAGS=$CFLAGS" >> $config_host_mak
echo "QEMU_CFLAGS=$QEMU_CFLAGS" >> $config_host_mak
echo "QEMU_INCLUDES=$QEMU_INCLUDES" >> $config_host_mak
if test "$sparse" = "yes" ; then
  echo "CC           := REAL_CC=\"\$(CC)\" cgcc"       >> $config_host_mak
  echo "HOST_CC      := REAL_CC=\"\$(HOST_CC)\" cgcc"  >> $config_host_mak
  echo "QEMU_CFLAGS  += -Wbitwise -Wno-transparent-union -Wno-old-initializer -Wno-non-pointer-null" >> $config_host_mak
fi
echo "HELPER_CFLAGS=$helper_cflags" >> $config_host_mak
echo "LDFLAGS=$LDFLAGS" >> $config_host_mak
echo "ARLIBS_BEGIN=$arlibs_begin" >> $config_host_mak
echo "ARLIBS_END=$arlibs_end" >> $config_host_mak
echo "LIBS+=$LIBS" >> $config_host_mak
echo "LIBS_TOOLS+=$libs_tools" >> $config_host_mak
echo "EXESUF=$EXESUF" >> $config_host_mak

# generate list of library paths for linker script

$ld --verbose -v 2> /dev/null | grep SEARCH_DIR > ${config_host_ld}

if test -f ${config_host_ld}~ ; then
  if cmp -s $config_host_ld ${config_host_ld}~ ; then
    mv ${config_host_ld}~ $config_host_ld
  else
    rm ${config_host_ld}~
  fi
fi

for d in libdis libdis-user; do
    mkdir -p $d
    symlink $source_path/Makefile.dis $d/Makefile
    echo > $d/config.mak
done
if test "$static" = "no" -a "$user_pie" = "yes" ; then
  echo "QEMU_CFLAGS+=-fpie" > libdis-user/config.mak
fi

for target in $target_list; do
target_dir="$target"
config_target_mak=$target_dir/config-target.mak
target_arch2=`echo $target | cut -d '-' -f 1`
target_bigendian="no"

case "$target_arch2" in
  armeb|lm32|m68k|microblaze|mips|mipsn32|mips64|ppc|ppcemb|ppc64|ppc64abi32|s390x|sh4eb|sparc|sparc64|sparc32plus)
  target_bigendian=yes
  ;;
esac
target_softmmu="no"
target_user_only="no"
target_linux_user="no"
target_darwin_user="no"
target_bsd_user="no"
case "$target" in
  ${target_arch2}-softmmu)
    target_softmmu="yes"
    ;;
  ${target_arch2}-linux-user)
    if test "$linux" != "yes" ; then
      echo "ERROR: Target '$target' is only available on a Linux host"
      exit 1
    fi
    target_user_only="yes"
    target_linux_user="yes"
    ;;
  ${target_arch2}-darwin-user)
    if test "$darwin" != "yes" ; then
      echo "ERROR: Target '$target' is only available on a Darwin host"
      exit 1
    fi
    target_user_only="yes"
    target_darwin_user="yes"
    ;;
  ${target_arch2}-bsd-user)
    if test "$bsd" != "yes" ; then
      echo "ERROR: Target '$target' is only available on a BSD host"
      exit 1
    fi
    target_user_only="yes"
    target_bsd_user="yes"
    ;;
  *)
    echo "ERROR: Target '$target' not recognised"
    exit 1
    ;;
esac

mkdir -p $target_dir
mkdir -p $target_dir/fpu
mkdir -p $target_dir/tcg
mkdir -p $target_dir/ide
mkdir -p $target_dir/9pfs
if test "$target" = "arm-linux-user" -o "$target" = "armeb-linux-user" -o "$target" = "arm-bsd-user" -o "$target" = "armeb-bsd-user" ; then
  mkdir -p $target_dir/nwfpe
fi
symlink $source_path/Makefile.target $target_dir/Makefile


echo "# Automatically generated by configure - do not modify" > $config_target_mak

bflt="no"
target_nptl="no"
interp_prefix1=`echo "$interp_prefix" | sed "s/%M/$target_arch2/g"`
echo "CONFIG_QEMU_INTERP_PREFIX=\"$interp_prefix1\"" >> $config_target_mak
gdb_xml_files=""
target_short_alignment=2
target_int_alignment=4
target_long_alignment=4
target_llong_alignment=8
target_libs_softmmu=

TARGET_ARCH="$target_arch2"
TARGET_BASE_ARCH=""
TARGET_ABI_DIR=""

case "$target_arch2" in
  i386)
    target_phys_bits=64
  ;;
  x86_64)
    TARGET_BASE_ARCH=i386
    target_phys_bits=64
    target_long_alignment=8
  ;;
  alpha)
    target_phys_bits=64
    target_long_alignment=8
    target_nptl="yes"
  ;;
  arm|armeb)
    TARGET_ARCH=arm
    bflt="yes"
    target_nptl="yes"
    gdb_xml_files="arm-core.xml arm-vfp.xml arm-vfp3.xml arm-neon.xml"
    target_phys_bits=32
    target_llong_alignment=4
  ;;
  cris)
    target_nptl="yes"
    target_phys_bits=32
  ;;
  lm32)
    target_phys_bits=32
    target_libs_softmmu="$opengl_libs"
  ;;
  m68k)
    bflt="yes"
    gdb_xml_files="cf-core.xml cf-fp.xml"
    target_phys_bits=32
    target_int_alignment=2
    target_long_alignment=2
    target_llong_alignment=2
  ;;
  microblaze|microblazeel)
    TARGET_ARCH=microblaze
    bflt="yes"
    target_nptl="yes"
    target_phys_bits=32
    target_libs_softmmu="$fdt_libs"
  ;;
  mips|mipsel)
    TARGET_ARCH=mips
    echo "TARGET_ABI_MIPSO32=y" >> $config_target_mak
    target_nptl="yes"
    target_phys_bits=64
  ;;
  mipsn32|mipsn32el)
    TARGET_ARCH=mipsn32
    TARGET_BASE_ARCH=mips
    echo "TARGET_ABI_MIPSN32=y" >> $config_target_mak
    target_phys_bits=64
  ;;
  mips64|mips64el)
    TARGET_ARCH=mips64
    TARGET_BASE_ARCH=mips
    echo "TARGET_ABI_MIPSN64=y" >> $config_target_mak
    target_phys_bits=64
    target_long_alignment=8
  ;;
  ppc)
    gdb_xml_files="power-core.xml power-fpu.xml power-altivec.xml power-spe.xml"
    target_phys_bits=32
    target_nptl="yes"
    target_libs_softmmu="$fdt_libs"
  ;;
  ppcemb)
    TARGET_BASE_ARCH=ppc
    TARGET_ABI_DIR=ppc
    gdb_xml_files="power-core.xml power-fpu.xml power-altivec.xml power-spe.xml"
    target_phys_bits=64
    target_nptl="yes"
    target_libs_softmmu="$fdt_libs"
  ;;
  ppc64)
    TARGET_BASE_ARCH=ppc
    TARGET_ABI_DIR=ppc
    gdb_xml_files="power64-core.xml power-fpu.xml power-altivec.xml power-spe.xml"
    target_phys_bits=64
    target_long_alignment=8
    target_libs_softmmu="$fdt_libs"
  ;;
  ppc64abi32)
    TARGET_ARCH=ppc64
    TARGET_BASE_ARCH=ppc
    TARGET_ABI_DIR=ppc
    echo "TARGET_ABI32=y" >> $config_target_mak
    gdb_xml_files="power64-core.xml power-fpu.xml power-altivec.xml power-spe.xml"
    target_phys_bits=64
    target_libs_softmmu="$fdt_libs"
  ;;
  sh4|sh4eb)
    TARGET_ARCH=sh4
    bflt="yes"
    target_nptl="yes"
    target_phys_bits=32
  ;;
  sparc)
    target_phys_bits=64
  ;;
  sparc64)
    TARGET_BASE_ARCH=sparc
    target_phys_bits=64
    target_long_alignment=8
  ;;
  sparc32plus)
    TARGET_ARCH=sparc64
    TARGET_BASE_ARCH=sparc
    TARGET_ABI_DIR=sparc
    echo "TARGET_ABI32=y" >> $config_target_mak
    target_phys_bits=64
  ;;
  s390x)
    target_nptl="yes"
    target_phys_bits=64
    target_long_alignment=8
  ;;
  unicore32)
    target_phys_bits=32
  ;;
  *)
    echo "Unsupported target CPU"
    exit 1
  ;;
esac
echo "TARGET_SHORT_ALIGNMENT=$target_short_alignment" >> $config_target_mak
echo "TARGET_INT_ALIGNMENT=$target_int_alignment" >> $config_target_mak
echo "TARGET_LONG_ALIGNMENT=$target_long_alignment" >> $config_target_mak
echo "TARGET_LLONG_ALIGNMENT=$target_llong_alignment" >> $config_target_mak
echo "TARGET_ARCH=$TARGET_ARCH" >> $config_target_mak
target_arch_name="`echo $TARGET_ARCH | tr '[:lower:]' '[:upper:]'`"
echo "TARGET_$target_arch_name=y" >> $config_target_mak
echo "TARGET_ARCH2=$target_arch2" >> $config_target_mak
# TARGET_BASE_ARCH needs to be defined after TARGET_ARCH
if [ "$TARGET_BASE_ARCH" = "" ]; then
  TARGET_BASE_ARCH=$TARGET_ARCH
fi
echo "TARGET_BASE_ARCH=$TARGET_BASE_ARCH" >> $config_target_mak
if [ "$TARGET_ABI_DIR" = "" ]; then
  TARGET_ABI_DIR=$TARGET_ARCH
fi
echo "TARGET_ABI_DIR=$TARGET_ABI_DIR" >> $config_target_mak
case "$target_arch2" in
  i386|x86_64)
    if test "$xen" = "yes" -a "$target_softmmu" = "yes" ; then
      target_phys_bits=64
      echo "CONFIG_XEN=y" >> $config_target_mak
      if test "$cpu" = "i386" -o "$cpu" = "x86_64"; then
          echo "CONFIG_XEN_MAPCACHE=y" >> $config_target_mak
      fi
    fi
esac
case "$target_arch2" in
  i386|x86_64|ppcemb|ppc|ppc64|s390x)
    # Make sure the target and host cpus are compatible
    if test "$kvm" = "yes" -a "$target_softmmu" = "yes" -a \
      \( "$target_arch2" = "$cpu" -o \
      \( "$target_arch2" = "ppcemb" -a "$cpu" = "ppc" \) -o \
      \( "$target_arch2" = "ppc64"  -a "$cpu" = "ppc" \) -o \
      \( "$target_arch2" = "ppc"    -a "$cpu" = "ppc64" \) -o \
      \( "$target_arch2" = "ppcemb" -a "$cpu" = "ppc64" \) -o \
      \( "$target_arch2" = "x86_64" -a "$cpu" = "i386"   \) -o \
      \( "$target_arch2" = "i386"   -a "$cpu" = "x86_64" \) \) ; then
      echo "CONFIG_KVM=y" >> $config_target_mak
      echo "KVM_CFLAGS=$kvm_cflags" >> $config_target_mak
      if test "$kvm_para" = "yes"; then
        echo "CONFIG_KVM_PARA=y" >> $config_target_mak
      fi
      if test $vhost_net = "yes" ; then
        echo "CONFIG_VHOST_NET=y" >> $config_target_mak
      fi
      if test "$kvm_ppc_pvr" = "yes" ; then
        echo "CONFIG_KVM_PPC_PVR=y" >> $config_target_mak
      fi
    fi
esac
if test "$target_bigendian" = "yes" ; then
  echo "TARGET_WORDS_BIGENDIAN=y" >> $config_target_mak
fi
if test "$target_softmmu" = "yes" ; then
  echo "TARGET_PHYS_ADDR_BITS=$target_phys_bits" >> $config_target_mak
  echo "CONFIG_SOFTMMU=y" >> $config_target_mak
  echo "LIBS+=$libs_softmmu $target_libs_softmmu" >> $config_target_mak
  echo "HWDIR=../libhw$target_phys_bits" >> $config_target_mak
  echo "subdir-$target: subdir-libhw$target_phys_bits" >> $config_host_mak
fi
if test "$target_user_only" = "yes" ; then
  echo "CONFIG_USER_ONLY=y" >> $config_target_mak
fi
if test "$target_linux_user" = "yes" ; then
  echo "CONFIG_LINUX_USER=y" >> $config_target_mak
fi
if test "$target_darwin_user" = "yes" ; then
  echo "CONFIG_DARWIN_USER=y" >> $config_target_mak
fi
if test "$smartcard_nss" = "yes" ; then
  echo "subdir-$target: subdir-libcacard" >> $config_host_mak
  echo "libcacard_libs=$libcacard_libs" >> $config_host_mak
  echo "libcacard_cflags=$libcacard_cflags" >> $config_host_mak
fi
list=""
if test ! -z "$gdb_xml_files" ; then
  for x in $gdb_xml_files; do
    list="$list $source_path/gdb-xml/$x"
  done
  echo "TARGET_XML_FILES=$list" >> $config_target_mak
fi

echo "CONFIG_SOFTFLOAT=y" >> $config_target_mak

if test "$target_user_only" = "yes" -a "$bflt" = "yes"; then
  echo "TARGET_HAS_BFLT=y" >> $config_target_mak
fi
if test "$target_user_only" = "yes" \
        -a "$nptl" = "yes" -a "$target_nptl" = "yes"; then
  echo "CONFIG_USE_NPTL=y" >> $config_target_mak
fi
if test "$target_user_only" = "yes" -a "$guest_base" = "yes"; then
  echo "CONFIG_USE_GUEST_BASE=y" >> $config_target_mak
fi
if test "$target_bsd_user" = "yes" ; then
  echo "CONFIG_BSD_USER=y" >> $config_target_mak
fi

# generate QEMU_CFLAGS/LDFLAGS for targets

cflags=""
includes=""
ldflags=""

if test "$ARCH" = "sparc64" ; then
  includes="-I\$(SRC_PATH)/tcg/sparc $includes"
elif test "$ARCH" = "s390x" ; then
  includes="-I\$(SRC_PATH)/tcg/s390 $includes"
elif test "$ARCH" = "x86_64" ; then
  includes="-I\$(SRC_PATH)/tcg/i386 $includes"
else
  includes="-I\$(SRC_PATH)/tcg/\$(ARCH) $includes"
fi
includes="-I\$(SRC_PATH)/tcg $includes"
includes="-I\$(SRC_PATH)/fpu $includes"

if test "$target_user_only" = "yes" ; then
    libdis_config_mak=libdis-user/config.mak
else
    libdis_config_mak=libdis/config.mak
fi

for i in $ARCH $TARGET_BASE_ARCH ; do
  case "$i" in
  alpha)
    echo "CONFIG_ALPHA_DIS=y"  >> $config_target_mak
    echo "CONFIG_ALPHA_DIS=y"  >> $libdis_config_mak
  ;;
  arm)
    echo "CONFIG_ARM_DIS=y"  >> $config_target_mak
    echo "CONFIG_ARM_DIS=y"  >> $libdis_config_mak
  ;;
  cris)
    echo "CONFIG_CRIS_DIS=y"  >> $config_target_mak
    echo "CONFIG_CRIS_DIS=y"  >> $libdis_config_mak
  ;;
  hppa)
    echo "CONFIG_HPPA_DIS=y"  >> $config_target_mak
    echo "CONFIG_HPPA_DIS=y"  >> $libdis_config_mak
  ;;
  i386|x86_64)
    echo "CONFIG_I386_DIS=y"  >> $config_target_mak
    echo "CONFIG_I386_DIS=y"  >> $libdis_config_mak
  ;;
  ia64*)
    echo "CONFIG_IA64_DIS=y"  >> $config_target_mak
    echo "CONFIG_IA64_DIS=y"  >> $libdis_config_mak
  ;;
  m68k)
    echo "CONFIG_M68K_DIS=y"  >> $config_target_mak
    echo "CONFIG_M68K_DIS=y"  >> $libdis_config_mak
  ;;
  microblaze*)
    echo "CONFIG_MICROBLAZE_DIS=y"  >> $config_target_mak
    echo "CONFIG_MICROBLAZE_DIS=y"  >> $libdis_config_mak
  ;;
  mips*)
    echo "CONFIG_MIPS_DIS=y"  >> $config_target_mak
    echo "CONFIG_MIPS_DIS=y"  >> $libdis_config_mak
  ;;
  ppc*)
    echo "CONFIG_PPC_DIS=y"  >> $config_target_mak
    echo "CONFIG_PPC_DIS=y"  >> $libdis_config_mak
  ;;
  s390*)
    echo "CONFIG_S390_DIS=y"  >> $config_target_mak
    echo "CONFIG_S390_DIS=y"  >> $libdis_config_mak
  ;;
  sh4)
    echo "CONFIG_SH4_DIS=y"  >> $config_target_mak
    echo "CONFIG_SH4_DIS=y"  >> $libdis_config_mak
  ;;
  sparc*)
    echo "CONFIG_SPARC_DIS=y"  >> $config_target_mak
    echo "CONFIG_SPARC_DIS=y"  >> $libdis_config_mak
  ;;
  esac
done

case "$ARCH" in
alpha)
  # Ensure there's only a single GP
  cflags="-msmall-data $cflags"
;;
esac

if test "$target_softmmu" = "yes" ; then
  case "$TARGET_BASE_ARCH" in
  arm)
    cflags="-DHAS_AUDIO $cflags"
  ;;
  lm32)
    cflags="-DHAS_AUDIO $cflags"
  ;;
  i386|mips|ppc)
    cflags="-DHAS_AUDIO -DHAS_AUDIO_CHOICE $cflags"
  ;;
  esac
fi

if test "$target_user_only" = "yes" -a "$static" = "no" -a \
	"$user_pie" = "yes" ; then
  cflags="-fpie $cflags"
  ldflags="-pie $ldflags"
fi

if test "$target_softmmu" = "yes" -a \( \
        "$TARGET_ARCH" = "microblaze" -o \
        "$TARGET_ARCH" = "cris" \) ; then
  echo "CONFIG_NEED_MMU=y" >> $config_target_mak
fi

if test "$gprof" = "yes" ; then
  echo "TARGET_GPROF=yes" >> $config_target_mak
  if test "$target_linux_user" = "yes" ; then
    cflags="-p $cflags"
    ldflags="-p $ldflags"
  fi
  if test "$target_softmmu" = "yes" ; then
    ldflags="-p $ldflags"
    echo "GPROF_CFLAGS=-p" >> $config_target_mak
  fi
fi

linker_script="-Wl,-T../config-host.ld -Wl,-T,\$(SRC_PATH)/\$(ARCH).ld"
if test "$target_linux_user" = "yes" -o "$target_bsd_user" = "yes" ; then
  case "$ARCH" in
  sparc)
    # -static is used to avoid g1/g3 usage by the dynamic linker
    ldflags="$linker_script -static $ldflags"
    ;;
  alpha | s390x)
    # The default placement of the application is fine.
    ;;
  *)
    ldflags="$linker_script $ldflags"
    ;;
  esac
fi

echo "LDFLAGS+=$ldflags" >> $config_target_mak
echo "QEMU_CFLAGS+=$cflags" >> $config_target_mak
echo "QEMU_INCLUDES+=$includes" >> $config_target_mak

done # for target in $targets

# build tree in object directory in case the source is not in the current directory
DIRS="tests tests/cris slirp audio block net pc-bios/optionrom"
DIRS="$DIRS pc-bios/spapr-rtas"
DIRS="$DIRS roms/seabios roms/vgabios"
DIRS="$DIRS fsdev ui"
FILES="Makefile tests/Makefile"
FILES="$FILES tests/cris/Makefile tests/cris/.gdbinit"
FILES="$FILES pc-bios/optionrom/Makefile pc-bios/keymaps"
FILES="$FILES pc-bios/spapr-rtas/Makefile"
FILES="$FILES roms/seabios/Makefile roms/vgabios/Makefile"
for bios_file in $source_path/pc-bios/*.bin $source_path/pc-bios/*.rom $source_path/pc-bios/*.dtb $source_path/pc-bios/openbios-*; do
    FILES="$FILES pc-bios/`basename $bios_file`"
done
mkdir -p $DIRS
for f in $FILES ; do
    test -e $f || symlink $source_path/$f $f
done

# temporary config to build submodules
for rom in seabios vgabios ; do
    config_mak=roms/$rom/config.mak
    echo "# Automatically generated by configure - do not modify" > $config_mak
    echo "SRC_PATH=$source_path/roms/$rom" >> $config_mak
    echo "CC=$cc" >> $config_mak
    echo "BCC=bcc" >> $config_mak
    echo "CPP=${cross_prefix}cpp" >> $config_mak
    echo "OBJCOPY=objcopy" >> $config_mak
    echo "IASL=iasl" >> $config_mak
    echo "LD=$ld" >> $config_mak
done

for hwlib in 32 64; do
  d=libhw$hwlib
  mkdir -p $d
  mkdir -p $d/ide
  symlink $source_path/Makefile.hw $d/Makefile
  mkdir -p $d/9pfs
  echo "QEMU_CFLAGS+=-DTARGET_PHYS_ADDR_BITS=$hwlib" > $d/config.mak
done

if [ "$source_path" != `pwd` ]; then
    # out of tree build
    mkdir -p libcacard
    rm -f libcacard/Makefile
    ln -s "$source_path/libcacard/Makefile" libcacard/Makefile
fi

d=libuser
mkdir -p $d
symlink $source_path/Makefile.user $d/Makefile
if test "$static" = "no" -a "$user_pie" = "yes" ; then
  echo "QEMU_CFLAGS+=-fpie" > $d/config.mak
fi

if test "$docs" = "yes" ; then
  mkdir -p QMP
fi
