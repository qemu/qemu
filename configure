#!/bin/sh
#
# qemu configure script (c) 2003 Fabrice Bellard
#

# Unset some variables known to interfere with behavior of common tools,
# just as autoconf does.  Unlike autoconf, we assume that unset exists.
unset CLICOLOR_FORCE GREP_OPTIONS BASH_ENV ENV MAIL MAILPATH CDPATH

# Don't allow CCACHE, if present, to use cached results of compile tests!
export CCACHE_RECACHE=yes

# make source path absolute
source_path=$(cd "$(dirname -- "$0")"; pwd)

if test "$PWD" -ef "$source_path"
then
    echo "Using './build' as the directory for build output"

    MARKER=build/auto-created-by-configure

    if test -e build
    then
        if test -f $MARKER
        then
           rm -rf build
        else
            echo "ERROR: ./build dir already exists and was not previously created by configure"
            exit 1
        fi
    fi

    if ! mkdir build || ! touch $MARKER
    then
        echo "ERROR: Could not create ./build directory. Check the permissions on"
        echo "your source directory, or try doing an out-of-tree build."
        exit 1
    fi

    cat > GNUmakefile <<'EOF'
# This file is auto-generated by configure to support in-source tree
# 'make' command invocation

build:
	@echo 'changing dir to build for $(MAKE) "$(MAKECMDGOALS)"...'
	@$(MAKE) -C build -f Makefile $(MAKECMDGOALS)
	@if test "$(MAKECMDGOALS)" = "distclean" && \
	    test -e build/auto-created-by-configure ; \
	then \
	    rm -rf build GNUmakefile ; \
	fi
%: build
	@
.PHONY: build
GNUmakefile: ;

EOF
    cd build
    exec "$source_path/configure" "$@"
fi

# Temporary directory used for files created while
# configure runs. Since it is in the build directory
# we can safely blow away any previous version of it
# (and we need not jump through hoops to try to delete
# it when configure exits.)
TMPDIR1="config-temp"
rm -rf "${TMPDIR1}"
if ! mkdir -p "${TMPDIR1}"; then
    echo "ERROR: failed to create temporary directory"
    exit 1
fi

TMPB="qemu-conf"
TMPC="${TMPDIR1}/${TMPB}.c"
TMPO="${TMPDIR1}/${TMPB}.o"
TMPE="${TMPDIR1}/${TMPB}.exe"

rm -f config.log

# Print a helpful header at the top of config.log
echo "# QEMU configure log $(date)" >> config.log
printf "# Configured with:" >> config.log
# repeat the invocation to log and stdout for CI
invoke=$(printf " '%s'" "$0" "$@")
test -n "$GITLAB_CI" && echo "configuring with: $invoke"
{ echo "$invoke"; echo; echo "#"; } >> config.log

quote_sh() {
    printf "%s" "$1" | sed "s,','\\\\'',g; s,.*,'&',"
}

error_exit() {
    (echo
    echo "ERROR: $1"
    while test -n "$2"; do
        echo "       $2"
        shift
    done
    echo) >&2
    exit 1
}

do_compiler() {
  # Run the compiler, capturing its output to the log. First argument
  # is compiler binary to execute.
  compiler="$1"
  shift
  if test -n "$BASH_VERSION"; then eval '
      echo >>config.log "
funcs: ${FUNCNAME[*]}
lines: ${BASH_LINENO[*]}"
  '; fi
  echo $compiler "$@" >> config.log
  $compiler "$@" >> config.log 2>&1 || return $?
}

do_cc() {
    do_compiler "$cc" $CPU_CFLAGS "$@"
}

compile_object() {
  local_cflags="$1"
  do_cc $CFLAGS $EXTRA_CFLAGS $local_cflags -c -o $TMPO $TMPC
}

compile_prog() {
  local_cflags="$1"
  local_ldflags="$2"
  do_cc $CFLAGS $EXTRA_CFLAGS $local_cflags -o $TMPE $TMPC \
      $LDFLAGS $EXTRA_LDFLAGS $local_ldflags
}

# symbolically link $1 to $2.  Portable version of "ln -sf".
symlink() {
  rm -rf "$2"
  mkdir -p "$(dirname "$2")"
  ln -s "$1" "$2"
}

# check whether a command is available to this shell (may be either an
# executable or a builtin)
has() {
    type "$1" >/dev/null 2>&1
}

version_ge () {
    local_ver1=$(expr "$1" : '\([0-9.]*\)' | tr . ' ')
    local_ver2=$(echo "$2" | tr . ' ')
    while true; do
        set x $local_ver1
        local_first=${2-0}
        # 'shift 2' if $2 is set, or 'shift' if $2 is not set
        shift ${2:+2}
        local_ver1=$*
        set x $local_ver2
        # the second argument finished, the first must be greater or equal
        test $# = 1 && return 0
        test $local_first -lt $2 && return 1
        test $local_first -gt $2 && return 0
        shift ${2:+2}
        local_ver2=$*
    done
}

if printf %s\\n "$source_path" "$PWD" | grep -q "[[:space:]:]";
then
  error_exit "main directory cannot contain spaces nor colons"
fi

# parse CC options first; some compiler tests are used to establish
# some defaults, based on the host environment

# default parameters
container_engine="auto"
cpu=""
cross_compile="no"
cross_prefix=""
host_cc="cc"
EXTRA_CFLAGS=""
EXTRA_CXXFLAGS=""
EXTRA_OBJCFLAGS=""
EXTRA_LDFLAGS=""

# Default value for a variable defining feature "foo".
#  * foo="no"  feature will only be used if --enable-foo arg is given
#  * foo=""    feature will be searched for, and if found, will be used
#              unless --disable-foo is given
#  * foo="yes" this value will only be set by --enable-foo flag.
#              feature will searched for,
#              if not found, configure exits with error
#
# Always add --enable-foo and --disable-foo command line args.
# Distributions want to ensure that several features are compiled in, and it
# is impossible without a --enable-foo that exits if a feature is not found.
default_feature=""

for opt do
  optarg=$(expr "x$opt" : 'x[^=]*=\(.*\)')
  case "$opt" in
  --cross-prefix=*) cross_prefix="$optarg"
                    cross_compile="yes"
  ;;
  --cc=*) CC="$optarg"
  ;;
  --cxx=*) CXX="$optarg"
  ;;
  --objcc=*) objcc="$optarg"
  ;;
  --rustc=*) RUSTC="$optarg"
  ;;
  --cpu=*) cpu="$optarg"
  ;;
  --extra-cflags=*)
    EXTRA_CFLAGS="$EXTRA_CFLAGS $optarg"
    EXTRA_CXXFLAGS="$EXTRA_CXXFLAGS $optarg"
    EXTRA_OBJCFLAGS="$EXTRA_OBJCFLAGS $optarg"
    ;;
  --extra-cxxflags=*) EXTRA_CXXFLAGS="$EXTRA_CXXFLAGS $optarg"
  ;;
  --extra-objcflags=*) EXTRA_OBJCFLAGS="$EXTRA_OBJCFLAGS $optarg"
  ;;
  --extra-ldflags=*) EXTRA_LDFLAGS="$EXTRA_LDFLAGS $optarg"
  ;;
  --cross-cc-*[!a-zA-Z0-9_-]*=*) error_exit "Passed bad --cross-cc-FOO option"
  ;;
  --cross-cc-cflags-*) cc_arch=${opt#--cross-cc-cflags-}; cc_arch=${cc_arch%%=*}
                      eval "cross_cc_cflags_${cc_arch}=\$optarg"
  ;;
  --cross-cc-*) cc_arch=${opt#--cross-cc-}; cc_arch=${cc_arch%%=*}
                eval "cross_cc_${cc_arch}=\$optarg"
  ;;
  --cross-prefix-*[!a-zA-Z0-9_-]*=*) error_exit "Passed bad --cross-prefix-FOO option"
  ;;
  --cross-prefix-*) cc_arch=${opt#--cross-prefix-}; cc_arch=${cc_arch%%=*}
                    eval "cross_prefix_${cc_arch}=\$optarg"
  ;;
  --without-default-features) default_feature="no"
  ;;
  esac
done

default_cflags='-O2 -g'
git_submodules_action="update"
docs="auto"
EXESUF=""
system="yes"
linux_user=""
bsd_user=""
plugins="$default_feature"
subdirs=""
ninja=""
python=
download="enabled"
skip_meson=no
use_containers="yes"
rust="disabled"
rust_target_triple=""
gdb_bin=$(command -v "gdb-multiarch" || command -v "gdb")
gdb_arches=""

# Don't accept a target_list environment variable.
unset target_list
unset target_list_exclude

# The following Meson options are handled manually (still they
# are included in the automatically generated help message)
# because they automatically enable/disable other options
tcg="auto"
cfi="false"

# Meson has PIE as a boolean rather than enabled/disabled/auto,
# and we also need to check for -static-pie before Meson runs
# which requires knowing whether --static is enabled.
pie=""
static="no"

# Preferred compiler:
#  ${CC} (if set)
#  ${cross_prefix}gcc (if cross-prefix specified)
#  system compiler
if test -z "${CC}${cross_prefix}"; then
  cc="cc"
else
  cc="${CC-${cross_prefix}gcc}"
fi

if test -z "${CXX}${cross_prefix}"; then
  cxx="c++"
else
  cxx="${CXX-${cross_prefix}g++}"
fi

# Preferred ObjC compiler:
# $objcc (if set, i.e. via --objcc option)
# ${cross_prefix}clang (if cross-prefix specified)
# clang (if available)
# $cc
if test -z "${objcc}${cross_prefix}"; then
  if has clang; then
    objcc=clang
  else
    objcc="$cc"
  fi
else
  objcc="${objcc-${cross_prefix}clang}"
fi

ar="${AR-${cross_prefix}ar}"
as="${AS-${cross_prefix}as}"
ccas="${CCAS-$cc}"
dlltool="${DLLTOOL-${cross_prefix}dlltool}"
objcopy="${OBJCOPY-${cross_prefix}objcopy}"
ld="${LD-${cross_prefix}ld}"
ranlib="${RANLIB-${cross_prefix}ranlib}"
nm="${NM-${cross_prefix}nm}"
readelf="${READELF-${cross_prefix}readelf}"
strip="${STRIP-${cross_prefix}strip}"
widl="${WIDL-${cross_prefix}widl}"
windres="${WINDRES-${cross_prefix}windres}"
windmc="${WINDMC-${cross_prefix}windmc}"
pkg_config="${PKG_CONFIG-${cross_prefix}pkg-config}"
sdl2_config="${SDL2_CONFIG-${cross_prefix}sdl2-config}"

rustc="${RUSTC-rustc}"

check_define() {
cat > $TMPC <<EOF
#if !defined($1)
#error $1 not defined
#endif
int main(void) { return 0; }
EOF
  compile_object
}

write_c_skeleton() {
    cat > $TMPC <<EOF
int main(void) { return 0; }
EOF
}

if check_define __linux__ ; then
  host_os=linux
elif check_define _WIN32 ; then
  host_os=windows
elif check_define __OpenBSD__ ; then
  host_os=openbsd
elif check_define __sun__ ; then
  host_os=sunos
elif check_define __HAIKU__ ; then
  host_os=haiku
elif check_define __FreeBSD__ ; then
  host_os=freebsd
elif check_define __FreeBSD_kernel__ && check_define __GLIBC__; then
  host_os=gnu/kfreebsd
elif check_define __DragonFly__ ; then
  host_os=dragonfly
elif check_define __NetBSD__; then
  host_os=netbsd
elif check_define __APPLE__; then
  host_os=darwin
else
  # This is a fatal error, but don't report it yet, because we
  # might be going to just print the --help text, or it might
  # be the result of a missing compiler.
  host_os=bogus
fi

if test ! -z "$cpu" ; then
  # command line argument
  :
elif check_define __i386__ ; then
  cpu="i386"
elif check_define __x86_64__ ; then
  if check_define __ILP32__ ; then
    cpu="x32"
  else
    cpu="x86_64"
  fi
elif check_define __sparc__ ; then
  if check_define __arch64__ ; then
    cpu="sparc64"
  else
    cpu="sparc"
  fi
elif check_define _ARCH_PPC ; then
  if check_define _ARCH_PPC64 ; then
    if check_define _LITTLE_ENDIAN ; then
      cpu="ppc64le"
    else
      cpu="ppc64"
    fi
  else
    cpu="ppc"
  fi
elif check_define __mips__ ; then
  if check_define __mips64 ; then
    cpu="mips64"
  else
    cpu="mips"
  fi
elif check_define __s390__ ; then
  if check_define __s390x__ ; then
    cpu="s390x"
  else
    cpu="s390"
  fi
elif check_define __riscv ; then
  if check_define _LP64 ; then
    cpu="riscv64"
  else
    cpu="riscv32"
  fi
elif check_define __arm__ ; then
  cpu="arm"
elif check_define __aarch64__ ; then
  cpu="aarch64"
elif check_define __loongarch64 ; then
  cpu="loongarch64"
else
  # Using uname is really broken, but it is just a fallback for architectures
  # that are going to use TCI anyway
  cpu=$(uname -m)
  if test "$host_os" != "bogus"; then
    echo "WARNING: unrecognized host CPU, proceeding with 'uname -m' output '$cpu'"
  fi
fi

# Normalise host CPU name to the values used by Meson cross files and in source
# directories, and set multilib cflags.  The canonicalization isn't really
# necessary, because the architectures that we check for should not hit the
# 'uname -m' case, but better safe than sorry in case --cpu= is used.
#
# Note that this case should only have supported host CPUs, not guests.
# Please keep it sorted and synchronized with meson.build's host_arch.
host_arch=
linux_arch=
raw_cpu=$cpu
case "$cpu" in
  aarch64)
    host_arch=aarch64
    linux_arch=arm64
    ;;

  armv*b|armv*l|arm)
    cpu=arm
    host_arch=arm
    linux_arch=arm
    ;;

  i386|i486|i586|i686)
    cpu="i386"
    host_arch=i386
    linux_arch=x86
    CPU_CFLAGS="-m32"
    ;;

  loongarch*)
    cpu=loongarch64
    host_arch=loongarch64
    linux_arch=loongarch
    ;;

  mips64*|mipsisa64*)
    cpu=mips64
    host_arch=mips
    linux_arch=mips
    ;;
  mips*)
    cpu=mips
    host_arch=mips
    linux_arch=mips
    ;;

  ppc)
    host_arch=ppc
    linux_arch=powerpc
    CPU_CFLAGS="-m32"
    ;;
  ppc64)
    host_arch=ppc64
    linux_arch=powerpc
    CPU_CFLAGS="-m64 -mbig-endian"
    ;;
  ppc64le)
    cpu=ppc64
    host_arch=ppc64
    linux_arch=powerpc
    CPU_CFLAGS="-m64 -mlittle-endian"
    ;;

  riscv32 | riscv64)
    host_arch=riscv
    linux_arch=riscv
    ;;

  s390)
    linux_arch=s390
    CPU_CFLAGS="-m31"
    ;;
  s390x)
    host_arch=s390x
    linux_arch=s390
    CPU_CFLAGS="-m64"
    ;;

  sparc|sun4[cdmuv])
    cpu=sparc
    CPU_CFLAGS="-m32 -mv8plus -mcpu=ultrasparc"
    ;;
  sparc64)
    host_arch=sparc64
    CPU_CFLAGS="-m64 -mcpu=ultrasparc"
    ;;

  x32)
    cpu="x86_64"
    host_arch=x86_64
    linux_arch=x86
    CPU_CFLAGS="-mx32"
    ;;
  x86_64|amd64)
    cpu="x86_64"
    host_arch=x86_64
    linux_arch=x86
    CPU_CFLAGS="-m64"
    ;;
esac

if test -n "$host_arch" && {
    ! test -d "$source_path/linux-user/include/host/$host_arch" ||
    ! test -d "$source_path/common-user/host/$host_arch"; }; then
    error_exit "linux-user/include/host/$host_arch does not exist." \
       "This is a bug in the configure script, please report it."
fi
if test -n "$linux_arch" && ! test -d "$source_path/linux-headers/asm-$linux_arch"; then
    error_exit "linux-headers/asm-$linux_arch does not exist." \
       "This is a bug in the configure script, please report it."
fi

check_py_version() {
    # We require python >= 3.8.
    # NB: a True python conditional creates a non-zero return code (Failure)
    "$1" -c 'import sys; sys.exit(sys.version_info < (3,8))'
}

first_python=
if test -z "${PYTHON}"; then
    # A bare 'python' is traditionally python 2.x, but some distros
    # have it as python 3.x, so check in both places.
    for binary in python3 python python3.12 python3.11 \
                          python3.10 python3.9 python3.8; do
        if has "$binary"; then
            python=$(command -v "$binary")
            if check_py_version "$python"; then
                # This one is good.
                first_python=
                break
            else
                first_python=$python
            fi
        fi
    done
else
    # Same as above, but only check the environment variable.
    has "${PYTHON}" || error_exit "The PYTHON environment variable does not point to an executable"
    python=$(command -v "$PYTHON")
    if check_py_version "$python"; then
        # This one is good.
        first_python=
    else
        first_python=$first_python
    fi
fi

# Check for ancillary tools used in testing
genisoimage=
for binary in genisoimage mkisofs
do
    if has $binary
    then
        genisoimage=$(command -v "$binary")
        break
    fi
done

if test "$host_os" = "windows" ; then
  EXESUF=".exe"
fi

meson_option_build_array() {
  printf '['
  (if test "$host_os" = windows; then
    IFS=\;
  else
    IFS=:
  fi
  for e in $1; do
    printf '"""'
    # backslash escape any '\' and '"' characters
    printf "%s" "$e" | sed -e 's/\([\"]\)/\\\1/g'
    printf '""",'
  done)
  printf ']\n'
}

. "$source_path/scripts/meson-buildoptions.sh"

meson_options=
meson_option_add() {
  local arg
  for arg; do
    meson_options="$meson_options $(quote_sh "$arg")"
  done
}
meson_option_parse() {
  meson_options="$meson_options $(_meson_option_parse "$@")"
  if test $? -eq 1; then
    echo "ERROR: unknown option $1"
    echo "Try '$0 --help' for more information"
    exit 1
  fi
}
has_meson_option() {
    test "${meson_options#*"$1"}" != "$meson_options"
}

meson_add_machine_file() {
  if test "$cross_compile" = "yes"; then
    meson_option_add --cross-file "$1"
  else
    meson_option_add --native-file "$1"
  fi
}

for opt do
  optarg=$(expr "x$opt" : 'x[^=]*=\(.*\)')
  case "$opt" in
  --help|-h) show_help=yes
  ;;
  --version|-V) exec cat "$source_path/VERSION"
  ;;
  --cross-prefix=*)
  ;;
  --cc=*)
  ;;
  --host-cc=*) host_cc="$optarg"
  ;;
  --cxx=*)
  ;;
  --objcc=*)
  ;;
  --rustc=*)
  ;;
  --make=*)
  ;;
  --install=*)
  ;;
  --python=*) python="$optarg"
  ;;
  --skip-meson) skip_meson=yes
  ;;
  --ninja=*) ninja="$optarg"
  ;;
  --extra-cflags=*)
  ;;
  --extra-cxxflags=*)
  ;;
  --extra-objcflags=*)
  ;;
  --extra-ldflags=*)
  ;;
  --cross-cc-*)
  ;;
  --cross-prefix-*)
  ;;
  --enable-docs) docs=enabled
  ;;
  --disable-docs) docs=disabled
  ;;
  --cpu=*)
  ;;
  --target-list=*) target_list="$optarg"
                   if test "$target_list_exclude"; then
                       error_exit "Can't mix --target-list with --target-list-exclude"
                   fi
  ;;
  --target-list-exclude=*) target_list_exclude="$optarg"
                   if test "$target_list"; then
                       error_exit "Can't mix --target-list-exclude with --target-list"
                   fi
  ;;
  --with-default-devices) meson_option_add -Ddefault_devices=true
  ;;
  --without-default-devices) meson_option_add -Ddefault_devices=false
  ;;
  --with-devices-*[!a-zA-Z0-9_-]*=*) error_exit "Passed bad --with-devices-FOO option"
  ;;
  --with-devices-*) device_arch=${opt#--with-devices-};
                    device_arch=${device_arch%%=*}
                    cf=$source_path/configs/devices/$device_arch-softmmu/$optarg.mak
                    if test -f "$cf"; then
                        device_archs="$device_archs $device_arch"
                        eval "devices_${device_arch}=\$optarg"
                    else
                        error_exit "File $cf does not exist"
                    fi
  ;;
  --without-default-features) # processed above
  ;;
  --static) static="yes"
  ;;
  --host=*|--build=*|\
  --disable-dependency-tracking|\
  --sbindir=*|--sharedstatedir=*|\
  --oldincludedir=*|--datarootdir=*|--infodir=*|\
  --htmldir=*|--dvidir=*|--pdfdir=*|--psdir=*)
    # These switches are silently ignored, for compatibility with
    # autoconf-generated configure scripts. This allows QEMU's
    # configure to be used by RPM and similar macros that set
    # lots of directory switches by default.
  ;;
  --enable-debug)
      # Enable debugging options that aren't excessively noisy
      meson_option_parse --enable-debug-tcg ""
      meson_option_parse --enable-debug-graph-lock ""
      meson_option_parse --enable-debug-mutex ""
      meson_option_add -Doptimization=0
      default_cflags='-O0 -g'
  ;;
  --disable-tcg) tcg="disabled"
  ;;
  --enable-tcg) tcg="enabled"
  ;;
  --disable-system) system="no"
  ;;
  --enable-system) system="yes"
  ;;
  --disable-user)
      linux_user="no" ;
      bsd_user="no" ;
  ;;
  --enable-user) ;;
  --disable-linux-user) linux_user="no"
  ;;
  --enable-linux-user) linux_user="yes"
  ;;
  --disable-bsd-user) bsd_user="no"
  ;;
  --enable-bsd-user) bsd_user="yes"
  ;;
  --enable-pie) pie="yes"
  ;;
  --disable-pie) pie="no"
  ;;
  --enable-cfi) cfi=true
  ;;
  --disable-cfi) cfi=false
  ;;
  --disable-download) download="disabled"; git_submodules_action=validate;
  ;;
  --enable-download) download="enabled"; git_submodules_action=update;
  ;;
  --enable-plugins) plugins="yes"
  ;;
  --disable-plugins) plugins="no"
  ;;
  --enable-containers) use_containers="yes"
  ;;
  --disable-containers) use_containers="no"
  ;;
  --container-engine=*) container_engine="$optarg"
  ;;
  --rust-target-triple=*) rust_target_triple="$optarg"
  ;;
  --gdb=*) gdb_bin="$optarg"
  ;;
  --enable-rust) rust=enabled
  ;;
  --disable-rust) rust=disabled
  ;;
  # everything else has the same name in configure and meson
  --*) meson_option_parse "$opt" "$optarg"
  ;;
  # Pass through -Dxxxx options to meson
  -D*) meson_option_add "$opt"
  ;;
  esac
done

if ! test -e "$source_path/.git"
then
    git_submodules_action="validate"
fi

if ! test -f "$source_path/subprojects/keycodemapdb/README" \
    && test "$download" = disabled
then
    echo
    echo "ERROR: missing subprojects"
    echo
    if test -e "$source_path/.git"; then
        echo "--disable-download specified but subprojects were not"
        echo 'checked out.  Please invoke "meson subprojects download"'
        echo "before configuring QEMU, or remove --disable-download"
        echo "from the command line."
    else
        echo "This is not a GIT checkout but subproject content appears to"
        echo "be missing. Do not use 'git archive' or GitHub download links"
        echo "to acquire QEMU source archives. Non-GIT builds are only"
        echo "supported with source archives linked from:"
        echo
        echo "  https://www.qemu.org/download/#source"
        echo
        echo "Developers working with GIT can use scripts/archive-source.sh"
        echo "if they need to create valid source archives."
    fi
    echo
    exit 1
fi

default_target_list=""
mak_wilds=""

if [ -n "$host_arch" ] && [ -d "$source_path/common-user/host/$host_arch" ]; then
    if [ "$linux_user" != no ]; then
        if [ "$host_os" = linux ]; then
            linux_user=yes
        elif [ "$linux_user" = yes ]; then
            error_exit "linux-user not supported on this architecture"
        fi
        if [ "$linux_user" = "yes" ]; then
            mak_wilds="${mak_wilds} $source_path/configs/targets/*-linux-user.mak"
        fi
    fi
    if [ "$bsd_user" != no ]; then
        if [ "$bsd_user" = "" ]; then
            test $host_os = freebsd && bsd_user=yes
        fi
        if [ "$bsd_user" = yes ] && ! [ -d "$source_path/bsd-user/$host_os" ]; then
            error_exit "bsd-user not supported on this host OS"
        fi
        if [ "$bsd_user" = "yes" ]; then
            mak_wilds="${mak_wilds} $source_path/configs/targets/*-bsd-user.mak"
        fi
    fi
else
    if [ "$linux_user" = yes ] || [ "$bsd_user" = yes ]; then
        error_exit "user mode emulation not supported on this architecture"
    fi
fi
if [ "$system" = "yes" ]; then
    mak_wilds="${mak_wilds} $source_path/configs/targets/*-softmmu.mak"
fi

for config in $mak_wilds; do
    target="$(basename "$config" .mak)"
    if echo "$target_list_exclude" | grep -vq "$target"; then
        default_target_list="${default_target_list} $target"
    fi
done

if test x"$show_help" = x"yes" ; then
cat << EOF

Usage: configure [options]
Options: [defaults in brackets after descriptions]

Standard options:
  --help                   print this message
  --target-list=LIST       set target list (default: build all)
$(echo Available targets: $default_target_list | \
  fold -s -w 53 | sed -e 's/^/                           /')
  --target-list-exclude=LIST exclude a set of targets from the default target-list

Advanced options (experts only):
  -Dmesonoptname=val       passthrough option to meson unmodified
  --cross-prefix=PREFIX    use PREFIX for compile tools, PREFIX can be blank [$cross_prefix]
  --cc=CC                  use C compiler CC [$cc]
  --host-cc=CC             when cross compiling, use C compiler CC for code run
                           at build time [$host_cc]
  --cxx=CXX                use C++ compiler CXX [$cxx]
  --objcc=OBJCC            use Objective-C compiler OBJCC [$objcc]
  --rustc=RUSTC            use Rust compiler RUSTC [$rustc]
  --extra-cflags=CFLAGS    append extra C compiler flags CFLAGS
  --extra-cxxflags=CXXFLAGS append extra C++ compiler flags CXXFLAGS
  --extra-objcflags=OBJCFLAGS append extra Objective C compiler flags OBJCFLAGS
  --extra-ldflags=LDFLAGS  append extra linker flags LDFLAGS
  --cross-cc-ARCH=CC       use compiler when building ARCH guest test cases
  --cross-cc-cflags-ARCH=  use compiler flags when building ARCH guest tests
  --cross-prefix-ARCH=PREFIX cross compiler prefix when building ARCH guest test cases
  --python=PYTHON          use specified python [$python]
  --ninja=NINJA            use specified ninja [$ninja]
  --static                 enable static build [$static]
  --rust-target-triple=TRIPLE  compilation target for Rust code [autodetect]
  --without-default-features   default all --enable-* options to "disabled"
  --without-default-devices    do not include any device that is not needed to
                           start the emulator (only use if you are including
                           desired devices in configs/devices/)
  --with-devices-ARCH=NAME override default configs/devices
  --enable-debug           enable common debug build options
  --cpu=CPU                Build for host CPU [$cpu]
  --disable-containers     don't use containers for cross-building
  --container-engine=TYPE  which container engine to use [$container_engine]
  --gdb=GDB-path           gdb to use for gdbstub tests [$gdb_bin]
EOF
  meson_options_help
cat << EOF
  system          all system emulation targets
  user            supported user emulation targets
  linux-user      all linux usermode emulation targets
  bsd-user        all BSD usermode emulation targets
  pie             Position Independent Executables

NOTE: The object files are built at the place where configure is launched
EOF
exit 0
fi

# Now that we are sure that the user did not only want to print the --help
# information, we should double-check that the C compiler really works:
write_c_skeleton
if ! compile_object ; then
    error_exit "C compiler \"$cc\" either does not exist or does not work."
fi

# Remove old dependency files to make sure that they get properly regenerated
rm -f ./*/config-devices.mak.d

if test -z "$python"
then
    # If first_python is set, there was a binary somewhere even though
    # it was not suitable.  Use it for the error message.
    if test -n "$first_python"; then
        error_exit "Cannot use '$first_python', Python >= 3.8 is required." \
            "Use --python=/path/to/python to specify a supported Python."
    else
        error_exit "Python not found. Use --python=/path/to/python"
    fi
fi

if ! check_py_version "$python"; then
  error_exit "Cannot use '$python', Python >= 3.8 is required." \
             "Use --python=/path/to/python to specify a supported Python." \
             "Maybe try:" \
             "  openSUSE Leap 15.3+: zypper install python39" \
             "  CentOS 8: dnf install python38"
fi

# Resolve PATH
python="$(command -v "$python")"

# Create a Python virtual environment using our configured python.
# The stdout of this script will be the location of a symlink that
# points to the configured Python.
# Entry point scripts for pip, meson, and sphinx are generated if those
# packages are present.

# Defaults assumed for now:
# - venv is cleared if it exists already;
# - venv is allowed to use system packages;
# - all setup can be performed offline;
# - missing packages may be fetched from PyPI,
#   unless --disable-download is passed.
# - pip is not installed into the venv when possible,
#   but ensurepip is called as a fallback when necessary.

echo "python determined to be '$python'"
echo "python version: $($python --version)"

python="$($python -B "${source_path}/python/scripts/mkvenv.py" create pyvenv)"
if test "$?" -ne 0 ; then
    error_exit "python venv creation failed"
fi

# Suppress writing compiled files
python="$python -B"
mkvenv="$python ${source_path}/python/scripts/mkvenv.py"

# Finish preparing the virtual environment using vendored .whl files

$mkvenv ensuregroup --dir "${source_path}/python/wheels" \
     ${source_path}/pythondeps.toml meson || exit 1

# At this point, we expect Meson to be installed and available.
# We expect mkvenv or pip to have created pyvenv/bin/meson for us.
# We ignore PATH completely here: we want to use the venv's Meson
# *exclusively*.

meson="$(cd pyvenv/bin; pwd)/meson"

# Conditionally ensure Sphinx is installed.

mkvenv_online_flag=""
if test "$download" = "enabled" ; then
    mkvenv_online_flag=" --online"
fi

if test "$docs" != "disabled" ; then
    if ! $mkvenv ensuregroup \
         $(test "$docs" = "enabled" && echo "$mkvenv_online_flag") \
         ${source_path}/pythondeps.toml docs;
    then
        if test "$docs" = "enabled" ; then
            exit 1
        fi
        echo "Sphinx not found/usable, disabling docs."
        docs=disabled
    else
        docs=enabled
    fi
fi

# Probe for ninja

if test -z "$ninja"; then
    for c in ninja ninja-build samu; do
        if has $c; then
            ninja=$(command -v "$c")
            break
        fi
    done
    if test -z "$ninja"; then
      error_exit "Cannot find Ninja"
    fi
fi

if test "$host_os" = "bogus"; then
    # Now that we know that we're not printing the help and that
    # the compiler works (so the results of the check_defines we used
    # to identify the OS are reliable), if we didn't recognize the
    # host OS we should stop now.
    error_exit "Unrecognized host OS (uname -s reports '$(uname -s)')"
fi

# test for any invalid configuration combinations
if test "$host_os" = "windows" && ! has "$dlltool"; then
  if test "$plugins" = "yes"; then
    error_exit "TCG plugins requires dlltool to build on Windows platforms"
  fi
  plugins="no"
fi
if test "$tcg" = "disabled" ; then
  if test "$plugins" = "yes"; then
    error_exit "Can't enable plugins on non-TCG builds"
  fi
  plugins="no"
fi
if test "$static" = "yes" ; then
  if test "$plugins" = "yes"; then
    error_exit "static and plugins are mutually incompatible"
  fi
  plugins="no"
fi
if test "$plugins" != "no"; then
    if has_meson_option "-Dtcg_interpreter=true"; then
        plugins="no"
    else
        plugins=yes
    fi
fi

cat > $TMPC << EOF

#ifdef __linux__
#  define THREAD __thread
#else
#  define THREAD
#endif
static THREAD int tls_var;
int main(void) { return tls_var; }
EOF

if test "$host_os" = windows || test "$host_os" = haiku; then
  if test "$pie" = "yes"; then
    error_exit "PIE not available due to missing OS support"
  fi
  pie=no
fi

if test "$pie" != "no"; then
  if test "$static" = "yes"; then
    pie_ldflags=-static-pie
  else
    pie_ldflags=-pie
  fi
  if compile_prog "-Werror -fPIE -DPIE" "$pie_ldflags"; then
    pie="yes"
  elif test "$pie" = "yes"; then
    error_exit "-static-pie not available due to missing toolchain support"
  else
    echo "Disabling PIE due to missing toolchain support"
    pie="no"
  fi
fi

##########################################

if test -z "${target_list+xxx}" ; then
    default_targets=yes
    for target in $default_target_list; do
        target_list="$target_list $target"
    done
    target_list="${target_list# }"
else
    default_targets=no
    target_list=$(echo "$target_list" | sed -e 's/,/ /g')
    for target in $target_list; do
        # Check that we recognised the target name; this allows a more
        # friendly error message than if we let it fall through.
        case " $default_target_list " in
            *" $target "*)
                ;;
            *)
                error_exit "Unknown target name '$target'"
                ;;
        esac
    done
fi

if test "$tcg" = "auto"; then
  if test -z "$target_list"; then
    tcg="disabled"
  else
    tcg="enabled"
  fi
fi

#########################################
# gdb test

if test -n "$gdb_bin"; then
    gdb_version_string=$($gdb_bin --version | head -n 1)
    # Extract last field in the version string
    gdb_version=${gdb_version_string##* }
    if version_ge $gdb_version 9.1; then
        gdb_arches=$($python "$source_path/scripts/probe-gdb-support.py" $gdb_bin)
    else
        gdb_bin=""
    fi
fi

##########################################
# big/little endian test
cat > $TMPC << EOF
#if defined(__BYTE_ORDER__) && __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__
# error LITTLE
#endif
int main(void) { return 0; }
EOF

if ! compile_prog ; then
  bigendian="no"
else
  cat > $TMPC << EOF
#if defined(__BYTE_ORDER__) && __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__
# error BIG
#endif
int main(void) { return 0; }
EOF

  if ! compile_prog ; then
    bigendian="yes"
  else
    echo big/little test failed
    exit 1
  fi
fi

##########################################
# detect rust triple

if test "$rust" != disabled && has "$rustc" && $rustc -vV > "${TMPDIR1}/${TMPB}.out"; then
  rust_host_triple=$(sed -n 's/^host: //p' "${TMPDIR1}/${TMPB}.out")
else
  if test "$rust" = enabled; then
    error_exit "could not execute rustc binary \"$rustc\""
  fi
  rust=disabled
fi
if test "$rust" != disabled && test -z "$rust_target_triple"; then
  # arch and os generally matches between meson and rust
  rust_arch=$host_arch
  rust_os=$host_os
  rust_machine=unknown
  rust_osvariant=

  # tweak rust_os if needed; also, machine and variant depend on the OS
  android=no
  case "$host_os" in
  darwin)
    # e.g. aarch64-apple-darwin
    rust_machine=apple
    ;;

  linux)
    # detect android/glibc/musl
    if check_define __ANDROID__; then
      rust_osvariant=android
      android=yes
    else
      cat > $TMPC << EOF
#define _GNU_SOURCE
#include <features.h>
#ifndef __USE_GNU
error using musl
#endif
EOF
      if compile_object; then
        rust_osvariant=gnu
      else
        rust_osvariant=musl
      fi
    fi

    case "$cpu" in
    arm)
      # e.g. arm-unknown-linux-gnueabi, arm-unknown-linux-gnueabihf
      write_c_skeleton
      compile_object
      if $READELF -A $TMPO | grep Tag_API_VFP_args: > /dev/null; then
        rust_osvariant=${rust_osvariant}eabihf
      else
        rust_osvariant=${rust_osvariant}eabi
      fi
      ;;

    mips64)
      # e.g. mips64-unknown-linux-gnuabi64
      rust_osvariant=${rust_osvariant}abi64
      ;;
    esac
    ;;

  netbsd)
    # e.g. arm-unknown-netbsd-eabihf
    test "$host_arch" = arm && rust_osvariant=eabihf
    ;;

  sunos)
    rust_machine=pc
    rust_os=solaris
    ;;

  windows)
    # e.g. aarch64-pc-windows-gnullvm, x86_64-pc-windows-gnu (MSVC not supported)
    rust_machine=pc
    if test "$host_arch" = aarch64; then
      rust_osvariant=gnullvm
    else
      rust_osvariant=gnu
    fi
    ;;
  esac

  # now tweak the architecture part, possibly based on pre-canonicalization --cpu
  case "$host_arch" in
  arm)
    # preserve ISA version (armv7 etc.) from $raw_cpu if passed via --cpu
    rust_arch=$raw_cpu
    test "$rust_arch" = arm && test "$rust_os" != linux && rust_arch=armv7
    ;;

  mips)
    # preserve ISA version (mipsisa64r6 etc.) and include endianness
    rust_arch=${raw_cpu%el}
    test "$bigendian" = no && rust_arch=${rust_arch}el
    ;;

  riscv32|riscv64)
    # e.g. riscv64gc-unknown-linux-gnu, but riscv64-linux-android
    test "$android" = no && rust_arch=${rust_arch}gc
    ;;

  sparc64)
    if test "$rust_os" = solaris; then
      rust_arch=sparcv9
      rust_machine=sun
    fi
    ;;

  x86_64)
    # e.g. x86_64-unknown-linux-gnux32
    test "$raw_cpu" = x32 && rust_osvariant=${rust_osvariant}x32
    ;;
  esac

  if test "$android" = yes; then
    # e.g. aarch64-linux-android
    rust_target_triple=$rust_arch-$rust_os-$rust_osvariant
  else
    rust_target_triple=$rust_arch-$rust_machine-$rust_os${rust_osvariant:+-$rust_osvariant}
  fi
fi

##########################################
# functions to probe cross compilers

container="no"
runc=""
if test $use_containers = "yes" && (has "docker" || has "podman"); then
    case $($python "$source_path"/tests/docker/docker.py --engine "$container_engine" probe) in
        *docker) container=docker ;;
        podman) container=podman ;;
        no) container=no ;;
    esac
    if test "$container" != "no"; then
        docker_py="$python $source_path/tests/docker/docker.py --engine $container"
        runc=$container
    fi
fi

# cross compilers defaults, can be overridden with --cross-cc-ARCH
: ${cross_prefix_aarch64="aarch64-linux-gnu-"}
: ${cross_prefix_aarch64_be="$cross_prefix_aarch64"}
: ${cross_prefix_alpha="alpha-linux-gnu-"}
: ${cross_prefix_arm="arm-linux-gnueabihf-"}
: ${cross_prefix_armeb="$cross_prefix_arm"}
: ${cross_prefix_hexagon="hexagon-unknown-linux-musl-"}
: ${cross_prefix_loongarch64="loongarch64-unknown-linux-gnu-"}
: ${cross_prefix_hppa="hppa-linux-gnu-"}
: ${cross_prefix_i386="i686-linux-gnu-"}
: ${cross_prefix_m68k="m68k-linux-gnu-"}
: ${cross_prefix_microblaze="microblaze-linux-musl-"}
: ${cross_prefix_mips64el="mips64el-linux-gnuabi64-"}
: ${cross_prefix_mips64="mips64-linux-gnuabi64-"}
: ${cross_prefix_mipsel="mipsel-linux-gnu-"}
: ${cross_prefix_mips="mips-linux-gnu-"}
: ${cross_prefix_ppc="powerpc-linux-gnu-"}
: ${cross_prefix_ppc64="powerpc64-linux-gnu-"}
: ${cross_prefix_ppc64le="$cross_prefix_ppc64"}
: ${cross_prefix_riscv64="riscv64-linux-gnu-"}
: ${cross_prefix_s390x="s390x-linux-gnu-"}
: ${cross_prefix_sh4="sh4-linux-gnu-"}
: ${cross_prefix_sparc64="sparc64-linux-gnu-"}
: ${cross_prefix_sparc="$cross_prefix_sparc64"}
: ${cross_prefix_tricore="tricore-"}
: ${cross_prefix_x86_64="x86_64-linux-gnu-"}

: ${cross_cc_aarch64_be="$cross_cc_aarch64"}
: ${cross_cc_cflags_aarch64_be="-mbig-endian"}
: ${cross_cc_armeb="$cross_cc_arm"}
: ${cross_cc_cflags_armeb="-mbig-endian"}
: ${cross_cc_hexagon="hexagon-unknown-linux-musl-clang"}
: ${cross_cc_cflags_hexagon="-mv73 -O2 -static"}
: ${cross_cc_cflags_i386="-m32"}
: ${cross_cc_cflags_ppc="-m32 -mbig-endian"}
: ${cross_cc_cflags_ppc64="-m64 -mbig-endian"}
: ${cross_cc_ppc64le="$cross_cc_ppc64"}
: ${cross_cc_cflags_ppc64le="-m64 -mlittle-endian"}
: ${cross_cc_cflags_sparc64="-m64 -mcpu=ultrasparc"}
: ${cross_cc_sparc="$cross_cc_sparc64"}
: ${cross_cc_cflags_sparc="-m32 -mcpu=supersparc"}
: ${cross_cc_cflags_x86_64="-m64 -mcx16"}

compute_target_variable() {
  eval "$2="
  if eval test -n "\"\${cross_prefix_$1}\""; then
    if eval has "\"\${cross_prefix_$1}\$3\""; then
      eval "$2=\"\${cross_prefix_$1}\$3\""
    fi
  fi
}

have_target() {
  for i; do
    case " $target_list " in
      *" $i "*) return 0;;
      *) ;;
    esac
  done
  return 1
}

# probe_target_compiler TARGET
#
# Look for a compiler for the given target, either native or cross.
# Set variables target_* if a compiler is found, and container_cross_*
# if a Docker-based cross-compiler image is known for the target.
# Set got_cross_cc to yes/no depending on whether a non-container-based
# compiler was found.
#
# If TARGET is a user-mode emulation target, also set build_static to
# "y" if static linking is possible.
#
probe_target_compiler() {
  # reset all output variables
  got_cross_cc=no
  container_image=
  container_hosts=
  container_cross_prefix=
  container_cross_cc=
  container_cross_ar=
  container_cross_as=
  container_cross_ld=
  container_cross_nm=
  container_cross_objcopy=
  container_cross_ranlib=
  container_cross_strip=

  target_arch=${1%%-*}
  case $target_arch in
    aarch64) container_hosts="x86_64 aarch64" ;;
    aarch64_be) container_hosts="x86_64 aarch64" ;;
    alpha) container_hosts=x86_64 ;;
    arm) container_hosts="x86_64 aarch64" ;;
    hexagon) container_hosts=x86_64 ;;
    hppa) container_hosts=x86_64 ;;
    i386) container_hosts=x86_64 ;;
    loongarch64) container_hosts=x86_64 ;;
    m68k) container_hosts=x86_64 ;;
    microblaze) container_hosts=x86_64 ;;
    mips64el) container_hosts=x86_64 ;;
    mips64) container_hosts=x86_64 ;;
    mipsel) container_hosts=x86_64 ;;
    mips) container_hosts=x86_64 ;;
    ppc) container_hosts=x86_64 ;;
    ppc64|ppc64le) container_hosts=x86_64 ;;
    riscv64) container_hosts=x86_64 ;;
    s390x) container_hosts=x86_64 ;;
    sh4) container_hosts=x86_64 ;;
    sparc64) container_hosts=x86_64 ;;
    tricore) container_hosts=x86_64 ;;
    x86_64) container_hosts="aarch64 ppc64le x86_64" ;;
    xtensa*) container_hosts=x86_64 ;;
  esac

  for host in $container_hosts; do
    test "$container" != no || continue
    test "$host" = "$cpu" || continue
    case $target_arch in
      # debian-all-test-cross architectures

      aarch64_be)
        container_image=debian-all-test-cross
        container_cross_prefix=aarch64-linux-gnu-
        ;;
      hppa|m68k|mips|riscv64|sparc64)
        container_image=debian-all-test-cross
        ;;
      mips64)
        container_image=debian-all-test-cross
        container_cross_prefix=mips64-linux-gnuabi64-
        ;;
      ppc|ppc64|ppc64le)
        container_image=debian-all-test-cross
        container_cross_prefix=powerpc${target_arch#ppc}-linux-gnu-
        ;;

      # debian-legacy-test-cross architectures (need Debian 11)
      # - libc6.1-dev-alpha-cross: https://bugs.debian.org/cgi-bin/bugreport.cgi?bug=1054412
      # - sh4-linux-user: binaries don't run with bookworm compiler

      alpha|sh4)
        container_image=debian-legacy-test-cross
        ;;

      # architectures with individual containers

      aarch64)
        # We don't have any bigendian build tools so we only use this for AArch64
        container_image=debian-arm64-cross
        ;;
      arm)
        # We don't have any bigendian build tools so we only use this for ARM
        container_image=debian-armhf-cross
        container_cross_prefix=arm-linux-gnueabihf-
        ;;
      hexagon)
        container_cross_prefix=hexagon-unknown-linux-musl-
        container_cross_cc=${container_cross_prefix}clang
        ;;
      i386)
        container_image=debian-i686-cross
        container_cross_prefix=i686-linux-gnu-
        ;;
      loongarch64)
        container_image=debian-loongarch-cross
        container_cross_prefix=loongarch64-unknown-linux-gnu-
        ;;
      microblaze)
        container_cross_prefix=microblaze-linux-musl-
        ;;
      mips64el)
        container_image=debian-all-test-cross
        container_cross_prefix=mips64el-linux-gnuabi64-
        ;;
      tricore)
        container_image=debian-tricore-cross
        container_cross_prefix=tricore-
        ;;
      x86_64)
        container_image=debian-amd64-cross
        ;;
      xtensa*)
        container_image=debian-xtensa-cross

        # default to the dc232b cpu
        container_cross_prefix=/opt/2020.07/xtensa-dc232b-elf/bin/xtensa-dc232b-elf-
        ;;
    esac
    # Debian and GNU architecture names usually match
    : ${container_image:=debian-$target_arch-cross}
    : ${container_cross_prefix:=$target_arch-linux-gnu-}
    : ${container_cross_cc:=${container_cross_prefix}gcc}
    : ${container_cross_ar:=${container_cross_prefix}ar}
    : ${container_cross_as:=${container_cross_prefix}as}
    : ${container_cross_ld:=${container_cross_prefix}ld}
    : ${container_cross_nm:=${container_cross_prefix}nm}
    : ${container_cross_objcopy:=${container_cross_prefix}objcopy}
    : ${container_cross_ranlib:=${container_cross_prefix}ranlib}
    : ${container_cross_strip:=${container_cross_prefix}strip}
  done

  try=cross
  # For softmmu/roms also look for a bi-endian or multilib-enabled host compiler
  if [ "${1%softmmu}" != "$1" ] || test "$target_arch" = "$cpu"; then
      case "$target_arch:$cpu" in
        aarch64_be:aarch64 | \
        armeb:arm | \
        i386:x86_64 | \
        mips*:mips64 | \
        ppc*:ppc64 | \
        sparc:sparc64 | \
        "$cpu:$cpu")
        try='native cross' ;;
      esac
  fi
  eval "target_cflags=\${cross_cc_cflags_$target_arch}"
  for thistry in $try; do
    case $thistry in
    native)
      target_cc=$cc
      target_ccas=$ccas
      target_ar=$ar
      target_as=$as
      target_ld=$ld
      target_nm=$nm
      target_objcopy=$objcopy
      target_ranlib=$ranlib
      target_strip=$strip
      ;;
    cross)
      target_cc=
      if eval test -n "\"\${cross_cc_$target_arch}\""; then
        if eval has "\"\${cross_cc_$target_arch}\""; then
          eval "target_cc=\"\${cross_cc_$target_arch}\""
        fi
      else
        compute_target_variable $target_arch target_cc gcc
      fi
      target_ccas=$target_cc
      compute_target_variable $target_arch target_ar ar
      compute_target_variable $target_arch target_as as
      compute_target_variable $target_arch target_ld ld
      compute_target_variable $target_arch target_nm nm
      compute_target_variable $target_arch target_objcopy objcopy
      compute_target_variable $target_arch target_ranlib ranlib
      compute_target_variable $target_arch target_strip strip
      ;;
    esac

    if test -n "$target_cc"; then
      case $target_arch in
        i386|x86_64)
          if $target_cc --version | grep -qi "clang"; then
            continue
          fi
          ;;
      esac
    elif test -n "$target_as" && test -n "$target_ld"; then
      # Special handling for assembler only targets
      case $target in
        tricore-softmmu)
          build_static=
          got_cross_cc=yes
          break
          ;;
        *)
          continue
          ;;
      esac
    else
      continue
    fi

    write_c_skeleton
    case $1 in
      *-softmmu)
        if do_compiler "$target_cc" $target_cflags -o $TMPO -c $TMPC &&
          do_compiler "$target_cc" $target_cflags -r -nostdlib -o "${TMPDIR1}/${TMPB}2.o" "$TMPO" -lgcc; then
          got_cross_cc=yes
          break
        fi
        ;;
      *)
        if do_compiler "$target_cc" $target_cflags -o $TMPE $TMPC -static ; then
          build_static=y
          got_cross_cc=yes
          break
        fi
        if do_compiler "$target_cc" $target_cflags -o $TMPE $TMPC ; then
          build_static=
          got_cross_cc=yes
          break
        fi
        ;;
    esac
  done
  if test $got_cross_cc != yes; then
    build_static=
    target_cc=
    target_ccas=
    target_ar=
    target_as=
    target_ld=
    target_nm=
    target_objcopy=
    target_ranlib=
    target_strip=
  fi
  test -n "$target_cc"
}

write_target_makefile() {
  echo "EXTRA_CFLAGS=$target_cflags"
  if test -z "$target_cc" && test -z "$target_as"; then
    test -z "$container_image" && error_exit "Internal error: could not find cross compiler for $1?"
    echo "$1: docker-image-$container_image" >> Makefile.prereqs
    if test -n "$container_cross_cc"; then
      echo "CC=$docker_py cc --cc $container_cross_cc -i qemu/$container_image -s $source_path --"
      echo "CCAS=$docker_py cc --cc $container_cross_cc -i qemu/$container_image -s $source_path --"
    fi
    echo "AR=$docker_py cc --cc $container_cross_ar -i qemu/$container_image -s $source_path --"
    echo "AS=$docker_py cc --cc $container_cross_as -i qemu/$container_image -s $source_path --"
    echo "LD=$docker_py cc --cc $container_cross_ld -i qemu/$container_image -s $source_path --"
    echo "NM=$docker_py cc --cc $container_cross_nm -i qemu/$container_image -s $source_path --"
    echo "OBJCOPY=$docker_py cc --cc $container_cross_objcopy -i qemu/$container_image -s $source_path --"
    echo "RANLIB=$docker_py cc --cc $container_cross_ranlib -i qemu/$container_image -s $source_path --"
    echo "STRIP=$docker_py cc --cc $container_cross_strip -i qemu/$container_image -s $source_path --"
  else
    if test -n "$target_cc"; then
      echo "CC=$target_cc"
      echo "CCAS=$target_ccas"
    fi
    if test -n "$target_ar"; then
      echo "AR=$target_ar"
    fi
    if test -n "$target_as"; then
      echo "AS=$target_as"
    fi
    if test -n "$target_ld"; then
      echo "LD=$target_ld"
    fi
    if test -n "$target_nm"; then
      echo "NM=$target_nm"
    fi
    if test -n "$target_objcopy"; then
      echo "OBJCOPY=$target_objcopy"
    fi
    if test -n "$target_ranlib"; then
      echo "RANLIB=$target_ranlib"
    fi
    if test -n "$target_strip"; then
      echo "STRIP=$target_strip"
    fi
  fi
}

#######################################
# cross-compiled firmware targets

# Set up build tree symlinks that point back into the source tree
# (these can be both files and directories).
# Caution: avoid adding files or directories here using wildcards. This
# will result in problems later if a new file matching the wildcard is
# added to the source tree -- nothing will cause configure to be rerun
# so the build tree will be missing the link back to the new file, and
# tests might fail. Prefer to keep the relevant files in their own
# directory and symlink the directory instead.
LINKS="Makefile"
LINKS="$LINKS docs/config"
LINKS="$LINKS pc-bios/optionrom/Makefile"
LINKS="$LINKS pc-bios/s390-ccw/Makefile"
LINKS="$LINKS pc-bios/vof/Makefile"
LINKS="$LINKS .gdbinit scripts" # scripts needed by relative path in .gdbinit
LINKS="$LINKS tests/data"
LINKS="$LINKS tests/qemu-iotests/check tests/qemu-iotests/Makefile"
LINKS="$LINKS python"
for f in $LINKS ; do
    if [ -e "$source_path/$f" ]; then
        symlink "$source_path/$f" "$f"
    fi
done

# use included Linux headers for KVM architectures
if test "$host_os" = "linux" && test -n "$linux_arch"; then
  symlink "$source_path/linux-headers/asm-$linux_arch" linux-headers/asm
fi

echo "# Automatically generated by configure - do not modify" > Makefile.prereqs

# Mac OS X ships with a broken assembler
if have_target i386-softmmu x86_64-softmmu && \
        test "$host_os" != "darwin" && test "$host_os" != "sunos" && \
        test "$host_os" != "haiku" && \
        probe_target_compiler i386-softmmu; then
    subdirs="$subdirs pc-bios/optionrom"
    config_mak=pc-bios/optionrom/config.mak
    echo "# Automatically generated by configure - do not modify" > $config_mak
    echo "TOPSRC_DIR=$source_path" >> $config_mak
    write_target_makefile >> $config_mak
fi

if have_target ppc-softmmu ppc64-softmmu && \
        probe_target_compiler ppc-softmmu; then
    subdirs="$subdirs pc-bios/vof"
    config_mak=pc-bios/vof/config.mak
    echo "# Automatically generated by configure - do not modify" > $config_mak
    echo "SRC_DIR=$source_path/pc-bios/vof" >> $config_mak
    write_target_makefile >> $config_mak
fi

# Only build s390-ccw bios if the compiler has -march=z900 or -march=z10
# (which is the lowest architecture level that Clang supports)
if have_target s390x-softmmu && probe_target_compiler s390x-softmmu && \
    GIT=git "$source_path/scripts/git-submodule.sh" "$git_submodules_action" roms/SLOF >> config.log 2>&1; then
  write_c_skeleton
  do_compiler "$target_cc" $target_cc_cflags -march=z900 -o $TMPO -c $TMPC
  has_z900=$?
  if [ $has_z900 = 0 ] || do_compiler "$target_cc" $target_cc_cflags -march=z10 -msoft-float -Werror -o $TMPO -c $TMPC; then
    if [ $has_z900 != 0 ]; then
      echo "WARNING: Your compiler does not support the z900!"
      echo "         The s390-ccw bios will only work with guest CPUs >= z10."
    fi
    subdirs="$subdirs pc-bios/s390-ccw"
    config_mak=pc-bios/s390-ccw/config-host.mak
    echo "# Automatically generated by configure - do not modify" > $config_mak
    echo "SRC_PATH=$source_path/pc-bios/s390-ccw" >> $config_mak
    echo "GIT_SUBMODULES_ACTION=$git_submodules_action" >> $config_mak
    write_target_makefile >> $config_mak
  fi
fi

#######################################
# generate config-host.mak

config_host_mak="config-host.mak"

echo "# Automatically generated by configure - do not modify" > $config_host_mak
echo >> $config_host_mak

echo all: >> $config_host_mak

echo "SRC_PATH=$source_path" >> $config_host_mak
echo "TARGET_DIRS=$target_list" >> $config_host_mak
echo "GDB=$gdb_bin" >> $config_host_mak
if test "$container" != no; then
    echo "RUNC=$runc" >> $config_host_mak
fi
echo "SUBDIRS=$subdirs" >> $config_host_mak
if test "$rust" != disabled; then
  echo "RUST_TARGET_TRIPLE=$rust_target_triple" >> $config_host_mak
fi
echo "PYTHON=$python" >> $config_host_mak
echo "MKVENV_ENSUREGROUP=$mkvenv ensuregroup $mkvenv_online_flag" >> $config_host_mak
echo "GENISOIMAGE=$genisoimage" >> $config_host_mak
echo "MESON=$meson" >> $config_host_mak
echo "NINJA=$ninja" >> $config_host_mak
echo "EXESUF=$EXESUF" >> $config_host_mak
if test "$default_targets" = "yes"; then
  echo "CONFIG_DEFAULT_TARGETS=y" >> $config_host_mak
fi

# tests/tcg configuration
mkdir -p tests/tcg
echo "# Automatically generated by configure - do not modify" > tests/tcg/$config_host_mak
echo "SRC_PATH=$source_path" >> tests/tcg/$config_host_mak
if test "$plugins" = "yes" ; then
    echo "CONFIG_PLUGIN=y" >> tests/tcg/$config_host_mak
fi

tcg_tests_targets=
for target in $target_list; do
  arch=${target%%-*}

  case $target in
    xtensa*-linux-user)
      # the toolchain is not complete with headers, only build system tests
      continue
      ;;
    *-softmmu)
      test -f "$source_path/tests/tcg/$arch/Makefile.softmmu-target" || continue
      qemu="qemu-system-$arch"
      ;;
    *-linux-user|*-bsd-user)
      qemu="qemu-$arch"
      ;;
  esac

  if probe_target_compiler $target || test -n "$container_image"; then
      test -n "$container_image" && build_static=y
      mkdir -p "tests/tcg/$target"
      config_target_mak=tests/tcg/$target/config-target.mak
      ln -sf "$source_path/tests/tcg/Makefile.target" "tests/tcg/$target/Makefile"
      echo "# Automatically generated by configure - do not modify" > "$config_target_mak"
      echo "TARGET_NAME=$arch" >> "$config_target_mak"
      echo "TARGET=$target" >> "$config_target_mak"
      write_target_makefile "build-tcg-tests-$target" >> "$config_target_mak"
      echo "BUILD_STATIC=$build_static" >> "$config_target_mak"
      echo "QEMU=$PWD/$qemu" >> "$config_target_mak"

      # will GDB work with these binaries?
      if test "${gdb_arches#*$arch}" != "$gdb_arches"; then
          echo "GDB=$gdb_bin" >> $config_target_mak
      fi

      if test "${gdb_arches#*aarch64}" != "$gdb_arches" && version_ge $gdb_version 15.1; then
          echo "GDB_HAS_MTE=y" >> $config_target_mak
      fi

      if test "${gdb_arches#*aarch64}" != "$gdb_arches" && version_ge $gdb_version 16.0; then
          # GDB has to support MTE in baremetal to allow debugging MTE in QEMU system mode
          echo "GDB_SUPPORTS_MTE_IN_BAREMETAL=y" >> $config_target_mak
      fi

      echo "run-tcg-tests-$target: $qemu\$(EXESUF)" >> Makefile.prereqs
      tcg_tests_targets="$tcg_tests_targets $target"
  fi
done

if test "$tcg" = "enabled"; then
    echo "TCG_TESTS_TARGETS=$tcg_tests_targets" >> $config_host_mak
fi

if test "$skip_meson" = no; then
  cross="config-meson.cross.new"
  meson_quote() {
    test $# = 0 && return
    echo "'$(echo $* | sed "s/ /','/g")'"
  }

  echo "# Automatically generated by configure - do not modify" > $cross
  echo "[properties]" >> $cross

  # unroll any custom device configs
  for a in $device_archs; do
      eval "c=\$devices_${a}"
      echo "${a}-softmmu = '$c'" >> $cross
  done

  echo "[built-in options]" >> $cross
  echo "c_args = [$(meson_quote $CFLAGS $EXTRA_CFLAGS)]" >> $cross
  echo "cpp_args = [$(meson_quote $CXXFLAGS $EXTRA_CXXFLAGS)]" >> $cross
  test -n "$objcc" && echo "objc_args = [$(meson_quote $OBJCFLAGS $EXTRA_OBJCFLAGS)]" >> $cross
  echo "c_link_args = [$(meson_quote $CFLAGS $LDFLAGS $EXTRA_CFLAGS $EXTRA_LDFLAGS)]" >> $cross
  echo "cpp_link_args = [$(meson_quote $CXXFLAGS $LDFLAGS $EXTRA_CXXFLAGS $EXTRA_LDFLAGS)]" >> $cross

  # Only enable by default for git builds and on select OSes
  echo "# environment defaults, can still be overridden on " >> $cross
  echo "# the command line" >> $cross
  if test -e "$source_path/.git" && \
      { test "$host_os" = linux || test "$host_os" = "windows"; }; then
      echo 'werror = true' >> $cross
  fi
  echo "[project options]" >> $cross
  if test "$SMBD" != ''; then
    echo "smbd = $(meson_quote "$SMBD")" >> $cross
  fi
  if test "${QEMU_GA_MANUFACTURER}" != ''; then
    echo "qemu_ga_manufacturer = $(meson_quote "${QEMU_GA_MANUFACTURER}")" >> $cross
  fi
  if test "${QEMU_GA_DISTRO}" != ''; then
    echo "qemu_ga_distro = $(meson_quote "${QEMU_GA_DISTRO}")" >> $cross
  fi
  if test "${QEMU_GA_VERSION}" != ''; then
    echo "qemu_ga_version = $(meson_quote "${QEMU_GA_VERSION}")" >> $cross
  fi

  echo >> $cross
  echo "[binaries]" >> $cross
  echo "c = [$(meson_quote $cc $CPU_CFLAGS)]" >> $cross
  test -n "$cxx" && echo "cpp = [$(meson_quote $cxx $CPU_CFLAGS)]" >> $cross
  test -n "$objcc" && echo "objc = [$(meson_quote $objcc $CPU_CFLAGS)]" >> $cross
  if test "$rust" != disabled; then
    if test "$rust_host_triple" != "$rust_target_triple"; then
      echo "rust = [$(meson_quote $rustc --target "$rust_target_triple")]" >> $cross
    else
      echo "rust = [$(meson_quote $rustc)]" >> $cross
    fi
  fi
  echo "ar = [$(meson_quote $ar)]" >> $cross
  echo "dlltool = [$(meson_quote $dlltool)]" >> $cross
  echo "nm = [$(meson_quote $nm)]" >> $cross
  echo "pkgconfig = [$(meson_quote $pkg_config)]" >> $cross
  echo "pkg-config = [$(meson_quote $pkg_config)]" >> $cross
  echo "ranlib = [$(meson_quote $ranlib)]" >> $cross
  echo "readelf = [$(meson_quote $readelf)]" >> $cross
  if has $sdl2_config; then
    echo "sdl2-config = [$(meson_quote $sdl2_config)]" >> $cross
  fi
  echo "strip = [$(meson_quote $strip)]" >> $cross
  echo "widl = [$(meson_quote $widl)]" >> $cross
  echo "windres = [$(meson_quote $windres)]" >> $cross
  echo "windmc = [$(meson_quote $windmc)]" >> $cross
  if test "$cross_compile" = "yes"; then
    echo "[host_machine]" >> $cross
    echo "system = '$host_os'" >> $cross
    case "$cpu" in
        i386)
            echo "cpu_family = 'x86'" >> $cross
            ;;
        *)
            echo "cpu_family = '$cpu'" >> $cross
            ;;
    esac
    echo "cpu = '$cpu'" >> $cross
    if test "$bigendian" = "yes" ; then
        echo "endian = 'big'" >> $cross
    else
        echo "endian = 'little'" >> $cross
    fi

    native="config-meson.native.new"
    echo "# Automatically generated by configure - do not modify" > $native
    echo "[binaries]" >> $native
    echo "c = [$(meson_quote $host_cc)]" >> $native
    if test "$rust" != disabled; then
      echo "rust = [$(meson_quote $rustc)]" >> $cross
    fi
    mv $native config-meson.native
    meson_option_add --native-file
    meson_option_add config-meson.native
  fi
  mv $cross config-meson.cross
  meson_add_machine_file config-meson.cross
  if test -f "$source_path/configs/meson/$host_os.txt"; then
    meson_add_machine_file $source_path/configs/meson/$host_os.txt
  fi

  rm -rf meson-private meson-info meson-logs

  test "$download" = "disabled" && meson_option_add "--wrap-mode=nodownload"
  test "$default_feature" = no && meson_option_add -Dauto_features=disabled
  test "$static" = yes && meson_option_add -Dprefer_static=true
  test "$pie" = no && meson_option_add -Db_pie=false

  # QEMU options
  test "$rust" != "disabled" && meson_option_add "-Drust=$rust"
  test "$cfi" != false && meson_option_add "-Dcfi=$cfi" "-Db_lto=$cfi"
  test "$docs" != auto && meson_option_add "-Ddocs=$docs"
  test -n "${LIB_FUZZING_ENGINE+xxx}" && meson_option_add "-Dfuzzing_engine=$LIB_FUZZING_ENGINE"
  test "$plugins" = yes && meson_option_add "-Dplugins=true"
  test "$tcg" != enabled && meson_option_add "-Dtcg=$tcg"
  run_meson() {
    NINJA=$ninja $meson setup "$@" "$PWD" "$source_path"
  }
  eval run_meson $meson_options
  if test "$?" -ne 0 ; then
      error_exit "meson setup failed"
  fi
  echo "$meson" > build.ninja.stamp
else
  if test -f meson-private/cmd_line.txt; then
    # Adjust old command line options that were removed
    # sed -i is not portable
    perl -i -ne '
      /^sphinx_build/ && next;
      print;' meson-private/cmd_line.txt
  fi
fi

# Save the configure command line for later reuse.
cat <<EOD >config.status
#!/bin/sh
# Generated by configure.
# Run this file to recreate the current configuration.
# Compiler output produced by configure, useful for debugging
# configure, is in config.log if it exists.
EOD

preserve_env() {
    envname=$1

    eval envval=\$$envname

    if test -n "$envval"
    then
	echo "$envname='$envval'" >> config.status
	echo "export $envname" >> config.status
    else
	echo "unset $envname" >> config.status
    fi
}

# Preserve various env variables that influence what
# features/build target configure will detect
preserve_env AR
preserve_env AS
preserve_env CC
preserve_env CFLAGS
preserve_env CXX
preserve_env CXXFLAGS
preserve_env DLLTOOL
preserve_env LD
preserve_env LDFLAGS
preserve_env LD_LIBRARY_PATH
preserve_env NM
preserve_env OBJCFLAGS
preserve_env OBJCOPY
preserve_env PATH
preserve_env PKG_CONFIG
preserve_env PKG_CONFIG_LIBDIR
preserve_env PKG_CONFIG_PATH
preserve_env PYTHON
preserve_env QEMU_GA_MANUFACTURER
preserve_env QEMU_GA_DISTRO
preserve_env QEMU_GA_VERSION
preserve_env SDL2_CONFIG
preserve_env SMBD
preserve_env STRIP
preserve_env WIDL
preserve_env WINDRES
preserve_env WINDMC

printf "exec" >>config.status
for i in "$0" "$@"; do
  test "$i" = --skip-meson || printf " %s" "$(quote_sh "$i")" >>config.status
done
echo ' "$@"' >>config.status
chmod +x config.status

rm -r "$TMPDIR1"

if test "$rust" != disabled; then
  echo
  echo 'INFO: Rust bindings generation with `bindgen` might fail in some cases where'
  echo 'the detected `libclang` does not match the expected `clang` version/target. In'
  echo 'this case you must pass the path to `clang` and `libclang` to your build'
  echo 'command invocation using the environment variables CLANG_PATH and LIBCLANG_PATH'
fi
