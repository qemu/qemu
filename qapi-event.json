##
# @SHUTDOWN
#
# Emitted when the virtual machine has shutdown, possibly indicating that QEMU
# is about about to exit.
#
# Note: If the command-line option "-no-shutdown" has been specified, qemu will
# not exit, and a STOP event will eventually follow the SHUTDOWN event
#
# Since: 0.12.0
##
{ 'event': 'SHUTDOWN' }

##
# @POWERDOWN
#
# Emitted when the virtual machine is powered down through the power control
# system, such as via ACPI.
#
# Since: 0.12.0
##
{ 'event': 'POWERDOWN' }

##
# @RESET
#
# Emitted when the virtual machine is reset
#
# Since: 0.12.0
##
{ 'event': 'RESET' }

##
# @STOP
#
# Emitted when the virtual machine is stopped
#
# Since: 0.12.0
##
{ 'event': 'STOP' }

##
# @RESUME
#
# Emitted when the virtual machine resumes execution
#
# Since: 0.12.0
##
{ 'event': 'RESUME' }

##
# @SUSPEND
#
# Emitted when guest enters a hardware suspension state, for example, S3 state,
# which is sometimes called standby state
#
# Since: 1.1
##
{ 'event': 'SUSPEND' }

##
# @SUSPEND_DISK
#
# Emitted when guest enters a hardware suspension state with data saved on
# disk, for example, S4 state, which is sometimes called hibernate state
#
# Note: QEMU shuts down (similar to event @SHUTDOWN) when entering this state
#
# Since: 1.2
##
{ 'event': 'SUSPEND_DISK' }

##
# @WAKEUP
#
# Emitted when the guest has woken up from suspend state and is running
#
# Since: 1.1
##
{ 'event': 'WAKEUP' }

##
# @RTC_CHANGE
#
# Emitted when the guest changes the RTC time.
#
# @offset: offset between base RTC clock (as specified by -rtc base), and
#          new RTC clock value
#
# Since: 0.13.0
##
{ 'event': 'RTC_CHANGE',
  'data': { 'offset': 'int' } }

##
# @WATCHDOG
#
# Emitted when the watchdog device's timer is expired
#
# @action: action that has been taken
#
# Note: If action is "reset", "shutdown", or "pause" the WATCHDOG event is
# followed respectively by the RESET, SHUTDOWN, or STOP events
#
# Since: 0.13.0
##
{ 'event': 'WATCHDOG',
  'data': { 'action': 'WatchdogExpirationAction' } }

##
# @DEVICE_DELETED
#
# Emitted whenever the device removal completion is acknowledged by the guest.
# At this point, it's safe to reuse the specified device ID. Device removal can
# be initiated by the guest or by HMP/QMP commands.
#
# @device: #optional, device name
#
# @path: device path
#
# Since: 1.5
##
{ 'event': 'DEVICE_DELETED',
  'data': { '*device': 'str', 'path': 'str' } }

##
# @NIC_RX_FILTER_CHANGED
#
# Emitted once until the 'query-rx-filter' command is executed, the first event
# will always be emitted
#
# @name: #optional, net client name
#
# @path: device path
#
# Since: 1.6
##
{ 'event': 'NIC_RX_FILTER_CHANGED',
  'data': { '*name': 'str', 'path': 'str' } }

##
# @VNC_CONNECTED
#
# Emitted when a VNC client establishes a connection
#
# @server: server information
#
# @client: client information
#
# Note: This event is emitted before any authentication takes place, thus
# the authentication ID is not provided
#
# Since: 0.13.0
##
{ 'event': 'VNC_CONNECTED',
  'data': { 'server': 'VncServerInfo',
            'client': 'VncBasicInfo' } }

##
# @VNC_INITIALIZED
#
# Emitted after authentication takes place (if any) and the VNC session is
# made active
#
# @server: server information
#
# @client: client information
#
# Since: 0.13.0
##
{ 'event': 'VNC_INITIALIZED',
  'data': { 'server': 'VncServerInfo',
            'client': 'VncClientInfo' } }

##
# @VNC_DISCONNECTED
#
# Emitted when the connection is closed
#
# @server: server information
#
# @client: client information
#
# Since: 0.13.0
##
{ 'event': 'VNC_DISCONNECTED',
  'data': { 'server': 'VncServerInfo',
            'client': 'VncClientInfo' } }
