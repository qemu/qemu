#!/usr/bin/env python3
# group: rw
#
# Test cases for the QMP 'x-blockdev-reopen' command
#
# Copyright (C) 2018-2019 Igalia, S.L.
# Author: Alberto Garcia <berto@igalia.com>
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#

import os
import re
import iotests
import copy
import json
from iotests import qemu_img, qemu_io

hd_path = [
    os.path.join(iotests.test_dir, 'hd0.img'),
    os.path.join(iotests.test_dir, 'hd1.img'),
    os.path.join(iotests.test_dir, 'hd2.img')
]

def hd_opts(idx):
    return {'driver': iotests.imgfmt,
            'node-name': 'hd%d' % idx,
            'file': {'driver': 'file',
                     'node-name': 'hd%d-file' % idx,
                     'filename':  hd_path[idx] } }

class TestBlockdevReopen(iotests.QMPTestCase):
    total_io_cmds = 0

    def setUp(self):
        qemu_img('create', '-f', iotests.imgfmt, hd_path[0], '3M')
        qemu_img('create', '-f', iotests.imgfmt, '-b', hd_path[0],
                 '-F', iotests.imgfmt, hd_path[1])
        qemu_img('create', '-f', iotests.imgfmt, hd_path[2], '3M')
        qemu_io('-f', iotests.imgfmt, '-c', 'write -P 0xa0  0 1M', hd_path[0])
        qemu_io('-f', iotests.imgfmt, '-c', 'write -P 0xa1 1M 1M', hd_path[1])
        qemu_io('-f', iotests.imgfmt, '-c', 'write -P 0xa2 2M 1M', hd_path[2])
        self.vm = iotests.VM()
        self.vm.launch()

    def tearDown(self):
        self.vm.shutdown()
        self.check_qemu_io_errors()
        os.remove(hd_path[0])
        os.remove(hd_path[1])
        os.remove(hd_path[2])

    # The output of qemu-io is not returned by vm.hmp_qemu_io() but
    # it's stored in the log and can only be read when the VM has been
    # shut down. This function runs qemu-io and keeps track of the
    # number of times it's been called.
    def run_qemu_io(self, img, cmd):
        result = self.vm.hmp_qemu_io(img, cmd)
        self.assert_qmp(result, 'return', '')
        self.total_io_cmds += 1

    # Once the VM is shut down we can parse the log and see if qemu-io
    # ran without errors.
    def check_qemu_io_errors(self):
        self.assertFalse(self.vm.is_running())
        found = 0
        log = self.vm.get_log()
        for line in log.split("\n"):
            if line.startswith("Pattern verification failed"):
                raise Exception("%s (command #%d)" % (line, found))
            if re.match("read .*/.* bytes at offset", line):
                found += 1
        self.assertEqual(found, self.total_io_cmds,
                         "Expected output of %d qemu-io commands, found %d" %
                         (found, self.total_io_cmds))

    # Run x-blockdev-reopen with 'opts' but applying 'newopts'
    # on top of it. The original 'opts' dict is unmodified
    def reopen(self, opts, newopts = {}, errmsg = None):
        opts = copy.deepcopy(opts)

        # Apply the changes from 'newopts' on top of 'opts'
        for key in newopts:
            value = newopts[key]
            # If key has the form "foo.bar" then we need to do
            # opts["foo"]["bar"] = value, not opts["foo.bar"] = value
            subdict = opts
            while key.find('.') != -1:
                [prefix, key] = key.split('.', 1)
                subdict = opts[prefix]
            subdict[key] = value

        result = self.vm.qmp('x-blockdev-reopen', conv_keys = False, **opts)
        if errmsg:
            self.assert_qmp(result, 'error/class', 'GenericError')
            self.assert_qmp(result, 'error/desc', errmsg)
        else:
            self.assert_qmp(result, 'return', {})


    # Run query-named-block-nodes and return the specified entry
    def get_node(self, node_name):
        result = self.vm.qmp('query-named-block-nodes')
        for node in result['return']:
            if node['node-name'] == node_name:
                return node
        return None

    # Run 'query-named-block-nodes' and compare its output with the
    # value passed by the user in 'graph'
    def check_node_graph(self, graph):
        result = self.vm.qmp('query-named-block-nodes')
        self.assertEqual(json.dumps(graph,  sort_keys=True),
                         json.dumps(result, sort_keys=True))

    # This test opens one single disk image (without backing files)
    # and tries to reopen it with illegal / incorrect parameters.
    def test_incorrect_parameters_single_file(self):
        # Open 'hd0' only (no backing files)
        opts = hd_opts(0)
        result = self.vm.qmp('blockdev-add', conv_keys = False, **opts)
        self.assert_qmp(result, 'return', {})
        original_graph = self.vm.qmp('query-named-block-nodes')

        # We can reopen the image passing the same options
        self.reopen(opts)

        # We can also reopen passing a child reference in 'file'
        self.reopen(opts, {'file': 'hd0-file'})

        # We cannot change any of these
        self.reopen(opts, {'node-name': 'not-found'}, "Cannot find node named 'not-found'")
        self.reopen(opts, {'node-name': ''}, "Cannot find node named ''")
        self.reopen(opts, {'node-name': None}, "Invalid parameter type for 'node-name', expected: string")
        self.reopen(opts, {'driver': 'raw'}, "Cannot change the option 'driver'")
        self.reopen(opts, {'driver': ''}, "Invalid parameter ''")
        self.reopen(opts, {'driver': None}, "Invalid parameter type for 'driver', expected: string")
        self.reopen(opts, {'file': 'not-found'}, "Cannot change the option 'file'")
        self.reopen(opts, {'file': ''}, "Cannot change the option 'file'")
        self.reopen(opts, {'file': None}, "Invalid parameter type for 'file', expected: BlockdevRef")
        self.reopen(opts, {'file.node-name': 'newname'}, "Cannot change the option 'node-name'")
        self.reopen(opts, {'file.driver': 'host_device'}, "Cannot change the option 'driver'")
        self.reopen(opts, {'file.filename': hd_path[1]}, "Cannot change the option 'filename'")
        self.reopen(opts, {'file.aio': 'native'}, "Cannot change the option 'aio'")
        self.reopen(opts, {'file.locking': 'off'}, "Cannot change the option 'locking'")
        self.reopen(opts, {'file.filename': None}, "Invalid parameter type for 'file.filename', expected: string")

        # node-name is optional in BlockdevOptions, but x-blockdev-reopen needs it
        del opts['node-name']
        self.reopen(opts, {}, "Node name not specified")

        # Check that nothing has changed
        self.check_node_graph(original_graph)

        # Remove the node
        result = self.vm.qmp('blockdev-del', conv_keys = True, node_name = 'hd0')
        self.assert_qmp(result, 'return', {})

    # This test opens an image with a backing file and tries to reopen
    # it with illegal / incorrect parameters.
    def test_incorrect_parameters_backing_file(self):
        # Open hd1 omitting the backing options (hd0 will be opened
        # with the default options)
        opts = hd_opts(1)
        result = self.vm.qmp('blockdev-add', conv_keys = False, **opts)
        self.assert_qmp(result, 'return', {})
        original_graph = self.vm.qmp('query-named-block-nodes')

        # We can't reopen the image passing the same options, 'backing' is mandatory
        self.reopen(opts, {}, "backing is missing for 'hd1'")

        # Everything works if we pass 'backing' using the existing node name
        for node in original_graph['return']:
            if node['drv'] == iotests.imgfmt and node['file'] == hd_path[0]:
                backing_node_name = node['node-name']
        self.reopen(opts, {'backing': backing_node_name})

        # We can't use a non-existing or empty (non-NULL) node as the backing image
        self.reopen(opts, {'backing': 'not-found'}, "Cannot find device= nor node_name=not-found")
        self.reopen(opts, {'backing': ''}, "Cannot find device= nor node_name=")

        # We can reopen the image just fine if we specify the backing options
        opts['backing'] = {'driver': iotests.imgfmt,
                           'file': {'driver': 'file',
                                    'filename': hd_path[0]}}
        self.reopen(opts)

        # We cannot change any of these options
        self.reopen(opts, {'backing.node-name': 'newname'}, "Cannot change the option 'node-name'")
        self.reopen(opts, {'backing.driver': 'raw'}, "Cannot change the option 'driver'")
        self.reopen(opts, {'backing.file.node-name': 'newname'}, "Cannot change the option 'node-name'")
        self.reopen(opts, {'backing.file.driver': 'host_device'}, "Cannot change the option 'driver'")

        # Check that nothing has changed since the beginning
        self.check_node_graph(original_graph)

        # Remove the node
        result = self.vm.qmp('blockdev-del', conv_keys = True, node_name = 'hd1')
        self.assert_qmp(result, 'return', {})

    # Reopen an image several times changing some of its options
    def test_reopen(self):
        # Check whether the filesystem supports O_DIRECT
        if 'O_DIRECT' in qemu_io('-f', 'raw', '-t', 'none', '-c', 'quit', hd_path[0]):
            supports_direct = False
        else:
            supports_direct = True

        # Open the hd1 image passing all backing options
        opts = hd_opts(1)
        opts['backing'] = hd_opts(0)
        result = self.vm.qmp('blockdev-add', conv_keys = False, **opts)
        self.assert_qmp(result, 'return', {})
        original_graph = self.vm.qmp('query-named-block-nodes')

        # We can reopen the image passing the same options
        self.reopen(opts)

        # Reopen in read-only mode
        self.assert_qmp(self.get_node('hd1'), 'ro', False)

        self.reopen(opts, {'read-only': True})
        self.assert_qmp(self.get_node('hd1'), 'ro', True)
        self.reopen(opts)
        self.assert_qmp(self.get_node('hd1'), 'ro', False)

        # Change the cache options
        self.assert_qmp(self.get_node('hd1'), 'cache/writeback', True)
        self.assert_qmp(self.get_node('hd1'), 'cache/direct', False)
        self.assert_qmp(self.get_node('hd1'), 'cache/no-flush', False)
        self.reopen(opts, {'cache': { 'direct': supports_direct, 'no-flush': True }})
        self.assert_qmp(self.get_node('hd1'), 'cache/writeback', True)
        self.assert_qmp(self.get_node('hd1'), 'cache/direct', supports_direct)
        self.assert_qmp(self.get_node('hd1'), 'cache/no-flush', True)

        # Reopen again with the original options
        self.reopen(opts)
        self.assert_qmp(self.get_node('hd1'), 'cache/writeback', True)
        self.assert_qmp(self.get_node('hd1'), 'cache/direct', False)
        self.assert_qmp(self.get_node('hd1'), 'cache/no-flush', False)

        # Change 'detect-zeroes' and 'discard'
        self.assert_qmp(self.get_node('hd1'), 'detect_zeroes', 'off')
        self.reopen(opts, {'detect-zeroes': 'on'})
        self.assert_qmp(self.get_node('hd1'), 'detect_zeroes', 'on')
        self.reopen(opts, {'detect-zeroes': 'unmap'},
                    "setting detect-zeroes to unmap is not allowed " +
                    "without setting discard operation to unmap")
        self.assert_qmp(self.get_node('hd1'), 'detect_zeroes', 'on')
        self.reopen(opts, {'detect-zeroes': 'unmap', 'discard': 'unmap'})
        self.assert_qmp(self.get_node('hd1'), 'detect_zeroes', 'unmap')
        self.reopen(opts)
        self.assert_qmp(self.get_node('hd1'), 'detect_zeroes', 'off')

        # Changing 'force-share' is currently not supported
        self.reopen(opts, {'force-share': True}, "Cannot change the option 'force-share'")

        # Change some qcow2-specific options
        # No way to test for success other than checking the return message
        if iotests.imgfmt == 'qcow2':
            self.reopen(opts, {'l2-cache-entry-size': 128 * 1024},
                        "L2 cache entry size must be a power of two "+
                        "between 512 and the cluster size (65536)")
            self.reopen(opts, {'l2-cache-size': 1024 * 1024,
                               'cache-size':     512 * 1024},
                        "l2-cache-size may not exceed cache-size")
            self.reopen(opts, {'l2-cache-size':        4 * 1024 * 1024,
                               'refcount-cache-size':  4 * 1024 * 1024,
                               'l2-cache-entry-size': 32 * 1024})
            self.reopen(opts, {'pass-discard-request': True})

        # Check that nothing has changed since the beginning
        # (from the parameters that we can check)
        self.check_node_graph(original_graph)

        # Check that the node names (other than the top-level one) are optional
        del opts['file']['node-name']
        del opts['backing']['node-name']
        del opts['backing']['file']['node-name']
        self.reopen(opts)
        self.check_node_graph(original_graph)

        # Reopen setting backing = null, this removes the backing image from the chain
        self.reopen(opts, {'backing': None})
        self.assert_qmp_absent(self.get_node('hd1'), 'image/backing-image')

        # Open the 'hd0' image
        result = self.vm.qmp('blockdev-add', conv_keys = False, **hd_opts(0))
        self.assert_qmp(result, 'return', {})

        # Reopen the hd1 image setting 'hd0' as its backing image
        self.reopen(opts, {'backing': 'hd0'})
        self.assert_qmp(self.get_node('hd1'), 'image/backing-image/filename', hd_path[0])

        # Check that nothing has changed since the beginning
        self.reopen(hd_opts(0), {'read-only': True})
        self.check_node_graph(original_graph)

        # The backing file (hd0) is now a reference, we cannot change backing.* anymore
        self.reopen(opts, {}, "Cannot change the option 'backing.driver'")

        # We can't remove 'hd0' while it's a backing image of 'hd1'
        result = self.vm.qmp('blockdev-del', conv_keys = True, node_name = 'hd0')
        self.assert_qmp(result, 'error/class', 'GenericError')
        self.assert_qmp(result, 'error/desc', "Node 'hd0' is busy: node is used as backing hd of 'hd1'")

        # But we can remove both nodes if done in the proper order
        result = self.vm.qmp('blockdev-del', conv_keys = True, node_name = 'hd1')
        self.assert_qmp(result, 'return', {})
        result = self.vm.qmp('blockdev-del', conv_keys = True, node_name = 'hd0')
        self.assert_qmp(result, 'return', {})

    # Reopen a raw image and see the effect of changing the 'offset' option
    def test_reopen_raw(self):
        opts = {'driver': 'raw', 'node-name': 'hd0',
                'file': { 'driver': 'file',
                          'filename': hd_path[0],
                          'node-name': 'hd0-file' } }

        # First we create a 2MB raw file, and fill each half with a
        # different value
        qemu_img('create', '-f', 'raw', hd_path[0], '2M')
        qemu_io('-f', 'raw', '-c', 'write -P 0xa0  0 1M', hd_path[0])
        qemu_io('-f', 'raw', '-c', 'write -P 0xa1 1M 1M', hd_path[0])

        # Open the raw file with QEMU
        result = self.vm.qmp('blockdev-add', conv_keys = False, **opts)
        self.assert_qmp(result, 'return', {})

        # Read 1MB from offset 0
        self.run_qemu_io("hd0", "read -P 0xa0  0 1M")

        # Reopen the image with a 1MB offset.
        # Now the results are different
        self.reopen(opts, {'offset': 1024*1024})
        self.run_qemu_io("hd0", "read -P 0xa1  0 1M")

        # Reopen again with the original options.
        # We get the original results again
        self.reopen(opts)
        self.run_qemu_io("hd0", "read -P 0xa0  0 1M")

        # Remove the block device
        result = self.vm.qmp('blockdev-del', conv_keys = True, node_name = 'hd0')
        self.assert_qmp(result, 'return', {})

    # Omitting an option should reset it to the default value, but if
    # an option cannot be changed it shouldn't be possible to reset it
    # to its default value either
    def test_reset_default_values(self):
        opts = {'driver': 'qcow2', 'node-name': 'hd0',
                'file': { 'driver': 'file',
                          'filename': hd_path[0],
                          'x-check-cache-dropped': True, # This one can be changed
                          'locking': 'off',              # This one can NOT be changed
                          'node-name': 'hd0-file' } }

        # Open the file with QEMU
        result = self.vm.qmp('blockdev-add', conv_keys = False, **opts)
        self.assert_qmp(result, 'return', {})

        # file.x-check-cache-dropped can be changed...
        self.reopen(opts, { 'file.x-check-cache-dropped': False })
        # ...and dropped completely (resetting to the default value)
        del opts['file']['x-check-cache-dropped']
        self.reopen(opts)

        # file.locking cannot be changed nor reset to the default value
        self.reopen(opts, { 'file.locking': 'on' }, "Cannot change the option 'locking'")
        del opts['file']['locking']
        self.reopen(opts, {}, "Option 'locking' cannot be reset to its default value")
        # But we can reopen it if we maintain its previous value
        self.reopen(opts, { 'file.locking': 'off' })

        # Remove the block device
        result = self.vm.qmp('blockdev-del', conv_keys = True, node_name = 'hd0')
        self.assert_qmp(result, 'return', {})

    # This test modifies the node graph a few times by changing the
    # 'backing' option on reopen and verifies that the guest data that
    # is read afterwards is consistent with the graph changes.
    def test_io_with_graph_changes(self):
        opts = []

        # Open hd0, hd1 and hd2 without any backing image
        for i in range(3):
            opts.append(hd_opts(i))
            opts[i]['backing'] = None
            result = self.vm.qmp('blockdev-add', conv_keys = False, **opts[i])
            self.assert_qmp(result, 'return', {})

        # hd0
        self.run_qemu_io("hd0", "read -P 0xa0  0 1M")
        self.run_qemu_io("hd0", "read -P 0    1M 1M")
        self.run_qemu_io("hd0", "read -P 0    2M 1M")

        # hd1 <- hd0
        self.reopen(opts[0], {'backing': 'hd1'})

        self.run_qemu_io("hd0", "read -P 0xa0  0 1M")
        self.run_qemu_io("hd0", "read -P 0xa1 1M 1M")
        self.run_qemu_io("hd0", "read -P 0    2M 1M")

        # hd1 <- hd0 , hd1 <- hd2
        self.reopen(opts[2], {'backing': 'hd1'})

        self.run_qemu_io("hd2", "read -P 0     0 1M")
        self.run_qemu_io("hd2", "read -P 0xa1 1M 1M")
        self.run_qemu_io("hd2", "read -P 0xa2 2M 1M")

        # hd1 <- hd2 <- hd0
        self.reopen(opts[0], {'backing': 'hd2'})

        self.run_qemu_io("hd0", "read -P 0xa0  0 1M")
        self.run_qemu_io("hd0", "read -P 0xa1 1M 1M")
        self.run_qemu_io("hd0", "read -P 0xa2 2M 1M")

        # hd2 <- hd0
        self.reopen(opts[2], {'backing': None})

        self.run_qemu_io("hd0", "read -P 0xa0  0 1M")
        self.run_qemu_io("hd0", "read -P 0    1M 1M")
        self.run_qemu_io("hd0", "read -P 0xa2 2M 1M")

        # hd2 <- hd1 <- hd0
        self.reopen(opts[1], {'backing': 'hd2'})
        self.reopen(opts[0], {'backing': 'hd1'})

        self.run_qemu_io("hd0", "read -P 0xa0  0 1M")
        self.run_qemu_io("hd0", "read -P 0xa1 1M 1M")
        self.run_qemu_io("hd0", "read -P 0xa2 2M 1M")

        # Illegal operation: hd2 is a child of hd1
        self.reopen(opts[2], {'backing': 'hd1'},
                    "Making 'hd1' a backing file of 'hd2' would create a cycle")

        # hd2 <- hd0, hd2 <- hd1
        self.reopen(opts[0], {'backing': 'hd2'})

        self.run_qemu_io("hd1", "read -P 0     0 1M")
        self.run_qemu_io("hd1", "read -P 0xa1 1M 1M")
        self.run_qemu_io("hd1", "read -P 0xa2 2M 1M")

        # More illegal operations
        self.reopen(opts[2], {'backing': 'hd1'},
                    "Making 'hd1' a backing file of 'hd2' would create a cycle")
        self.reopen(opts[2], {'file': 'hd0-file'}, "Cannot change the option 'file'")

        result = self.vm.qmp('blockdev-del', conv_keys = True, node_name = 'hd2')
        self.assert_qmp(result, 'error/class', 'GenericError')
        self.assert_qmp(result, 'error/desc', "Node 'hd2' is busy: node is used as backing hd of 'hd0'")

        # hd1 doesn't have a backing file now
        self.reopen(opts[1], {'backing': None})

        self.run_qemu_io("hd1", "read -P 0     0 1M")
        self.run_qemu_io("hd1", "read -P 0xa1 1M 1M")
        self.run_qemu_io("hd1", "read -P 0    2M 1M")

        # We can't remove the 'backing' option if the image has a
        # default backing file
        del opts[1]['backing']
        self.reopen(opts[1], {}, "backing is missing for 'hd1'")

        self.run_qemu_io("hd1", "read -P 0     0 1M")
        self.run_qemu_io("hd1", "read -P 0xa1 1M 1M")
        self.run_qemu_io("hd1", "read -P 0    2M 1M")

    # This test verifies that we can't change the children of a block
    # device during a reopen operation in a way that would create
    # cycles in the node graph
    @iotests.skip_if_unsupported(['blkverify'])
    def test_graph_cycles(self):
        opts = []

        # Open all three images without backing file
        for i in range(3):
            opts.append(hd_opts(i))
            opts[i]['backing'] = None
            result = self.vm.qmp('blockdev-add', conv_keys = False, **opts[i])
            self.assert_qmp(result, 'return', {})

        # hd1 <- hd0, hd1 <- hd2
        self.reopen(opts[0], {'backing': 'hd1'})
        self.reopen(opts[2], {'backing': 'hd1'})

        # Illegal: hd2 is backed by hd1
        self.reopen(opts[1], {'backing': 'hd2'},
                    "Making 'hd2' a backing file of 'hd1' would create a cycle")

        # hd1 <- hd0 <- hd2
        self.reopen(opts[2], {'backing': 'hd0'})

        # Illegal: hd2 is backed by hd0, which is backed by hd1
        self.reopen(opts[1], {'backing': 'hd2'},
                    "Making 'hd2' a backing file of 'hd1' would create a cycle")

        # Illegal: hd1 cannot point to itself
        self.reopen(opts[1], {'backing': 'hd1'},
                    "Making 'hd1' a backing file of 'hd1' would create a cycle")

        # Remove all backing files
        self.reopen(opts[0])
        self.reopen(opts[2])

        ##########################################
        # Add a blkverify node using hd0 and hd1 #
        ##########################################
        bvopts = {'driver': 'blkverify',
                  'node-name': 'bv',
                  'test': 'hd0',
                  'raw': 'hd1'}
        result = self.vm.qmp('blockdev-add', conv_keys = False, **bvopts)
        self.assert_qmp(result, 'return', {})

        # blkverify doesn't currently allow reopening. TODO: implement this
        self.reopen(bvopts, {}, "Block format 'blkverify' used by node 'bv'" +
                    " does not support reopening files")

        # Illegal: hd0 is a child of the blkverify node
        self.reopen(opts[0], {'backing': 'bv'},
                    "Making 'bv' a backing file of 'hd0' would create a cycle")

        # Delete the blkverify node
        result = self.vm.qmp('blockdev-del', conv_keys = True, node_name = 'bv')
        self.assert_qmp(result, 'return', {})

    # Misc reopen tests with different block drivers
    @iotests.skip_if_unsupported(['quorum', 'throttle'])
    def test_misc_drivers(self):
        ####################
        ###### quorum ######
        ####################
        for i in range(3):
            opts = hd_opts(i)
            # Open all three images without backing file
            opts['backing'] = None
            result = self.vm.qmp('blockdev-add', conv_keys = False, **opts)
            self.assert_qmp(result, 'return', {})

        opts = {'driver': 'quorum',
                'node-name': 'quorum0',
                'children': ['hd0', 'hd1', 'hd2'],
                'vote-threshold': 2}
        result = self.vm.qmp('blockdev-add', conv_keys = False, **opts)
        self.assert_qmp(result, 'return', {})

        # Quorum doesn't currently allow reopening. TODO: implement this
        self.reopen(opts, {}, "Block format 'quorum' used by node 'quorum0'" +
                    " does not support reopening files")

        # You can't make quorum0 a backing file of hd0:
        # hd0 is already a child of quorum0.
        self.reopen(hd_opts(0), {'backing': 'quorum0'},
                    "Making 'quorum0' a backing file of 'hd0' would create a cycle")

        # Delete quorum0
        result = self.vm.qmp('blockdev-del', conv_keys = True, node_name = 'quorum0')
        self.assert_qmp(result, 'return', {})

        # Delete hd0, hd1 and hd2
        for i in range(3):
            result = self.vm.qmp('blockdev-del', conv_keys = True,
                                 node_name = 'hd%d' % i)
            self.assert_qmp(result, 'return', {})

        ######################
        ###### blkdebug ######
        ######################
        opts = {'driver': 'blkdebug',
                'node-name': 'bd',
                'config': '/dev/null',
                'image': hd_opts(0)}
        result = self.vm.qmp('blockdev-add', conv_keys = False, **opts)
        self.assert_qmp(result, 'return', {})

        # blkdebug allows reopening if we keep the same options
        self.reopen(opts)

        # but it currently does not allow changes
        self.reopen(opts, {'image': 'hd1'}, "Cannot change the option 'image'")
        self.reopen(opts, {'align': 33554432}, "Cannot change the option 'align'")
        self.reopen(opts, {'config': '/non/existent'}, "Cannot change the option 'config'")
        del opts['config']
        self.reopen(opts, {}, "Option 'config' cannot be reset to its default value")

        # Delete the blkdebug node
        result = self.vm.qmp('blockdev-del', conv_keys = True, node_name = 'bd')
        self.assert_qmp(result, 'return', {})

        ##################
        ###### null ######
        ##################
        opts = {'driver': 'null-co', 'node-name': 'root', 'size': 1024}

        result = self.vm.qmp('blockdev-add', conv_keys = False, **opts)
        self.assert_qmp(result, 'return', {})

        # 1 << 30 is the default value, but we cannot change it explicitly
        self.reopen(opts, {'size': (1 << 30)}, "Cannot change the option 'size'")

        # We cannot change 'size' back to its default value either
        del opts['size']
        self.reopen(opts, {}, "Option 'size' cannot be reset to its default value")

        result = self.vm.qmp('blockdev-del', conv_keys = True, node_name = 'root')
        self.assert_qmp(result, 'return', {})

        ##################
        ###### file ######
        ##################
        opts = hd_opts(0)
        opts['file']['locking'] = 'on'
        result = self.vm.qmp('blockdev-add', conv_keys = False, **opts)
        self.assert_qmp(result, 'return', {})

        # 'locking' cannot be changed
        del opts['file']['locking']
        self.reopen(opts, {'file.locking': 'on'})
        self.reopen(opts, {'file.locking': 'off'}, "Cannot change the option 'locking'")
        self.reopen(opts, {}, "Option 'locking' cannot be reset to its default value")

        # Trying to reopen the 'file' node directly does not make a difference
        opts = opts['file']
        self.reopen(opts, {'locking': 'on'})
        self.reopen(opts, {'locking': 'off'}, "Cannot change the option 'locking'")
        self.reopen(opts, {}, "Option 'locking' cannot be reset to its default value")

        result = self.vm.qmp('blockdev-del', conv_keys = True, node_name = 'hd0')
        self.assert_qmp(result, 'return', {})

        ######################
        ###### throttle ######
        ######################
        opts = { 'qom-type': 'throttle-group', 'id': 'group0',
                 'limits': { 'iops-total': 1000 } }
        result = self.vm.qmp('object-add', conv_keys = False, **opts)
        self.assert_qmp(result, 'return', {})

        opts = { 'qom-type': 'throttle-group', 'id': 'group1',
                 'limits': { 'iops-total': 2000 } }
        result = self.vm.qmp('object-add', conv_keys = False, **opts)
        self.assert_qmp(result, 'return', {})

        # Add a throttle filter with group = group0
        opts = { 'driver': 'throttle', 'node-name': 'throttle0',
                 'throttle-group': 'group0', 'file': hd_opts(0) }
        result = self.vm.qmp('blockdev-add', conv_keys = False, **opts)
        self.assert_qmp(result, 'return', {})

        # We can reopen it if we keep the same options
        self.reopen(opts)

        # We can also reopen if 'file' is a reference to the child
        self.reopen(opts, {'file': 'hd0'})

        # This is illegal
        self.reopen(opts, {'throttle-group': 'notfound'}, "Throttle group 'notfound' does not exist")

        # But it's possible to change the group to group1
        self.reopen(opts, {'throttle-group': 'group1'})

        # Now group1 is in use, it cannot be deleted
        result = self.vm.qmp('object-del', id = 'group1')
        self.assert_qmp(result, 'error/class', 'GenericError')
        self.assert_qmp(result, 'error/desc', "object 'group1' is in use, can not be deleted")

        # Default options, this switches the group back to group0
        self.reopen(opts)

        # So now we cannot delete group0
        result = self.vm.qmp('object-del', id = 'group0')
        self.assert_qmp(result, 'error/class', 'GenericError')
        self.assert_qmp(result, 'error/desc', "object 'group0' is in use, can not be deleted")

        # But group1 is free this time, and it can be deleted
        result = self.vm.qmp('object-del', id = 'group1')
        self.assert_qmp(result, 'return', {})

        # Let's delete the filter node
        result = self.vm.qmp('blockdev-del', conv_keys = True, node_name = 'throttle0')
        self.assert_qmp(result, 'return', {})

        # And we can finally get rid of group0
        result = self.vm.qmp('object-del', id = 'group0')
        self.assert_qmp(result, 'return', {})

    # If an image has a backing file then the 'backing' option must be
    # passed on reopen. We don't allow leaving the option out in this
    # case because it's unclear what the correct semantics would be.
    def test_missing_backing_options_1(self):
        # hd2
        opts = hd_opts(2)
        result = self.vm.qmp('blockdev-add', conv_keys = False, **opts)
        self.assert_qmp(result, 'return', {})

        # hd0
        opts = hd_opts(0)
        result = self.vm.qmp('blockdev-add', conv_keys = False, **opts)
        self.assert_qmp(result, 'return', {})

        # hd0 has no backing file: we can omit the 'backing' option
        self.reopen(opts)

        # hd2 <- hd0
        self.reopen(opts, {'backing': 'hd2'})

        # hd0 has a backing file: we must set the 'backing' option
        self.reopen(opts, {}, "backing is missing for 'hd0'")

        # hd2 can't be removed because it's the backing file of hd0
        result = self.vm.qmp('blockdev-del', conv_keys = True, node_name = 'hd2')
        self.assert_qmp(result, 'error/class', 'GenericError')
        self.assert_qmp(result, 'error/desc', "Node 'hd2' is busy: node is used as backing hd of 'hd0'")

        # Detach hd2 from hd0.
        self.reopen(opts, {'backing': None})

        # Without a backing file, we can omit 'backing' again
        self.reopen(opts)

        # Remove both hd0 and hd2
        result = self.vm.qmp('blockdev-del', conv_keys = True, node_name = 'hd0')
        self.assert_qmp(result, 'return', {})

        result = self.vm.qmp('blockdev-del', conv_keys = True, node_name = 'hd2')
        self.assert_qmp(result, 'return', {})

    # If an image has default backing file (as part of its metadata)
    # then the 'backing' option must be passed on reopen. We don't
    # allow leaving the option out in this case because it's unclear
    # what the correct semantics would be.
    def test_missing_backing_options_2(self):
        # hd0 <- hd1
        # (hd0 is hd1's default backing file)
        opts = hd_opts(1)
        result = self.vm.qmp('blockdev-add', conv_keys = False, **opts)
        self.assert_qmp(result, 'return', {})

        # hd1 has a backing file: we can't omit the 'backing' option
        self.reopen(opts, {}, "backing is missing for 'hd1'")

        # Let's detach the backing file
        self.reopen(opts, {'backing': None})

        # No backing file attached to hd1 now, but we still can't omit the 'backing' option
        self.reopen(opts, {}, "backing is missing for 'hd1'")

        result = self.vm.qmp('blockdev-del', conv_keys = True, node_name = 'hd1')
        self.assert_qmp(result, 'return', {})

    # Test that making 'backing' a reference to an existing child
    # keeps its current options
    def test_backing_reference(self):
        # hd2 <- hd1 <- hd0
        opts = hd_opts(0)
        opts['backing'] = hd_opts(1)
        opts['backing']['backing'] = hd_opts(2)
        # Enable 'detect-zeroes' on all three nodes
        opts['detect-zeroes'] = 'on'
        opts['backing']['detect-zeroes'] = 'on'
        opts['backing']['backing']['detect-zeroes'] = 'on'
        result = self.vm.qmp('blockdev-add', conv_keys = False, **opts)
        self.assert_qmp(result, 'return', {})

        # Reopen the chain passing the minimum amount of required options.
        # By making 'backing' a reference to hd1 (instead of a sub-dict)
        # we tell QEMU to keep its current set of options.
        opts = {'driver': iotests.imgfmt,
                'node-name': 'hd0',
                'file': 'hd0-file',
                'backing': 'hd1' }
        self.reopen(opts)

        # This has reset 'detect-zeroes' on hd0, but not on hd1 and hd2.
        self.assert_qmp(self.get_node('hd0'), 'detect_zeroes', 'off')
        self.assert_qmp(self.get_node('hd1'), 'detect_zeroes', 'on')
        self.assert_qmp(self.get_node('hd2'), 'detect_zeroes', 'on')

    # Test what happens if the graph changes due to other operations
    # such as block-stream
    def test_block_stream_1(self):
        # hd1 <- hd0
        opts = hd_opts(0)
        opts['backing'] = hd_opts(1)
        opts['backing']['backing'] = None
        result = self.vm.qmp('blockdev-add', conv_keys = False, **opts)
        self.assert_qmp(result, 'return', {})

        # Stream hd1 into hd0 and wait until it's done
        result = self.vm.qmp('block-stream', conv_keys = True, job_id = 'stream0', device = 'hd0')
        self.assert_qmp(result, 'return', {})
        self.wait_until_completed(drive = 'stream0')

        # Now we have only hd0
        self.assertEqual(self.get_node('hd1'), None)

        # We have backing.* options but there's no backing file anymore
        self.reopen(opts, {}, "Cannot change the option 'backing.driver'")

        # If we remove the 'backing' option then we can reopen hd0 just fine
        del opts['backing']
        self.reopen(opts)

        # We can also reopen hd0 if we set 'backing' to null
        self.reopen(opts, {'backing': None})

        result = self.vm.qmp('blockdev-del', conv_keys = True, node_name = 'hd0')
        self.assert_qmp(result, 'return', {})

    # Another block_stream test
    def test_block_stream_2(self):
        # hd2 <- hd1 <- hd0
        opts = hd_opts(0)
        opts['backing'] = hd_opts(1)
        opts['backing']['backing'] = hd_opts(2)
        result = self.vm.qmp('blockdev-add', conv_keys = False, **opts)
        self.assert_qmp(result, 'return', {})

        # Stream hd1 into hd0 and wait until it's done
        result = self.vm.qmp('block-stream', conv_keys = True, job_id = 'stream0',
                             device = 'hd0', base_node = 'hd2')
        self.assert_qmp(result, 'return', {})
        self.wait_until_completed(drive = 'stream0')

        # The chain is hd2 <- hd0 now. hd1 is missing
        self.assertEqual(self.get_node('hd1'), None)

        # The backing options in the dict were meant for hd1, but we cannot
        # use them with hd2 because hd1 had a backing file while hd2 does not.
        self.reopen(opts, {}, "Cannot change the option 'backing.driver'")

        # If we remove hd1's options from the dict then things work fine
        opts['backing'] = opts['backing']['backing']
        self.reopen(opts)

        # We can also reopen hd0 if we use a reference to the backing file
        self.reopen(opts, {'backing': 'hd2'})

        # But we cannot leave the option out
        del opts['backing']
        self.reopen(opts, {}, "backing is missing for 'hd0'")

        # Now we can delete hd0 (and hd2)
        result = self.vm.qmp('blockdev-del', conv_keys = True, node_name = 'hd0')
        self.assert_qmp(result, 'return', {})
        self.assertEqual(self.get_node('hd2'), None)

    # Reopen the chain during a block-stream job (from hd1 to hd0)
    def test_block_stream_3(self):
        # hd2 <- hd1 <- hd0
        opts = hd_opts(0)
        opts['backing'] = hd_opts(1)
        opts['backing']['backing'] = hd_opts(2)
        result = self.vm.qmp('blockdev-add', conv_keys = False, **opts)
        self.assert_qmp(result, 'return', {})

        # hd2 <- hd0
        result = self.vm.qmp('block-stream', conv_keys = True, job_id = 'stream0',
                             device = 'hd0', base_node = 'hd2',
                             auto_finalize = False)
        self.assert_qmp(result, 'return', {})

        # We can remove hd2 while the stream job is ongoing
        opts['backing']['backing'] = None
        self.reopen(opts, {})

        # We can't remove hd1 while the stream job is ongoing
        opts['backing'] = None
        self.reopen(opts, {}, "Cannot change 'backing' link from 'hd0' to 'hd1'")

        self.vm.run_job('stream0', auto_finalize = False, auto_dismiss = True)

    # Reopen the chain during a block-stream job (from hd2 to hd1)
    def test_block_stream_4(self):
        # hd2 <- hd1 <- hd0
        opts = hd_opts(0)
        opts['backing'] = hd_opts(1)
        opts['backing']['backing'] = hd_opts(2)
        result = self.vm.qmp('blockdev-add', conv_keys = False, **opts)
        self.assert_qmp(result, 'return', {})

        # hd1 <- hd0
        result = self.vm.qmp('block-stream', conv_keys = True, job_id = 'stream0',
                             device = 'hd1', filter_node_name='cor',
                             auto_finalize = False)
        self.assert_qmp(result, 'return', {})

        # We can't reopen with the original options because there is a filter
        # inserted by stream job above hd1.
        self.reopen(opts, {},
                    "Cannot change the option 'backing.backing.file.node-name'")

        # We can't reopen hd1 to read-only, as block-stream requires it to be
        # read-write
        self.reopen(opts['backing'], {'read-only': True},
                    "Cannot make block node read-only, there is a writer on it")

        # We can't remove hd2 while the stream job is ongoing
        opts['backing']['backing'] = None
        self.reopen(opts['backing'], {'read-only': False},
                    "Cannot change 'backing' link from 'hd1' to 'hd2'")

        # We can detach hd1 from hd0 because it doesn't affect the stream job
        opts['backing'] = None
        self.reopen(opts)

        self.vm.run_job('stream0', auto_finalize = False, auto_dismiss = True)

    # Reopen the chain during a block-commit job (from hd0 to hd2)
    def test_block_commit_1(self):
        # hd2 <- hd1 <- hd0
        opts = hd_opts(0)
        opts['backing'] = hd_opts(1)
        opts['backing']['backing'] = hd_opts(2)
        result = self.vm.qmp('blockdev-add', conv_keys = False, **opts)
        self.assert_qmp(result, 'return', {})

        result = self.vm.qmp('block-commit', conv_keys = True, job_id = 'commit0',
                             device = 'hd0')
        self.assert_qmp(result, 'return', {})

        # We can't remove hd2 while the commit job is ongoing
        opts['backing']['backing'] = None
        self.reopen(opts, {}, "Cannot change 'backing' link from 'hd1' to 'hd2'")

        # We can't remove hd1 while the commit job is ongoing
        opts['backing'] = None
        self.reopen(opts, {}, "Cannot change 'backing' link from 'hd0' to 'hd1'")

        event = self.vm.event_wait(name='BLOCK_JOB_READY')
        self.assert_qmp(event, 'data/device', 'commit0')
        self.assert_qmp(event, 'data/type', 'commit')
        self.assert_qmp_absent(event, 'data/error')

        result = self.vm.qmp('block-job-complete', device='commit0')
        self.assert_qmp(result, 'return', {})

        self.wait_until_completed(drive = 'commit0')

    # Reopen the chain during a block-commit job (from hd1 to hd2)
    def test_block_commit_2(self):
        # hd2 <- hd1 <- hd0
        opts = hd_opts(0)
        opts['backing'] = hd_opts(1)
        opts['backing']['backing'] = hd_opts(2)
        result = self.vm.qmp('blockdev-add', conv_keys = False, **opts)
        self.assert_qmp(result, 'return', {})

        result = self.vm.qmp('block-commit', conv_keys = True, job_id = 'commit0',
                             device = 'hd0', top_node = 'hd1',
                             auto_finalize = False)
        self.assert_qmp(result, 'return', {})

        # We can't remove hd2 while the commit job is ongoing
        opts['backing']['backing'] = None
        self.reopen(opts, {}, "Cannot change the option 'backing.driver'")

        # We can't remove hd1 while the commit job is ongoing
        opts['backing'] = None
        self.reopen(opts, {}, "Cannot change backing link if 'hd0' has an implicit backing file")

        # hd2 <- hd0
        self.vm.run_job('commit0', auto_finalize = False, auto_dismiss = True)

        self.assert_qmp(self.get_node('hd0'), 'ro', False)
        self.assertEqual(self.get_node('hd1'), None)
        self.assert_qmp(self.get_node('hd2'), 'ro', True)

    def run_test_iothreads(self, iothread_a, iothread_b, errmsg = None):
        opts = hd_opts(0)
        result = self.vm.qmp('blockdev-add', conv_keys = False, **opts)
        self.assert_qmp(result, 'return', {})

        opts2 = hd_opts(2)
        result = self.vm.qmp('blockdev-add', conv_keys = False, **opts2)
        self.assert_qmp(result, 'return', {})

        result = self.vm.qmp('object-add', qom_type='iothread', id='iothread0')
        self.assert_qmp(result, 'return', {})

        result = self.vm.qmp('object-add', qom_type='iothread', id='iothread1')
        self.assert_qmp(result, 'return', {})

        result = self.vm.qmp('device_add', driver='virtio-scsi', id='scsi0',
                             iothread=iothread_a)
        self.assert_qmp(result, 'return', {})

        result = self.vm.qmp('device_add', driver='virtio-scsi', id='scsi1',
                             iothread=iothread_b)
        self.assert_qmp(result, 'return', {})

        if iothread_a:
            result = self.vm.qmp('device_add', driver='scsi-hd', drive='hd0',
                                 share_rw=True, bus="scsi0.0")
            self.assert_qmp(result, 'return', {})

        if iothread_b:
            result = self.vm.qmp('device_add', driver='scsi-hd', drive='hd2',
                                 share_rw=True, bus="scsi1.0")
            self.assert_qmp(result, 'return', {})

        # Attaching the backing file may or may not work
        self.reopen(opts, {'backing': 'hd2'}, errmsg)

        # But removing the backing file should always work
        self.reopen(opts, {'backing': None})

        self.vm.shutdown()

    # We don't allow setting a backing file that uses a different AioContext if
    # neither of them can switch to the other AioContext
    def test_iothreads_error(self):
        self.run_test_iothreads('iothread0', 'iothread1',
                                "Cannot change iothread of active block backend")

    def test_iothreads_compatible_users(self):
        self.run_test_iothreads('iothread0', 'iothread0')

    def test_iothreads_switch_backing(self):
        self.run_test_iothreads('iothread0', None)

    def test_iothreads_switch_overlay(self):
        self.run_test_iothreads(None, 'iothread0')

if __name__ == '__main__':
    iotests.activate_logging()
    iotests.main(supported_fmts=["qcow2"],
                 supported_protocols=["file"])
