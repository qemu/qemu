#!/bin/bash
#
# qcow2 error path testing
#
# Copyright (C) 2010 Red Hat, Inc.
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#

# creator
owner=kwolf@redhat.com

seq=`basename $0`
echo "QA output created by $seq"

here=`pwd`
tmp=/tmp/$$
status=1	# failure is the default!

_cleanup()
{
	_cleanup_test_img
    rm "$TEST_DIR/blkdebug.conf"
}
trap "_cleanup; exit \$status" 0 1 2 3 15

# get standard environment, filters and checks
. ./common.rc
. ./common.filter
. ./common.pattern

# Currently only qcow2 supports rebasing
_supported_fmt qcow2
_supported_proto file
_supported_os Linux
_default_cache_mode "writethrough"
_supported_cache_modes "writethrough" "none"

echo "Errors while writing 128 kB"
echo

CLUSTER_SIZE=1024

BLKDBG_TEST_IMG="blkdebug:$TEST_DIR/blkdebug.conf:$TEST_IMG"

for event in \
    l1_update \
    \
    l2_load \
    l2_update \
    l2_alloc.write \
    \
    write_aio \
    \
    refblock_load \
    refblock_update_part \
    refblock_alloc \
    \
    cluster_alloc \

do

for errno in 5 28; do
for imm in off; do
for once in on off; do
for vmstate in "" "-b"; do

cat > "$TEST_DIR/blkdebug.conf" <<EOF
[inject-error]
event = "$event"
errno = "$errno"
immediately = "$imm"
once ="$once"
EOF

_make_test_img 1G

echo
echo "Event: $event; errno: $errno; imm: $imm; once: $once; write $vmstate"

# We want to catch a simple L2 update, not the allocation of the first L2 table
if [ "$event" == "l2_update" ]; then
    $QEMU_IO -c "write $vmstate 0 512" "$TEST_IMG" > /dev/null 2>&1
fi

$QEMU_IO -c "write $vmstate 0 128k " "$BLKDBG_TEST_IMG" | _filter_qemu_io

# l2_load is not called on allocation, so issue a second write
# Reads are another path to trigger l2_load, so do a read, too
if [ "$event" == "l2_load" ]; then
    $QEMU_IO -c "write $vmstate 0 128k " "$BLKDBG_TEST_IMG" | _filter_qemu_io
    $QEMU_IO -c "read $vmstate 0 128k " "$BLKDBG_TEST_IMG" | _filter_qemu_io
fi

_check_test_img 2>&1 | grep -v "refcount=1 reference=0"

done
done
done
done
done


echo
echo === Refcout table growth tests ===
echo
CLUSTER_SIZE=512


for event in \
    refblock_alloc.hookup \
    refblock_alloc.write \
    refblock_alloc.write_blocks \
    refblock_alloc.write_table \
    refblock_alloc.switch_table \

do

# This one takes a while, so let's test only one error code (ENOSPC should
# never be generated by qemu, so it's probably a good choice)
for errno in 28; do
for imm in off; do
for once in on off; do
for vmstate in "" "-b"; do

cat > "$TEST_DIR/blkdebug.conf" <<EOF
[inject-error]
event = "$event"
errno = "$errno"
immediately = "$imm"
once = "$once"
EOF

_make_test_img 1G

echo
echo "Event: $event; errno: $errno; imm: $imm; once: $once; write $vmstate"
$QEMU_IO -c "write $vmstate 0 64M" "$BLKDBG_TEST_IMG" | _filter_qemu_io

_check_test_img 2>&1 | grep -v "refcount=1 reference=0"

done
done
done
done
done

echo
echo === L1 growth tests ===
echo
CLUSTER_SIZE=1024


for event in \
    l1_grow.alloc_table \
    l1_grow.write_table \
    l1_grow.activate_table \

do

for errno in 5 28; do
for imm in off; do
for once in on off; do

cat > "$TEST_DIR/blkdebug.conf" <<EOF
[inject-error]
event = "$event"
errno = "$errno"
immediately = "$imm"
once = "$once"
EOF

_make_test_img 1G

echo
echo "Event: $event; errno: $errno; imm: $imm; once: $once"
$QEMU_IO -c "write -b 0 64k" "$BLKDBG_TEST_IMG" | _filter_qemu_io

_check_test_img 2>&1 | grep -v "refcount=1 reference=0"

done
done
done
done

# success, all done
echo "*** done"
rm -f $seq.full
status=0
