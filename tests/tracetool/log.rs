// SPDX-License-Identifier: GPL-2.0-or-later
// This file is @generated by tracetool, do not edit.

#[allow(unused_imports)]
use std::ffi::c_char;
#[allow(unused_imports)]
use util::bindings;

#[inline(always)]
fn trace_event_state_is_enabled(dstate: u16) -> bool {
    (unsafe { trace_events_enabled_count }) != 0 && dstate != 0
}

extern "C" {
    static mut trace_events_enabled_count: u32;
}
extern "C" {
    static mut _TRACE_TEST_BLAH_DSTATE: u16;
    static mut _TRACE_TEST_WIBBLE_DSTATE: u16;
}

#[inline(always)]
#[allow(dead_code)]
pub fn trace_test_blah(_context: *mut (), _filename: &std::ffi::CStr)
{
    if trace_event_state_is_enabled(unsafe { _TRACE_TEST_BLAH_DSTATE}) {
        let format_string = c"test_blah Blah context=%p filename=%s\n";
        if (unsafe { bindings::qemu_loglevel } & bindings::LOG_TRACE) != 0 {
            unsafe { bindings::qemu_log(format_string.as_ptr() as *const c_char, _context /* as *mut () */, _filename.as_ptr());}
        }
    }
}

#[inline(always)]
#[allow(dead_code)]
pub fn trace_test_wibble(_context: *mut (), _value: std::ffi::c_int)
{
    if trace_event_state_is_enabled(unsafe { _TRACE_TEST_WIBBLE_DSTATE}) {
        let format_string = c"test_wibble Wibble context=%p value=%d\n";
        if (unsafe { bindings::qemu_loglevel } & bindings::LOG_TRACE) != 0 {
            unsafe { bindings::qemu_log(format_string.as_ptr() as *const c_char, _context /* as *mut () */, _value /* as std::ffi::c_int */);}
        }
    }
}
