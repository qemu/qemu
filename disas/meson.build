libvixl_ss = ss.source_set()
subdir('libvixl')

common_ss.add(when: 'CONFIG_ALPHA_DIS', if_true: files('alpha.c'))
common_ss.add(when: 'CONFIG_ARM_A64_DIS', if_true: files('arm-a64.cc'))
common_ss.add_all(when: 'CONFIG_ARM_A64_DIS', if_true: libvixl_ss)
common_ss.add(when: 'CONFIG_ARM_DIS', if_true: files('arm.c'))
common_ss.add(when: 'CONFIG_CRIS_DIS', if_true: files('cris.c'))
common_ss.add(when: 'CONFIG_HPPA_DIS', if_true: files('hppa.c'))
common_ss.add(when: 'CONFIG_I386_DIS', if_true: files('i386.c'))
common_ss.add(when: 'CONFIG_LM32_DIS', if_true: files('lm32.c'))
common_ss.add(when: 'CONFIG_M68K_DIS', if_true: files('m68k.c'))
common_ss.add(when: 'CONFIG_MICROBLAZE_DIS', if_true: files('microblaze.c'))
common_ss.add(when: 'CONFIG_MIPS_DIS', if_true: files('mips.c'))
common_ss.add(when: 'CONFIG_MOXIE_DIS', if_true: files('moxie.c'))
common_ss.add(when: 'CONFIG_NANOMIPS_DIS', if_true: files('nanomips.cpp'))
common_ss.add(when: 'CONFIG_NIOS2_DIS', if_true: files('nios2.c'))
common_ss.add(when: 'CONFIG_PPC_DIS', if_true: files('ppc.c'))
common_ss.add(when: 'CONFIG_RISCV_DIS', if_true: files('riscv.c'))
common_ss.add(when: 'CONFIG_S390_DIS', if_true: files('s390.c'))
common_ss.add(when: 'CONFIG_SH4_DIS', if_true: files('sh4.c'))
common_ss.add(when: 'CONFIG_SPARC_DIS', if_true: files('sparc.c'))
common_ss.add(when: 'CONFIG_XTENSA_DIS', if_true: files('xtensa.c'))

# TODO: As long as the TCG interpreter and its generated code depend
# on the QEMU target, we cannot compile the disassembler here.
#common_ss.add(when: 'CONFIG_TCI_DIS', if_true: files('tci.c'))
