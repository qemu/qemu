stub_ss.add(files('bdrv-next-monitor-owned.c'))
stub_ss.add(files('blk-commit-all.c'))
stub_ss.add(files('blk-exp-close-all.c'))
stub_ss.add(files('blockdev-close-all-bdrv-states.c'))
stub_ss.add(files('change-state-handler.c'))
stub_ss.add(files('cmos.c'))
stub_ss.add(files('cpu-get-clock.c'))
stub_ss.add(files('cpus-get-virtual-clock.c'))
stub_ss.add(files('qemu-timer-notify-cb.c'))
stub_ss.add(files('icount.c'))
stub_ss.add(files('dump.c'))
stub_ss.add(files('error-printf.c'))
stub_ss.add(files('fdset.c'))
stub_ss.add(files('gdbstub.c'))
stub_ss.add(files('get-vm-name.c'))
if linux_io_uring.found()
  stub_ss.add(files('io_uring.c'))
endif
stub_ss.add(files('iothread-lock.c'))
if have_block
  stub_ss.add(files('iothread-lock-block.c'))
endif
stub_ss.add(files('isa-bus.c'))
stub_ss.add(files('is-daemonized.c'))
if libaio.found()
  stub_ss.add(files('linux-aio.c'))
endif
stub_ss.add(files('migr-blocker.c'))
stub_ss.add(files('module-opts.c'))
stub_ss.add(files('monitor.c'))
stub_ss.add(files('monitor-core.c'))
stub_ss.add(files('qemu-timer-notify-cb.c'))
stub_ss.add(files('qmp_memory_device.c'))
stub_ss.add(files('qmp-command-available.c'))
stub_ss.add(files('qmp-quit.c'))
stub_ss.add(files('qtest.c'))
stub_ss.add(files('ram-block.c'))
stub_ss.add(files('ramfb.c'))
stub_ss.add(files('replay.c'))
stub_ss.add(files('runstate-check.c'))
stub_ss.add(files('sysbus.c'))
stub_ss.add(files('target-get-monitor-def.c'))
stub_ss.add(files('target-monitor-defs.c'))
stub_ss.add(files('trace-control.c'))
stub_ss.add(files('uuid.c'))
stub_ss.add(files('vmgenid.c'))
stub_ss.add(files('vmstate.c'))
stub_ss.add(files('vm-stop.c'))
stub_ss.add(files('win32-kbd-hook.c'))
stub_ss.add(files('cpu-synchronize-state.c'))
if have_block
  stub_ss.add(files('replay-tools.c'))
endif
if have_system
  stub_ss.add(files('fw_cfg.c'))
  stub_ss.add(files('pci-bus.c'))
  stub_ss.add(files('semihost.c'))
  stub_ss.add(files('usb-dev-stub.c'))
  stub_ss.add(files('xen-hw-stub.c'))
else
  stub_ss.add(files('qdev.c'))
endif
