diff -ruN proll_18.orig/Makefile proll-patch7/Makefile
--- proll_18.orig/Makefile	2002-09-13 14:16:59.000000000 +0000
+++ proll-patch7/Makefile	2004-11-13 15:50:49.000000000 +0000
@@ -4,6 +4,7 @@
 	make -C krups-ser    all
 	make -C espresso     all
 	make -C espresso-ser all
+	make -C qemu all
 
 clean:
 	make -C mrcoffee clean
@@ -11,3 +12,4 @@
 	make -C krups-ser    clean
 	make -C espresso     clean
 	make -C espresso-ser clean
+	make -C qemu clean
diff -ruN proll_18.orig/qemu/Makefile proll-patch7/qemu/Makefile
--- proll_18.orig/qemu/Makefile	1970-01-01 00:00:00.000000000 +0000
+++ proll-patch7/qemu/Makefile	2005-03-02 16:41:50.000000000 +0000
@@ -0,0 +1,122 @@
+#
+# proll:
+# qemu/Makefile - make PROLL for QEMU
+# $Id: proll.patch,v 1.3 2005-03-13 09:43:36 bellard Exp $
+#
+# Copyright 1999 Pete Zaitcev
+# This is Free Software is licensed under terms of GNU General Public License.
+#
+
+CC = gcc
+
+#CROSS = /usr/local/sparc/bin/sparc-sun-linux-
+CROSS = sparc-unknown-linux-gnu-
+
+CROSSCC = $(CROSS)gcc
+CROSSLD = $(CROSS)ld
+CROSSNM = $(CROSS)nm
+
+RM = /bin/rm -f
+ELFTOAOUT = elftoaout
+
+#
+SRC = ../src
+
+# Due to remapping algorithm PROLBASE should be algned on PMD.
+# We make PROLBASE a define instead of using _start because we
+# want to shift it to form a PGD entry. A relocatable label will not work.
+# Linux kernel expects us to be at LINUX_OPPROM_BEGVM <asm-sparc/openprom.h>.
+PROLBASE =   0xffd00000
+PROLRODATA = 0xffd07000
+PROLDATA =   0xffd09000
+PROLSIZE = 240*1024
+
+# Linux
+# Fixed %g6 is for arch/sparc/kernel/head.S, it seems ok w/o -ffixed-g6.
+# Kernel uses -fcall-used-g5 -fcall-used-g7, we probably do not need them.
+# __ANSI__ is supposed to be on by default but it is not.
+CFLAGS = -O2 -Wall -DPROLBASE=$(PROLBASE) -DPROLDATA=$(PROLDATA) -DPROLRODATA=$(PROLRODATA) -D__ANSI__=1 -I$(SRC) -mcpu=hypersparc -g -DQEMU
+ASFLAGS = -D__ASSEMBLY__ -I$(SRC) -DPROLRODATA=$(PROLRODATA) -DPROLDATA=$(PROLDATA) -DPROLSIZE=$(PROLSIZE) -g
+# Solaris or Linux/i386 cross compilation
+#CFLAGS = -Iinclude -O
+
+LDFLAGS = -N -Ttext $(PROLBASE) --section-start .rodata=$(PROLRODATA) -Tdata $(PROLDATA) -Tbss $(PROLDATA)
+
+ALL = proll.aout
+PROLLEXE = proll.elf
+
+OBJS = head.o wuf.o wof.o main.o $(CONSOLE) \
+ printf.o le.o system_qemu.o iommu.o \
+ arp.o netinit.o bootp.o packet.o tftp.o udp.o sched_4m.o openprom.o \
+ vconsole.o hconsole.o rconsole.o vcons_zs.o
+
+all:           $(ALL)
+
+$(PROLLEXE):   $(OBJS)
+	$(CROSSLD) $(LDFLAGS) -o $(PROLLEXE) $(OBJS)
+
+head.o:         head.S $(SRC)/phys_jj.h \
+  $(SRC)/asi.h $(SRC)/psr.h $(SRC)/crs.h
+	$(CROSSCC) $(ASFLAGS) -DPROLBASE=$(PROLBASE) -o $*.o -c $*.S
+
+main.o:         main.c $(SRC)/asi.h $(SRC)/pgtsrmmu.h $(SRC)/iommu.h \
+  $(SRC)/phys_jj.h $(SRC)/vconsole.h $(SRC)/version.h $(SRC)/general.h \
+  $(SRC)/net.h $(SRC)/romlib.h $(SRC)/netpriv.h $(SRC)/arpa.h $(SRC)/system.h
+	$(CROSSCC) $(CFLAGS) -c $*.c
+openprom.o:	openprom.c $(SRC)/openprom.h $(SRC)/general.h $(SRC)/romlib.h \
+  $(SRC)/vconsole.h $(SRC)/system.h $(SRC)/phys_jj.h
+	$(CROSSCC) $(CFLAGS) -c $*.c
+
+system_qemu.o:       system_qemu.c $(SRC)/vconsole.h $(SRC)/pgtsrmmu.h \
+  $(SRC)/timer.h $(SRC)/general.h $(SRC)/net.h $(SRC)/romlib.h $(SRC)/asi.h \
+  $(SRC)/netpriv.h $(SRC)/arpa.h $(SRC)/system.h $(SRC)/crs.h
+	$(CROSSCC) $(CFLAGS) -c $*.c
+iommu.o:        $(SRC)/iommu.c $(SRC)/pgtsrmmu.h $(SRC)/phys_jj.h $(SRC)/iommu.h \
+ $(SRC)/vconsole.h $(SRC)/general.h $(SRC)/romlib.h $(SRC)/system.h $(SRC)/asi.h
+	$(CROSSCC) $(CFLAGS) -c $(SRC)/$*.c
+vconsole.o:	$(SRC)/vconsole.c $(SRC)/vconsole.h $(SRC)/hconsole.h
+	$(CROSSCC) $(CFLAGS) -c $(SRC)/$*.c
+vcons_zs.o:	$(SRC)/vcons_zs.c $(SRC)/vconsole.h $(SRC)/system.h
+	$(CROSSCC) $(CFLAGS) -c $(SRC)/$*.c
+hconsole.o:	$(SRC)/hconsole.c $(SRC)/hconsole.h $(SRC)/rconsole.h $(SRC)/phys_jj.h
+	$(CROSSCC) $(CFLAGS) -c $(SRC)/$*.c
+rconsole.o:	$(SRC)/rconsole.c $(SRC)/rconsole.h
+	$(CROSSCC) $(CFLAGS) -c $(SRC)/$*.c
+printf.o:       $(SRC)/printf.c
+	$(CROSSCC) $(CFLAGS) -c $(SRC)/$*.c
+le.o:		$(SRC)/le.c $(SRC)/dma.h $(SRC)/system.h $(SRC)/netpriv.h $(SRC)/romlib.h $(SRC)/general.h $(SRC)/net.h $(SRC)/phys_jj.h
+	$(CROSSCC) $(CFLAGS) -c $(SRC)/$*.c
+
+arp.o:		$(SRC)/arp.c $(SRC)/general.h $(SRC)/net.h $(SRC)/romlib.h $(SRC)/netpriv.h $(SRC)/arp.h
+	$(CROSSCC) $(CFLAGS) -c $(SRC)/$*.c
+netinit.o:	$(SRC)/netinit.c $(SRC)/general.h $(SRC)/net.h $(SRC)/romlib.h $(SRC)/netpriv.h $(SRC)/arp.h $(SRC)/ip.h $(SRC)/udp.h
+	$(CROSSCC) $(CFLAGS) -c $(SRC)/$*.c
+tftp.o:		$(SRC)/tftp.c $(SRC)/general.h $(SRC)/net.h $(SRC)/arpa.h $(SRC)/romlib.h $(SRC)/tftp.h
+	$(CROSSCC) $(CFLAGS) -c $(SRC)/$*.c
+udp.o:		$(SRC)/udp.c $(SRC)/general.h $(SRC)/net.h $(SRC)/romlib.h $(SRC)/netpriv.h $(SRC)/arp.h $(SRC)/ip.h $(SRC)/udp.h
+	$(CROSSCC) $(CFLAGS) -c $(SRC)/$*.c
+packet.o:	$(SRC)/packet.c $(SRC)/general.h $(SRC)/net.h $(SRC)/romlib.h $(SRC)/netpriv.h
+	$(CROSSCC) $(CFLAGS) -c $(SRC)/$*.c
+sched_4m.o:	$(SRC)/sched_4m.c $(SRC)/system.h $(SRC)/general.h $(SRC)/romlib.h $(SRC)/phys_jj.h
+	$(CROSSCC) $(CFLAGS) -c $(SRC)/$*.c
+bootp.o:	$(SRC)/bootp.c $(SRC)/general.h $(SRC)/net.h \
+  $(SRC)/arpa.h $(SRC)/romlib.h $(SRC)/system.h $(SRC)/bootp.h
+	$(CROSSCC) $(CFLAGS) -DNOBPEXT=1 -c $(SRC)/$*.c
+
+wuf.o:		$(SRC)/wuf.S
+	$(CROSSCC) $(ASFLAGS) -o $*.o -c $(SRC)/$*.S
+wof.o:		$(SRC)/wof.S
+	$(CROSSCC) $(ASFLAGS) -o $*.o -c $(SRC)/$*.S
+
+#genlab.o:      genlab.c
+#	$(CC) -c $*.c
+#
+#genlab:        genlab.o
+#	$(CC) -o genlab genlab.o
+
+clean:
+	$(RM) $(OBJS)
+	$(RM) $(PROLLEXE) proll.aout
+
+proll.aout:	$(PROLLEXE)
+	$(ELFTOAOUT) -o proll.aout $(PROLLEXE)
diff -ruN proll_18.orig/qemu/head.S proll-patch7/qemu/head.S
--- proll_18.orig/qemu/head.S	1970-01-01 00:00:00.000000000 +0000
+++ proll-patch7/qemu/head.S	2005-03-02 15:30:47.000000000 +0000
@@ -0,0 +1,539 @@
+/**
+ ** Standalone startup code for Linux PROM emulator.
+ ** Copyright 1999 Pete A. Zaitcev
+ ** This code is licensed under GNU General Public License.
+ **/
+/*
+ * $Id: proll.patch,v 1.3 2005-03-13 09:43:36 bellard Exp $
+ */
+
+#include <psr.h>
+#include <asi.h>
+#include <crs.h>
+/* #include <asm/head.h> */	/* Trap entries. Do not use. */
+#include "phys_jj.h"
+
+#define C_LABEL(name)	name
+#define REGWIN_SZ   0x40
+
+#define WRITE_PAUSE    nop; nop; nop; /* Have to do this after %wim/%psr chg */
+
+  /* 22 is 24-2, (va)>>(SRMMU_PGDIR_SHIFT-PTESIZESHFT) */
+#define VATOPGDOFF(va) (((va)>>22)&0x3FC)
+#define VATOPMDOFF(va) (((va)>>16)&0xFC)
+
+#define NOP_INSN       0x01000000     /* Used to patch sparc_save_state */
+
+/* Here are some trap goodies */
+
+#if 0
+/* Generic trap entry. */
+#define TRAP_ENTRY(type, label) \
+	rd %psr, %l0; b label; rd %wim, %l3; nop;
+#endif
+
+/* Data/text faults. */
+#define SRMMU_TFAULT rd %psr, %l0; rd %wim, %l3; b C_LABEL(srmmu_fault); mov 1, %l7;
+#define SRMMU_DFAULT rd %psr, %l0; rd %wim, %l3; b C_LABEL(srmmu_fault); mov 0, %l7;
+
+#if 0
+/* This is for traps we should NEVER get. */
+#define BAD_TRAP(num) \
+        rd %psr, %l0; mov num, %l7; b bad_trap_handler; rd %wim, %l3;
+
+/* This is for traps when we want just skip the instruction which caused it */
+#define SKIP_TRAP(type, name) \
+	jmpl %l2, %g0; rett %l2 + 4; nop; nop;
+
+/* Notice that for the system calls we pull a trick.  We load up a
+ * different pointer to the system call vector table in %l7, but call
+ * the same generic system call low-level entry point.  The trap table
+ * entry sequences are also HyperSparc pipeline friendly ;-)
+ */
+
+/* Software trap for Linux system calls. */
+#define LINUX_SYSCALL_TRAP \
+        sethi %hi(C_LABEL(sys_call_table)), %l7; \
+        or %l7, %lo(C_LABEL(sys_call_table)), %l7; \
+        b linux_sparc_syscall; \
+        rd %psr, %l0;
+
+/* Software trap for SunOS4.1.x system calls. */
+#define SUNOS_SYSCALL_TRAP \
+        rd %psr, %l0; \
+        sethi %hi(C_LABEL(sunos_sys_table)), %l7; \
+        b linux_sparc_syscall; \
+        or %l7, %lo(C_LABEL(sunos_sys_table)), %l7;
+
+/* Software trap for Slowaris system calls. */
+#define SOLARIS_SYSCALL_TRAP \
+        b solaris_syscall; \
+        rd %psr, %l0; \
+        nop; \
+        nop;
+
+#define INDIRECT_SOLARIS_SYSCALL(x) \
+	mov x, %g1; \
+	b solaris_syscall; \
+	rd %psr, %l0; \
+	nop;
+
+#define BREAKPOINT_TRAP \
+	b breakpoint_trap; \
+	rd %psr,%l0; \
+	nop; \
+	nop;
+
+/* Software trap for Sparc-netbsd system calls. */
+#define NETBSD_SYSCALL_TRAP \
+        sethi %hi(C_LABEL(sys_call_table)), %l7; \
+        or %l7, %lo(C_LABEL(sys_call_table)), %l7; \
+        b bsd_syscall; \
+        rd %psr, %l0;
+
+/* The Get Condition Codes software trap for userland. */
+#define GETCC_TRAP \
+        b getcc_trap_handler; mov %psr, %l0; nop; nop;
+
+/* The Set Condition Codes software trap for userland. */
+#define SETCC_TRAP \
+        b setcc_trap_handler; mov %psr, %l0; nop; nop;
+
+/* This is for hard interrupts from level 1-14, 15 is non-maskable (nmi) and
+ * gets handled with another macro.
+ */
+#define TRAP_ENTRY_INTERRUPT(int_level) \
+        mov int_level, %l7; rd %psr, %l0; b real_irq_entry; rd %wim, %l3;
+
+/* NMI's (Non Maskable Interrupts) are special, you can't keep them
+ * from coming in, and basically if you get one, the shows over. ;(
+ * On the sun4c they are usually asynchronous memory errors, on the
+ * the sun4m they could be either due to mem errors or a software
+ * initiated interrupt from the prom/kern on an SMP box saying "I
+ * command you to do CPU tricks, read your mailbox for more info."
+ */
+#define NMI_TRAP \
+        rd %wim, %l3; b linux_trap_nmi_sun4c; mov %psr, %l0; nop;
+
+#endif
+
+/* Window overflows/underflows are special and we need to try to be as
+ * efficient as possible here....
+ */
+#define WINDOW_SPILL \
+        rd %psr, %l0; rd %wim, %l3; b spill_window_entry; nop;
+
+#define WINDOW_FILL \
+        rd %psr, %l0; rd %wim, %l3; b fill_window_entry; nop;
+
+#define STUB_TRAP	ba stub_trap; nop; nop; nop;
+
+#define TRAP_ENTRY(a,b)		STUB_TRAP
+#define SKIP_TRAP(a,b)		STUB_TRAP
+#define SUNOS_SYSCALL_TRAP	STUB_TRAP
+#define SOLARIS_SYSCALL_TRAP	STUB_TRAP
+#define NETBSD_SYSCALL_TRAP	STUB_TRAP
+#define LINUX_SYSCALL_TRAP	STUB_TRAP
+#define BREAKPOINT_TRAP		STUB_TRAP
+#define NMI_TRAP		STUB_TRAP
+#define GETCC_TRAP		STUB_TRAP
+#define SETCC_TRAP		STUB_TRAP
+#define BAD_TRAP(n)		STUB_TRAP
+#define	TRAP_ENTRY_INTERRUPT(i)		STUB_TRAP
+#define	INDIRECT_SOLARIS_SYSCALL(i)	STUB_TRAP
+
+	.section ".text"
+	.globl start, _start
+_start:
+start:
+	.globl spill_window_entry, fill_window_entry
+
+#define	EXPORT_TRAP(trap) \
+	.globl trap; \
+	.type trap,function; \
+	.size trap, 16
+
+EXPORT_TRAP(t_zero)
+EXPORT_TRAP(t_wovf)
+EXPORT_TRAP(t_wunf)
+EXPORT_TRAP(t_irq1)
+EXPORT_TRAP(t_irq2)
+EXPORT_TRAP(t_irq3)
+EXPORT_TRAP(t_irq4)
+EXPORT_TRAP(t_irq5)
+EXPORT_TRAP(t_irq6)
+EXPORT_TRAP(t_irq7)
+EXPORT_TRAP(t_irq8)
+EXPORT_TRAP(t_irq9)
+EXPORT_TRAP(t_irq10)
+EXPORT_TRAP(t_irq11)
+EXPORT_TRAP(t_irq12)
+EXPORT_TRAP(t_irq13)
+EXPORT_TRAP(t_irq14)
+EXPORT_TRAP(t_irq15)
+
+C_LABEL(trapbase):
+t_zero:	b goprol; nop; nop; nop;
+t_tflt:	SRMMU_TFAULT                        /* Inst. Access Exception        */
+t_bins:	TRAP_ENTRY(0x2, bad_instruction)    /* Illegal Instruction           */
+t_pins:	TRAP_ENTRY(0x3, priv_instruction)   /* Privileged Instruction        */
+t_fpd:	TRAP_ENTRY(0x4, fpd_trap_handler)   /* Floating Point Disabled       */
+t_wovf:	WINDOW_SPILL                        /* Window Overflow               */
+t_wunf:	WINDOW_FILL                         /* Window Underflow              */
+t_mna:	TRAP_ENTRY(0x7, mna_handler)        /* Memory Address Not Aligned    */
+t_fpe:	TRAP_ENTRY(0x8, fpe_trap_handler)   /* Floating Point Exception      */
+t_dflt:	SRMMU_DFAULT                        /* Data Miss Exception           */
+t_tio:	TRAP_ENTRY(0xa, do_tag_overflow)    /* Tagged Instruction Ovrflw     */
+t_wpt:	TRAP_ENTRY(0xb, do_watchpoint)      /* Watchpoint Detected           */
+t_badc:	BAD_TRAP(0xc) BAD_TRAP(0xd) BAD_TRAP(0xe) BAD_TRAP(0xf) BAD_TRAP(0x10)
+t_irq1:	TRAP_ENTRY_INTERRUPT(1)             /* IRQ Software/SBUS Level 1     */
+t_irq2:	TRAP_ENTRY_INTERRUPT(2)             /* IRQ SBUS Level 2              */
+t_irq3:	TRAP_ENTRY_INTERRUPT(3)             /* IRQ SCSI/DMA/SBUS Level 3     */
+t_irq4:	TRAP_ENTRY_INTERRUPT(4)             /* IRQ Software Level 4          */
+t_irq5:	TRAP_ENTRY_INTERRUPT(5)             /* IRQ SBUS/Ethernet Level 5     */
+t_irq6:	TRAP_ENTRY_INTERRUPT(6)             /* IRQ Software Level 6          */
+t_irq7:	TRAP_ENTRY_INTERRUPT(7)             /* IRQ Video/SBUS Level 5        */
+t_irq8:	TRAP_ENTRY_INTERRUPT(8)             /* IRQ SBUS Level 6              */
+t_irq9:	TRAP_ENTRY_INTERRUPT(9)             /* IRQ SBUS Level 7              */
+t_irq10:TRAP_ENTRY_INTERRUPT(10)            /* IRQ Timer #1 (one we use)     */
+t_irq11:TRAP_ENTRY_INTERRUPT(11)            /* IRQ Floppy Intr.              */
+t_irq12:TRAP_ENTRY_INTERRUPT(12)            /* IRQ Zilog serial chip         */
+t_irq13:TRAP_ENTRY_INTERRUPT(13)            /* IRQ Audio Intr.               */
+t_irq14:TRAP_ENTRY_INTERRUPT(14)            /* IRQ Timer #2                  */
+t_nmi:	NMI_TRAP                            /* Level 15 (NMI)                */
+t_racc:	TRAP_ENTRY(0x20, do_reg_access)     /* General Register Access Error */
+t_iacce:BAD_TRAP(0x21)                      /* Instr Access Error            */
+t_bad22:BAD_TRAP(0x22) BAD_TRAP(0x23)
+t_cpdis:TRAP_ENTRY(0x24, do_cp_disabled)    /* Co-Processor Disabled         */
+t_uflsh:SKIP_TRAP(0x25, unimp_flush)        /* Unimplemented FLUSH inst.     */
+t_bad26:BAD_TRAP(0x26) BAD_TRAP(0x27)
+t_cpexc:TRAP_ENTRY(0x28, do_cp_exception)   /* Co-Processor Exception        */
+t_dacce:SRMMU_DFAULT                        /* Data Access Error             */
+t_hwdz:	TRAP_ENTRY(0x2a, do_hw_divzero)     /* Division by zero, you lose... */
+t_dserr:BAD_TRAP(0x2b)                      /* Data Store Error              */
+t_daccm:BAD_TRAP(0x2c)                      /* Data Access MMU-Miss          */
+t_bad2d:               BAD_TRAP(0x2d) BAD_TRAP(0x2e) BAD_TRAP(0x2f)
+        BAD_TRAP(0x30) BAD_TRAP(0x31) BAD_TRAP(0x32) BAD_TRAP(0x33)
+        BAD_TRAP(0x34) BAD_TRAP(0x35) BAD_TRAP(0x36) BAD_TRAP(0x37)
+        BAD_TRAP(0x38) BAD_TRAP(0x39) BAD_TRAP(0x3a) BAD_TRAP(0x3b)
+t_iaccm:BAD_TRAP(0x3c)                      /* Instr Access MMU-Miss         */
+ BAD_TRAP(0x3d) BAD_TRAP(0x3e) BAD_TRAP(0x3f)
+ BAD_TRAP(0x40) BAD_TRAP(0x41) BAD_TRAP(0x42) BAD_TRAP(0x43)
+ BAD_TRAP(0x44) BAD_TRAP(0x45) BAD_TRAP(0x46) BAD_TRAP(0x47)
+ BAD_TRAP(0x48) BAD_TRAP(0x49) BAD_TRAP(0x4a) BAD_TRAP(0x4b)
+ BAD_TRAP(0x4c) BAD_TRAP(0x4d) BAD_TRAP(0x4e) BAD_TRAP(0x4f)
+ BAD_TRAP(0x50) BAD_TRAP(0x51) BAD_TRAP(0x52) BAD_TRAP(0x53)
+ BAD_TRAP(0x54) BAD_TRAP(0x55) BAD_TRAP(0x56) BAD_TRAP(0x57)
+ BAD_TRAP(0x58) BAD_TRAP(0x59) BAD_TRAP(0x5a) BAD_TRAP(0x5b)
+ BAD_TRAP(0x5c) BAD_TRAP(0x5d) BAD_TRAP(0x5e) BAD_TRAP(0x5f)
+ BAD_TRAP(0x60) BAD_TRAP(0x61) BAD_TRAP(0x62) BAD_TRAP(0x63)
+ BAD_TRAP(0x64) BAD_TRAP(0x65) BAD_TRAP(0x66) BAD_TRAP(0x67)
+ BAD_TRAP(0x68) BAD_TRAP(0x69) BAD_TRAP(0x6a) BAD_TRAP(0x6b)
+ BAD_TRAP(0x6c) BAD_TRAP(0x6d) BAD_TRAP(0x6e) BAD_TRAP(0x6f)
+ BAD_TRAP(0x70) BAD_TRAP(0x71) BAD_TRAP(0x72) BAD_TRAP(0x73)
+ BAD_TRAP(0x74) BAD_TRAP(0x75) BAD_TRAP(0x76) BAD_TRAP(0x77)
+ BAD_TRAP(0x78) BAD_TRAP(0x79) BAD_TRAP(0x7a) BAD_TRAP(0x7b)
+ BAD_TRAP(0x7c) BAD_TRAP(0x7d) BAD_TRAP(0x7e) BAD_TRAP(0x7f)
+t_sunos:SUNOS_SYSCALL_TRAP                  /* SunOS System Call             */
+t_sbkpt:BREAKPOINT_TRAP                     /* Software Breakpoint/KGDB      */
+t_divz:	BAD_TRAP(0x82)                      /* Divide by zero trap           */
+t_flwin:TRAP_ENTRY(0x83, do_flush_windows)  /* Flush Windows Trap            */
+t_clwin:BAD_TRAP(0x84)                      /* Clean Windows Trap            */
+t_rchk:	BAD_TRAP(0x85)                      /* Range Check                   */
+t_funal:BAD_TRAP(0x86)                      /* Fix Unaligned Access Trap     */
+t_iovf:	BAD_TRAP(0x87)                      /* Integer Overflow Trap         */
+t_slowl:SOLARIS_SYSCALL_TRAP                /* Slowaris System Call          */
+t_netbs:NETBSD_SYSCALL_TRAP                 /* Net-B.S. System Call          */
+t_bad8a:BAD_TRAP(0x8a) BAD_TRAP(0x8b) BAD_TRAP(0x8c) BAD_TRAP(0x8d)
+ BAD_TRAP(0x8e) BAD_TRAP(0x8f)
+t_linux:LINUX_SYSCALL_TRAP                  /* Linux System Call             */
+t_bad91:BAD_TRAP(0x91) BAD_TRAP(0x92) BAD_TRAP(0x93)
+ BAD_TRAP(0x94) BAD_TRAP(0x95) BAD_TRAP(0x96) BAD_TRAP(0x97)
+ BAD_TRAP(0x98) BAD_TRAP(0x99) BAD_TRAP(0x9a) BAD_TRAP(0x9b) BAD_TRAP(0x9c) BAD_TRAP(0x9d) BAD_TRAP(0x9e) BAD_TRAP(0x9f)
+t_getcc:GETCC_TRAP                          /* Get Condition Codes           */
+t_setcc:SETCC_TRAP                          /* Set Condition Codes           */
+t_bada2:BAD_TRAP(0xa2) BAD_TRAP(0xa3)
+ BAD_TRAP(0xa4) BAD_TRAP(0xa5) BAD_TRAP(0xa6)
+t_slowi:INDIRECT_SOLARIS_SYSCALL(156)
+ BAD_TRAP(0xa8) BAD_TRAP(0xa9) BAD_TRAP(0xaa) BAD_TRAP(0xab)
+ BAD_TRAP(0xac) BAD_TRAP(0xad) BAD_TRAP(0xae) BAD_TRAP(0xaf)
+ BAD_TRAP(0xb0) BAD_TRAP(0xb1) BAD_TRAP(0xb2) BAD_TRAP(0xb3)
+ BAD_TRAP(0xb4) BAD_TRAP(0xb5) BAD_TRAP(0xb6) BAD_TRAP(0xb7)
+ BAD_TRAP(0xb8) BAD_TRAP(0xb9) BAD_TRAP(0xba) BAD_TRAP(0xbb)
+ BAD_TRAP(0xbc) BAD_TRAP(0xbd) BAD_TRAP(0xbe) BAD_TRAP(0xbf)
+t_badc0:BAD_TRAP(0xc0) BAD_TRAP(0xc1) BAD_TRAP(0xc2) BAD_TRAP(0xc3)
+ BAD_TRAP(0xc4) BAD_TRAP(0xc5) BAD_TRAP(0xc6) BAD_TRAP(0xc7)
+ BAD_TRAP(0xc8) BAD_TRAP(0xc9) BAD_TRAP(0xca) BAD_TRAP(0xcb)
+ BAD_TRAP(0xcc) BAD_TRAP(0xcd) BAD_TRAP(0xce) BAD_TRAP(0xcf)
+ BAD_TRAP(0xd0) BAD_TRAP(0xd1) BAD_TRAP(0xd2) BAD_TRAP(0xd3)
+t_badd4:BAD_TRAP(0xd4) BAD_TRAP(0xd5) BAD_TRAP(0xd6) BAD_TRAP(0xd7)
+ BAD_TRAP(0xd8) BAD_TRAP(0xd9) BAD_TRAP(0xda) BAD_TRAP(0xdb)
+ BAD_TRAP(0xdc) BAD_TRAP(0xdd) BAD_TRAP(0xde) BAD_TRAP(0xdf)
+ BAD_TRAP(0xe0) BAD_TRAP(0xe1) BAD_TRAP(0xe2) BAD_TRAP(0xe3)
+ BAD_TRAP(0xe4) BAD_TRAP(0xe5) BAD_TRAP(0xe6) BAD_TRAP(0xe7)
+t_bade8:BAD_TRAP(0xe8) BAD_TRAP(0xe9) BAD_TRAP(0xea) BAD_TRAP(0xeb)
+ BAD_TRAP(0xec) BAD_TRAP(0xed) BAD_TRAP(0xee) BAD_TRAP(0xef)
+ BAD_TRAP(0xf0) BAD_TRAP(0xf1) BAD_TRAP(0xf2) BAD_TRAP(0xf3)
+ BAD_TRAP(0xf4) BAD_TRAP(0xf5) BAD_TRAP(0xf6) BAD_TRAP(0xf7)
+ BAD_TRAP(0xf8) BAD_TRAP(0xf9) BAD_TRAP(0xfa) BAD_TRAP(0xfb)
+t_badfc:BAD_TRAP(0xfc) BAD_TRAP(0xfd)
+dbtrap:	BAD_TRAP(0xfe)                      /* Debugger/PROM breakpoint #1   */
+dbtrap2:BAD_TRAP(0xff)                      /* Debugger/PROM breakpoint #2   */	
+
+stub_trap:
+   set (PHYS_JJ_TCX_FB + 0xbf0), %g5	/* 2 cells from side */
+   set 0x00ffffff, %g4
+   sta %g4, [%g5] ASI_M_BYPASS
+1:	ba 1b; nop
+
+	.section ".bss"
+	.align 8
+bss_start:
+	.align	0x1000		! PAGE_SIZE
+	.globl C_LABEL(bootup_user_stack)
+        .type   bootup_user_stack,#object
+        .size   bootup_user_stack,0x2000
+C_LABEL(bootup_user_stack):		.skip 0x2000
+
+	.section ".text"
+
+goprol:
+	! %g1 contains end of memory
+	set	PHYS_JJ_EEPROM + 0x30, %g1
+	lda	[%g1] ASI_M_BYPASS, %g1
+	! map PROLDATA to PROLBASE+PROLSIZE to end of ram
+	set	PROLSIZE+0x1000-PROLDATA+PROLBASE, %g2	! add 0x1000 for temp tables
+	sub	%g1, %g2, %g2			! start of private memory
+	srl	%g2, 0x4, %g7			! ctx table at s+0x0
+	add	%g2, 0x400, %g3			! l1 table at s+0x400
+	srl	%g3, 0x4, %g3
+	or	%g3, 0x1, %g3
+	sta	%g3, [%g2] ASI_M_BYPASS
+	add	%g2, 0x400, %g2			! s+0x400
+	add	%g2, 0x800, %g3			! l2 table for ram (00xxxxxx) at s+0x800
+	srl	%g3, 0x4, %g3
+	or	%g3, 0x1, %g3
+	sta	%g3, [%g2] ASI_M_BYPASS
+	add	%g2, 0x500, %g3			! l2 table for rom (ffxxxxxx) at s+0x900
+	add	%g2, 0x3fc, %g2			! s+0x7fc
+	srl	%g3, 0x4, %g3
+	or	%g3, 0x1, %g3
+	sta	%g3, [%g2] ASI_M_BYPASS
+	add	%g2, 0x4, %g2			! s+0x800
+	set	((7 << 2) | 2), %g3		! 7 = U: --- S: RWX (main memory)
+	sta	%g3, [%g2] ASI_M_BYPASS
+	add	%g2, 0x200, %g3			! l3 table for rom at s+0xa00
+	add	%g2, 0x1d0, %g2			! s+0x9d0
+	srl	%g3, 0x4, %g3
+	or	%g3, 0x1, %g3
+	sta	%g3, [%g2] ASI_M_BYPASS
+	add	%g2, 0x30, %g2			! s+0xa00
+
+	set	PROLBASE, %g3
+	set	0x1000, %g5
+	set	(PROLDATA-PROLBASE)/0x1000, %g6 ! # of .text pages
+1:	srl	%g3, 0x4, %g4
+	or	%g4, ((7 << 2) | 2), %g4	! 4 = U: --X S: --X (rom, execute only)
+	sta	%g4, [%g2] ASI_M_BYPASS
+	add	%g2, 4, %g2
+	add	%g3, %g5, %g3
+	deccc	%g6
+	bne	1b
+	 nop
+#if 0	
+	set	(PROLDATA-PROLRODATA)/0x1000, %g6 ! # of .rodata pages
+1:	srl	%g3, 0x4, %g4
+	or	%g4, ((0 << 2) | 2), %g4	! 0 = U: R-- S: R-- (rom, read only)
+	sta	%g4, [%g2] ASI_M_BYPASS
+	add	%g2, 4, %g2
+	add	%g3, %g5, %g3
+	deccc	%g6
+	bne	1b
+	 nop
+#endif
+	set	(PROLBASE+PROLSIZE-PROLDATA)/0x1000, %g6 ! # of .bss pages
+	set	0x1000, %g4
+	sll	%g7, 0x4, %g3
+	add	%g4, %g3, %g3
+1:	srl	%g3, 0x4, %g4
+	or	%g4, ((7 << 2) | 2), %g4        ! 5 = U: R-- S: RW- (data area, read/write)
+	sta	%g4, [%g2] ASI_M_BYPASS
+	add	%g2, 4, %g2
+	add	%g3, %g5, %g3
+	deccc	%g6
+	bne	1b
+	 nop
+
+	mov	%g1, %g3
+
+	set     AC_M_CTPR, %g2
+	sta     %g7, [%g2] ASI_M_MMUREGS	! set ctx table ptr
+	set	1, %g1
+	sta     %g1, [%g0] ASI_M_MMUREGS	! enable mmu
+
+	/*
+	 * The code which enables traps is a simplified version of
+	 * kernel head.S.
+	 *
+	 * We know number of windows as 8 so we do not calculate them.
+	 * The deadwood is here for any case.
+	 */
+
+	/* Turn on Supervisor, EnableFloating, and all the PIL bits.
+	 * Also puts us in register window zero with traps off.
+	 */
+	set	(PSR_PS | PSR_S | PSR_PIL | PSR_EF), %g2
+	wr	%g2, 0x0, %psr
+	WRITE_PAUSE
+
+	/* I want a kernel stack NOW! */
+	set	C_LABEL(bootup_user_stack), %g1
+	set	(0x2000 - REGWIN_SZ), %g2
+	add	%g1, %g2, %sp
+	mov	0, %fp			/* And for good luck */
+
+	/* Zero out our BSS section. */
+	set	C_LABEL(bss_start) , %o0	! First address of BSS
+	set	C_LABEL(end) , %o1		! Last address of BSS
+	ba	2f
+	 nop
+1:
+	st	%g0, [%o0]
+2:
+	subcc	%o0, %o1, %g0
+	bl	1b
+	 add	%o0, 0x4, %o0
+
+	mov	2, %g1
+	wr	%g1, 0x0, %wim			! make window 1 invalid
+	WRITE_PAUSE
+
+#if 0
+	wr  %g0, 0x0, %wim
+	WRITE_PAUSE
+	save
+	rd  %psr, %g3
+	restore
+	and  %g3, PSR_CWP, %g3
+	add  %g3, 0x1, %g3
+#else
+	or	%g0, 8, %g3
+#endif
+
+#if 0
+	sethi	%hi( C_LABEL(cputyp) ), %o0
+	st	%g7, [%o0 + %lo( C_LABEL(cputyp) )]
+
+	sethi	%hi( C_LABEL(nwindows) ), %g4
+	st	%g3, [%g4 + %lo( C_LABEL(nwindows) )]
+
+	sub	%g3, 0x1, %g3
+	sethi	%hi( C_LABEL(nwindowsm1) ), %g4
+	st	%g3, [%g4 + %lo( C_LABEL(nwindowsm1) )]
+#endif
+
+	/* Here we go, start using Linux's trap table... */
+	set	C_LABEL(trapbase), %g3
+	wr	%g3, 0x0, %tbr
+	WRITE_PAUSE
+
+	/* Finally, turn on traps so that we can call c-code. */
+	rd	%psr, %g3
+	wr	%g3, 0x0, %psr
+	WRITE_PAUSE
+
+	wr	%g3, PSR_ET, %psr
+	WRITE_PAUSE
+
+	.globl prolmain
+	call C_LABEL(prolmain)
+	 nop
+
+3:
+	b       3b
+	 nop
+
+/*
+ * Memory access trap handler
+ *   %l0  program %psr from trap table entry
+ *   %l1  program %pc from hardware
+ *   %l2  program %npc from hardware
+ *   %l3  program %wim from trap table entry
+ *   %l4
+ *   %l5
+ *   %l6
+ *   %l7  text flag from trap table entry
+ */
+
+	.section ".text"
+	.globl srmmu_fault
+C_LABEL(srmmu_fault):
+
+	set AC_M_SFAR, %l6
+	set AC_M_SFSR, %l5
+	lda [%l6] ASI_M_MMUREGS, %l6
+	lda [%l5] ASI_M_MMUREGS, %l5
+
+	set ignore_fault, %l5
+	ld [%l5], %l5
+	subcc %l5, %g0, %g0		/* NULL pointer trap faults always */
+	be 3f
+	 nop
+	subcc %l5, %l6, %g0
+	be 2f
+	 nop
+3:
+
+   set (PHYS_JJ_TCX_FB + 0xbf0), %g5	/* 2 cells from side */
+   set 0x00ffffff, %g4
+   sta %g4, [%g5] ASI_M_BYPASS
+   add %g5, 8, %g5			/* On right side */
+   sta %g4, [%g5] ASI_M_BYPASS
+1:	ba 1b; nop
+
+2:
+	set C_LABEL(fault_ignored), %l5
+	mov 1, %l6
+	st %l6, [%l5]
+
+	/*
+	 * Skip the faulting instruction.
+	 * I think it works when next instruction is a branch even.
+	 */
+	or %l2, 0, %l1
+	add %l2, 4, %l2
+
+	wr %l0, 0, %psr
+	WRITE_PAUSE
+	jmp %l1
+	rett %l2
+
+/*
+ * Slow external versions of st_bypass and ld_bypass.
+ * rconsole.c uses inlines. We call these in places which are not speed
+ * critical, to avoid compiler bugs.
+ */
+	.globl C_LABEL(st_bypass)
+C_LABEL(st_bypass):
+	retl
+	 sta %o1, [%o0] ASI_M_BYPASS
+	.globl C_LABEL(ld_bypass)
+C_LABEL(ld_bypass):
+	retl
+	 lda [%o0] ASI_M_BYPASS, %o0
+	.globl C_LABEL(sth_bypass)
+C_LABEL(sth_bypass):
+	retl
+	 stha %o1, [%o0] ASI_M_BYPASS
+	.globl C_LABEL(ldh_bypass)
+C_LABEL(ldh_bypass):
+	retl
+	 lduha [%o0] ASI_M_BYPASS, %o0
+	.globl C_LABEL(stb_bypass)
+C_LABEL(stb_bypass):
+	retl
+	 stba %o1, [%o0] ASI_M_BYPASS
+	.globl C_LABEL(ldb_bypass)
+C_LABEL(ldb_bypass):
+	retl
+	 lduba [%o0] ASI_M_BYPASS, %o0
diff -ruN proll_18.orig/qemu/main.c proll-patch7/qemu/main.c
--- proll_18.orig/qemu/main.c	1970-01-01 00:00:00.000000000 +0000
+++ proll-patch7/qemu/main.c	2005-03-02 20:08:23.000000000 +0000
@@ -0,0 +1,173 @@
+/**
+ ** Proll (PROM replacement)
+ ** Copyright 1999 Pete Zaitcev
+ ** This code is licensed under GNU General Public License.
+ **/
+#include <stdarg.h>
+
+// #include <asm/contregs.h>
+#include <asi.h>
+#include "pgtsrmmu.h"
+#include "iommu.h"		/* Typical SBus IOMMU for sun4m */
+#include "phys_jj.h"
+#include "vconsole.h"
+#include "version.h"
+#include <general.h>		/* __P() */
+#include <net.h>		/* init_net() */
+#include <romlib.h>		/* we are a provider for part of this. */
+#include <netpriv.h>		/* myipaddr */
+#include <arpa.h>
+#include <system.h>		/* our own prototypes */
+
+void *init_openprom_qemu(int bankc, struct bank *bankv, unsigned hiphybas, const char *cmdline, char boot_device, int nographic);
+int vcon_zs_init(struct vconterm *t, unsigned int a0);
+int vcon_zs_write(struct vconterm *t, char *data, int leng);
+
+static void init_idprom(void);
+
+struct vconterm dp0;
+struct mem cmem;		/* Current memory, virtual */
+struct mem cio;			/* Current I/O space */
+struct phym pmem;		/* Current phys. mem. */
+struct iommu ciommu;		/* Our IOMMU on sun4m */
+
+static struct {
+    const char id[16];
+    unsigned int version;
+    char pad1[0x1c]; // Pad to 0x30
+    unsigned int ram_size;
+    char boot_device;
+    unsigned int load_addr, kernel_size;
+    unsigned int cmdline, cmdline_len;
+    char pad2[0x0c]; // Pad to 0x54
+    unsigned short width, height, depth;
+} *hw_idprom;
+
+int ignore_fault, fault_ignored;
+void *printk_fn;
+unsigned int q_height, q_width;
+
+/*
+ */
+void prolmain()
+{
+	static char fname[14];
+	static struct banks bb;
+	unsigned int hiphybas;
+	const void *romvec;
+	unsigned int ram_size;
+	char nographic;
+
+	nographic = ldb_bypass(PHYS_JJ_EEPROM + 0x2F);
+	if (!nographic) {
+	    q_width = ldh_bypass(PHYS_JJ_EEPROM + 0x54);
+	    q_height = ldh_bypass(PHYS_JJ_EEPROM + 0x56);
+	    vcon_init(&dp0, PHYS_JJ_TCX_FB);
+	    printk_fn = vcon_write;
+	}
+	else {
+	    vcon_zs_init(&dp0, 0x71100000);
+	    printk_fn = vcon_zs_write;
+	}
+
+
+	printk("PROLL %s QEMU\n", PROLL_VERSION_STRING);
+	ram_size = ld_bypass(PHYS_JJ_EEPROM + 0x30);
+	printk("%d MB total\n", ram_size/(1024*1024));
+
+	bb.nbanks = 1;
+	bb.bankv[0].start = 0;
+	bb.bankv[0].length = ram_size;
+
+	hiphybas = ram_size - PROLSIZE;
+
+	mem_init(&cmem, (char *) &_end, (char *)(PROLBASE+PROLSIZE));
+	makepages(&pmem, hiphybas);
+	init_mmu_swift((unsigned int)pmem.pctp - PROLBASE + hiphybas);
+
+	mem_init(&cio, (char *)(PROLBASE+PROLSIZE),
+	    (char *)(PROLBASE+PROLSIZE+IOMAPSIZE));
+
+	iommu_init(&ciommu, hiphybas);
+
+	/*
+	 */
+	init_idprom();
+	printk("NVRAM: id %s version %d\n", hw_idprom->id, hw_idprom->version);
+	if (!nographic)
+	    printk("Prom console: TCX %dx%d\n", q_width, q_height);
+	else
+	    printk("Prom console: serial\n");
+	sched_init();
+	le_probe();
+	init_net();
+
+	printk("Boot device: %c\n", hw_idprom->boot_device);
+	if (hw_idprom->boot_device == 'n') {
+	    if (bootp() != 0) fatal();
+	    /*
+	     * boot_rec.bp_file cannot be used because system PROM
+	     * uses it to locate ourselves. If we load from boot_rec.bp_file,
+	     * we will loop reloading PROLL over and over again.
+	     * Thus we use traditional PROLL scheme HEXIPADDR.PROL (single L).
+	     */
+	    xtoa(myipaddr, fname, 8);
+	    fname[9] = '.';
+	    fname[10] = 'P';
+	    fname[11] = 'R';
+	    fname[12] = 'O';
+	    fname[13] = 'L';
+	    fname[14] = 0;
+	    
+	    if (load(boot_rec.bp_siaddr, fname) != 0) fatal();
+	}
+
+	romvec = init_openprom_qemu(bb.nbanks, bb.bankv, hiphybas,
+				    (void *)hw_idprom->cmdline, hw_idprom->boot_device, nographic);
+
+	printk("Memory used: virt 0x%x:0x%x[%dK] iomap 0x%x:0x%x\n",
+	    PROLBASE, (int)cmem.curp, ((unsigned) cmem.curp - PROLBASE)/1024,
+	    (int)cio.start, (int)cio.curp);
+
+	{
+	    void (*entry)(const void *, int, int, int, int) = (void *) hw_idprom->load_addr;
+		printk("Kernel loaded at 0x%x, size %dK, command line = '%s'\n",
+		       *entry, hw_idprom->kernel_size/1024, hw_idprom->cmdline);
+		entry(romvec, 0, 0, 0, 0);
+	}
+
+	mem_fini(&cmem);
+	vcon_fini(&dp0);
+}
+
+/*
+ * dvma_alloc over iommu_alloc.
+ */
+void *dvma_alloc(int size, unsigned int *pphys)
+{
+	return iommu_alloc(&ciommu, size, pphys);
+}
+
+/*
+ */
+void udelay(unsigned long usecs)
+{
+    // Qemu hardware is perfect and does not need any delays!
+}
+
+static void init_idprom()
+{
+	void *va_prom;
+
+	if ((va_prom = map_io(PHYS_JJ_EEPROM, PHYS_JJ_EEPROM_SIZE)) == NULL) {
+		printk("init_idprom: cannot map eeprom\n");
+		fatal();
+	}
+	bcopy(va_prom + PHYS_JJ_IDPROM_OFF, idprom, IDPROM_SIZE);
+	/*
+	 * hw_idprom is not used anywhere.
+	 * It's just as we hate to leave hanging pointers (I/O page here).
+	 */
+	hw_idprom = va_prom; 
+}
+
diff -ruN proll_18.orig/qemu/openprom.c proll-patch7/qemu/openprom.c
--- proll_18.orig/qemu/openprom.c	1970-01-01 00:00:00.000000000 +0000
+++ proll-patch7/qemu/openprom.c	2005-03-02 20:09:57.000000000 +0000
@@ -0,0 +1,646 @@
+/*
+ * PROM interface support
+ * Copyright 1996 The Australian National University.
+ * Copyright 1996 Fujitsu Laboratories Limited
+ * Copyright 1999 Pete A. Zaitcev
+ * This software may be distributed under the terms of the Gnu
+ * Public License version 2 or later
+ */
+
+#include <openprom.h>
+#include <general.h>
+#include <romlib.h>
+#include <system.h>
+#include <vconsole.h>
+#include "phys_jj.h"
+
+//#define DEBUG_OBP
+
+struct property {
+	const char *name;
+	const char *value;
+	const int length;
+};
+
+struct node {
+	const struct property *properties;
+	/* short */ const int sibling;
+	/* short */ const int child;
+};
+
+static int obp_nextnode(int node);
+static int obp_child(int node);
+static int obp_proplen(int node, char *name);
+static int obp_getprop(int node, char *name, char *val);
+static int obp_setprop(int node, char *name, char *val, int len);
+static const char *obp_nextprop(int node, char *name);
+
+static char obp_idprom[IDPROM_SIZE];
+static const struct property null_properties = { NULL, NULL, -1 };
+static const int prop_true = -1;
+
+static const struct property propv_root[] = {
+	{"name",	"SUNW,JavaStation-1", sizeof("SUNW,JavaStation-1") },
+	{"idprom",	obp_idprom, IDPROM_SIZE},
+	{"banner-name", "JavaStation", sizeof("JavaStation")},
+	{"compatible",	"sun4m", 6},
+	{NULL, NULL, -1}
+};
+
+static const int prop_iommu_reg[] = {
+	0x0, 0x10000000, 0x00000300,
+};
+static const struct property propv_iommu[] = {
+	{"name",	"iommu", sizeof("iommu")},
+	{"reg",		(char*)&prop_iommu_reg[0], sizeof(prop_iommu_reg) },
+	{NULL, NULL, -1}
+};
+
+static const int prop_sbus_ranges[] = {
+	0x0, 0x0, 0x0, 0x30000000, 0x10000000,
+	0x1, 0x0, 0x0, 0x40000000, 0x10000000,
+	0x2, 0x0, 0x0, 0x50000000, 0x10000000,
+	0x3, 0x0, 0x0, 0x60000000, 0x10000000,
+	0x4, 0x0, 0x0, 0x70000000, 0x10000000,
+};
+static const struct property propv_sbus[] = {
+	{"name",	"sbus", 5},
+	{"ranges",	(char*)&prop_sbus_ranges[0], sizeof(prop_sbus_ranges)},
+	{"device_type",	"hierarchical", sizeof("hierarchical") },
+	{NULL, NULL, -1}
+};
+
+static const int prop_tcx_regs[] = {
+	0x2, 0x00800000, 0x00100000,
+	0x2, 0x02000000, 0x00000001,
+	0x2, 0x04000000, 0x00800000,
+	0x2, 0x06000000, 0x00800000,
+	0x2, 0x0a000000, 0x00000001,
+	0x2, 0x0c000000, 0x00000001,
+	0x2, 0x0e000000, 0x00000001,
+	0x2, 0x00700000, 0x00001000,
+	0x2, 0x00200000, 0x00000004,
+	0x2, 0x00300000, 0x0000081c,
+	0x2, 0x00000000, 0x00010000,
+	0x2, 0x00240000, 0x00000004,
+	0x2, 0x00280000, 0x00000001,
+};
+
+#if 1	/* Zaitcev */
+static const int pixfreq = 0x03dfd240;
+static const int hbporch = 0xa0;
+static const int vfreq = 0x3c;
+#endif
+#if 0	/* Kevin Boone - 70Hz refresh */
+static const int pixfreq = 0x047868C0;
+static const int hbporch = 0x90;
+static const int vfreq = 0x46;
+#endif
+
+static const int vbporch = 0x1d;
+static const int vsync = 0x6;
+static const int hsync = 0x88;
+static const int vfporch = 0x3;
+static const int hfporch = 0x18;
+static const int height = 0x300;
+static const int width = 0x400;
+static const int linebytes = 0x400;
+static const int depth = 8;
+static const int tcx_intr[] = { 5, 0 };
+static const int tcx_interrupts = 5;
+static const struct property propv_sbus_tcx[] = {
+	{"name",	"SUNW,tcx", sizeof("SUNW,tcx")},
+	{"vbporch",	(char*)&vbporch, sizeof(int)},
+	{"hbporch",	(char*)&hbporch, sizeof(int)},
+	{"vsync",	(char*)&vsync, sizeof(int)},
+	{"hsync",	(char*)&hsync, sizeof(int)},
+	{"vfporch",	(char*)&vfporch, sizeof(int)},
+	{"hfporch",	(char*)&hfporch, sizeof(int)},
+	{"pixfreq",	(char*)&pixfreq, sizeof(int)},
+	{"vfreq",	(char*)&vfreq, sizeof(int)},
+	{"height",	(char*)&height, sizeof(int)},
+	{"width",	(char*)&width, sizeof(int)},
+	{"linebytes",	(char*)&linebytes, sizeof(int)},
+	{"depth",	(char*)&depth, sizeof(int)},
+	{"reg",		(char*)&prop_tcx_regs[0], sizeof(prop_tcx_regs)},
+	{"tcx-8-bit",	(char*)&prop_true, 0},
+	{"intr",	(char*)&tcx_intr[0], sizeof(tcx_intr)},
+	{"interrupts",	(char*)&tcx_interrupts, sizeof(tcx_interrupts)},
+	{"device_type",	"display", sizeof("display")},
+	{NULL, NULL, -1}
+};
+
+static const int prop_cs4231_reg[] = {
+	0x3, 0x0C000000, 0x00000040
+};
+static const int cs4231_interrupts = 5;
+static const int cs4231_intr[] = { 5, 0 };
+
+static const struct property propv_sbus_cs4231[] = {
+	{"name",	"SUNW,CS4231", sizeof("SUNW,CS4231") },
+	{"intr",	(char*)&cs4231_intr[0], sizeof(cs4231_intr) },
+	{"interrupts",  (char*)&cs4231_interrupts, sizeof(cs4231_interrupts) },	
+	{"reg",		(char*)&prop_cs4231_reg[0], sizeof(prop_cs4231_reg) },
+	{"device_type", "serial", sizeof("serial") },
+	{"alias",	"audio", sizeof("audio") },
+	{NULL, NULL, -1}
+};
+
+static const int cpu_nctx = NCTX_SWIFT;
+static const int cpu_cache_line_size = 0x20;
+static const int cpu_cache_nlines = 0x200;
+static const struct property propv_cpu[] = {
+	{"name",	"STP1012PGA", sizeof("STP1012PGA") },
+	{"device_type",	"cpu", 4 },
+	{"mmu-nctx",	(char*)&cpu_nctx, sizeof(int)},
+	{"cache-line-size",	(char*)&cpu_cache_line_size, sizeof(int)},
+	{"cache-nlines",	(char*)&cpu_cache_nlines, sizeof(int)},
+	{NULL, NULL, -1}
+};
+
+static const int prop_obio_ranges[] = {
+	0x0, 0x0, 0x0, 0x71000000, 0x01000000,
+};
+static const struct property propv_obio[] = {
+	{"name",	"obio", 5 },
+	{"ranges",	(char*)&prop_obio_ranges[0], sizeof(prop_obio_ranges) },
+	{"device_type",	"hierarchical", sizeof("hierarchical") },
+	{NULL, NULL, -1}
+};
+
+static const int prop_auxio_reg[] = {
+	0x0, 0x00900000, 0x00000001,
+};
+static const struct property propv_obio_auxio[] = {
+	{"name",	"auxio", sizeof("auxio") },
+	{"reg",		(char*)&prop_auxio_reg[0], sizeof(prop_auxio_reg) },
+	{NULL, NULL, -1}
+};
+
+static const int prop_int_reg[] = {
+	0x0, 0x00e00000, 0x00000010,
+	0x0, 0x00e10000, 0x00000010,
+};
+static const struct property propv_obio_int[] = {
+	{"name",	"interrupt", sizeof("interrupt")},
+	{"reg",		(char*)&prop_int_reg[0], sizeof(prop_int_reg) },
+	{NULL, NULL, -1}
+};
+
+static const int prop_cnt_reg[] = {
+	0x0, 0x00d00000, 0x00000010,
+	0x0, 0x00d10000, 0x00000010,
+};
+static const struct property propv_obio_cnt[] = {
+	{"name",	"counter", sizeof("counter")},
+	{"reg",		(char*)&prop_cnt_reg[0], sizeof(prop_cnt_reg) },
+	{NULL, NULL, -1}
+};
+
+static const int prop_eeprom_reg[] = {
+	0x0, 0x00200000, 0x00002000,
+};
+static const struct property propv_obio_eep[] = {
+	{"name",	"eeprom", sizeof("eeprom")},
+	{"reg",		(char*)&prop_eeprom_reg[0], sizeof(prop_eeprom_reg) },
+	{"model",	"mk48t08", sizeof("mk48t08")},
+	{NULL, NULL, -1}
+};
+
+static const int prop_su_reg[] = {
+	0x0, 0x003002f8, 0x00000008,
+};
+static const struct property propv_obio_su[] = {
+	{"name",	"su", sizeof("su")},
+	{"reg",		(char*)&prop_su_reg[0], sizeof(prop_su_reg) },
+	{NULL, NULL, -1}
+};
+
+static const int prop_zs_intr[] = { 12, 0x0 };
+static const int prop_zs_reg[] = {
+	0x0, 0x00000000, 0x00000008,
+};
+static const int prop_zs_addr = { 0x70000000 };
+static const int prop_zs_slave[] = { 1 };
+static const struct property propv_obio_zs[] = {
+	{"name",	"zs", sizeof("zs")},
+	{"reg",		(char*)&prop_zs_reg[0], sizeof(prop_zs_reg) },
+	{"slave",	(char*)&prop_zs_slave[0], sizeof(prop_zs_slave) },
+	{"device_type", "serial", sizeof("serial") },
+	{"intr",	(char*)&prop_zs_intr[0], sizeof(prop_zs_intr) },
+	//	{"address",	(char*)&prop_zs_addr, sizeof(prop_zs_addr) },
+	{NULL, NULL, -1}
+};
+
+static const int prop_zs1_intr[] = { 12, 0x0 };
+static const int prop_zs1_reg[] = {
+	0x0, 0x00100000, 0x00000008,
+};
+static const int prop_zs1_addr = { 0x70100000 };
+static const int prop_zs1_slave[] = { 0 };
+static const struct property propv_obio_zs1[] = {
+	{"name",	"zs", sizeof("zs")},
+	{"reg",		(char*)&prop_zs1_reg[0], sizeof(prop_zs1_reg) },
+	{"slave",	(char*)&prop_zs1_slave[0], sizeof(prop_zs1_slave) },
+	{"device_type", "serial", sizeof("serial") },
+	{"intr",	(char*)&prop_zs1_intr[0], sizeof(prop_zs1_intr) },
+	//	{"address",	(char*)&prop_zs1_addr, sizeof(prop_zs1_addr) },
+	{NULL, NULL, -1}
+};
+
+static const int prop_ledma_reg[] = {
+	0x4, 0x08400010, 0x00000020,
+};
+static const int prop_ledma_burst = 0x3f;
+static const struct property propv_sbus_ledma[] = {
+	{"name",	"ledma", sizeof("ledma")},
+	{"reg",		(char*)&prop_ledma_reg[0], sizeof(prop_ledma_reg) },
+	{"burst-sizes",	(char*)&prop_ledma_burst, sizeof(int) },
+	{NULL, NULL, -1}
+};
+
+static const int prop_le_reg[] = {
+	0x4, 0x08c00000, 0x00000004,
+};
+static const int prop_le_busmaster_regval = 0x7;
+static const int prop_le_intr[] = { 0x26, 0x0 };
+static const struct property propv_sbus_ledma_le[] = {
+	{"name",	"le", sizeof("le")},
+	{"reg",		(char*)&prop_le_reg[0], sizeof(prop_le_reg) },
+	{"busmaster-regval",	(char*)&prop_le_busmaster_regval, sizeof(int)},
+	{"intr",	(char*)&prop_le_intr[0], sizeof(prop_le_intr) },
+	{NULL, NULL, -1}
+};
+
+static const int prop_espdma_reg[] = {
+	0x4, 0x08400000, 0x00000010,
+};
+// Disabled, not implemented yet
+static const struct property propv_sbus_espdma[] = {
+	{"name",	"xxxespdma", sizeof("xxxespdma")}, 
+	{"reg",		(char*)&prop_espdma_reg[0], sizeof(prop_espdma_reg) },
+	{NULL, NULL, -1}
+};
+
+static const int prop_esp_reg[] = {
+	0x4, 0x08800000, 0x00000040,
+};
+static const int prop_esp_intr[] = { 0x24, 0x0 };
+static const struct property propv_sbus_espdma_esp[] = {
+	{"name",	"esp", sizeof("esp")},
+	{"reg",		(char*)&prop_esp_reg[0], sizeof(prop_esp_reg) },
+	{"intr",	(char*)&prop_esp_intr[0], sizeof(prop_esp_intr) },
+	{NULL, NULL, -1}
+};
+
+static const int prop_bpp_reg[] = {
+	0x4, 0x0c800000, 0x0000001c,
+};
+static const int prop_bpp_intr[] = { 0x33, 0x0 };
+static const struct property propv_sbus_bpp[] = {
+	{"name",	"SUNW,bpp", sizeof("SUNW,bpp")},
+	{"reg",		(char*)&prop_bpp_reg[0], sizeof(prop_bpp_reg) },
+	{"intr",	(char*)&prop_bpp_intr[0], sizeof(prop_bpp_intr) },
+	{NULL, NULL, -1}
+};
+
+static const int prop_fd_intr[] = { 0x2b, 0x0 };
+static const int prop_fd_reg[] = {
+	0x0, 0x00400000, 0x0000000f,
+};
+static const struct property propv_obio_fd[] = {
+	{"name",	"SUNW,fdtwo", sizeof("SUNW,fdtwo")},
+	{"reg",		(char*)&prop_fd_reg[0], sizeof(prop_fd_reg) },
+	{"device_type", "block", sizeof("block") },
+	{"intr",	(char*)&prop_fd_intr[0], sizeof(prop_fd_intr) },
+	{NULL, NULL, -1}
+};
+
+static const int prop_pw_intr[] = { 0x22, 0x0 };
+static const int prop_pw_reg[] = {
+	0x0, 0x00910000, 0x00000001,
+};
+static const struct property propv_obio_pw[] = {
+	{"name",	"power", sizeof("power")},
+	{"reg",		(char*)&prop_pw_reg[0], sizeof(prop_pw_reg) },
+	{"intr",	(char*)&prop_pw_intr[0], sizeof(prop_pw_intr) },
+	{NULL, NULL, -1}
+};
+
+static const int prop_cf_reg[] = {
+	0x0, 0x00800000, 0x00000001,
+};
+static const struct property propv_obio_cf[] = {
+	{"name",	"slavioconfig", sizeof("slavioconfig")},
+	{"reg",		(char*)&prop_cf_reg[0], sizeof(prop_cf_reg) },
+	{NULL, NULL, -1}
+};
+
+static const struct node nodes[] = {
+	{ &null_properties,	 1,  0 }, /* 0 = big brother of root */
+	{ propv_root,		 0,  2 }, /*  1 "/" */
+	{ propv_iommu,		11,  3 }, /*  2 "/iommu" */
+	{ propv_sbus,		 0,  4 }, /*  3 "/iommu/sbus" */
+	{ propv_sbus_tcx,	 5,  0 }, /*  4 "/iommu/sbus/SUNW,tcx" */
+	{ propv_sbus_ledma,	 7,  6 }, /*  5 "/iommu/sbus/ledma" */
+	{ propv_sbus_ledma_le,	 0,  0 }, /*  6 "/iommu/sbus/ledma/le" */
+	{ propv_sbus_cs4231,	 8,  0 }, /*  7 "/iommu/sbus/SUNW,CS4231 */
+	{ propv_sbus_bpp,	 9,  0 }, /*  8 "/iommu/sbus/SUNW,bpp */
+	{ propv_sbus_espdma,	 0, 10 }, /*  9 "/iommu/sbus/espdma" */
+	{ propv_sbus_espdma_esp, 0,  0 }, /* 10 "/iommu/sbus/espdma/esp" */
+	{ propv_cpu,		12,  0 }, /* 11 "/STP1012PGA" */
+	{ propv_obio,		 0, 13 }, /* 12 "/obio" */
+	{ propv_obio_int,	14,  0 }, /* 13 "/obio/interrupt" */
+	{ propv_obio_cnt,	15,  0 }, /* 14 "/obio/counter" */
+	{ propv_obio_eep,	16,  0 }, /* 15 "/obio/eeprom" */
+	{ propv_obio_auxio,	17,  0 }, /* 16 "/obio/auxio" */
+	{ propv_obio_zs,	18,  0 }, /* 17 "/obio/zs@0,0" */
+	{ propv_obio_zs1,	19,  0 }, /* 18 "/obio/zs@0,100000" */
+	{ propv_obio_fd,	20,  0 }, /* 19 "/obio/SUNW,fdtwo" */
+	{ propv_obio_pw,	21,  0 }, /* 20 "/obio/power" */
+	{ propv_obio_cf,	 0,  0 }, /* 21 "/obio/slavioconfig@0,800000" */
+#if 0
+	{ propv_obio_su,	14,  0 }, /* 13 "/obio/su" */
+	{ propv_cpu,		18,  0 }, /* 17 "/STP1012PGA" */
+	{ propv_cpu,		19,  0 }, /* 18 "/STP1012PGA" */
+
+	{ propv_cpu,		20,  0 }, /* 19 "/STP1012PGA" */
+	{ propv_cpu,		21,  0 }, /* 20 "/STP1012PGA" */
+	{ propv_cpu,		22,  0 }, /* 21 "/STP1012PGA" */
+	{ propv_cpu,		23,  0 }, /* 22 "/STP1012PGA" */
+	{ propv_cpu,		24,  0 }, /* 23 "/STP1012PGA" */
+	{ propv_cpu,		25,  0 }, /* 24 "/STP1012PGA" */
+	{ propv_cpu,		26,  0 }, /* 25 "/STP1012PGA" */
+	{ propv_cpu,		27,  0 }, /* 26 "/STP1012PGA" */
+	{ propv_cpu,		28,  0 }, /* 27 "/STP1012PGA" */
+	{ propv_cpu,		29,  0 }, /* 28 "/STP1012PGA" */
+	{ propv_cpu,		30,  0 }, /* 29 "/STP1012PGA" */
+#endif
+};
+
+static struct linux_mlist_v0 totphys[MAX_BANKS];
+static struct linux_mlist_v0 totmap[1];
+static struct linux_mlist_v0 totavail[MAX_BANKS];
+
+static struct linux_mlist_v0 *ptphys;
+static struct linux_mlist_v0 *ptmap;
+static struct linux_mlist_v0 *ptavail;
+
+static const struct linux_nodeops nodeops0 = {
+        obp_nextnode,	/* int (*no_nextnode)(int node); */
+        obp_child,	/* int (*no_child)(int node); */
+        obp_proplen,	/* int (*no_proplen)(int node, char *name); */
+        obp_getprop,	/* int (*no_getprop)(int node,char *name,char *val); */
+        obp_setprop,	/* int (*no_setprop)(int node, char *name,
+				 char *val, int len); */
+        obp_nextprop	/* char * (*no_nextprop)(int node, char *name); */
+};
+
+static struct linux_arguments_v0 obp_arg;
+static const struct linux_arguments_v0 * const obp_argp = &obp_arg;
+
+static void (*synch_hook)(void);
+static char obp_stdin, obp_stdout;
+
+static int obp_nbgetchar(void);
+static int obp_nbputchar(int ch);
+static void obp_reboot(char *);
+static void obp_abort(void);
+static void obp_halt(void);
+static int obp_devopen(char *str);
+static int obp_devclose(int dev_desc);
+static int obp_rdblkdev(int dev_desc, int num_blks, int blk_st, char *buf);
+
+static void doublewalk(unsigned ptab1, unsigned va)
+{
+unsigned int proc_tablewalk(int ctx, unsigned int va);
+unsigned int mem_tablewalk(unsigned int pa, unsigned int va);
+
+	proc_tablewalk(0, va);
+	if (ptab1 != 0) mem_tablewalk(ptab1, va);
+}
+
+static struct linux_romvec romvec0;
+
+void *
+init_openprom_qemu(int bankc, struct bank *bankv, unsigned hiphybas,
+		   const char *cmdline, char boot_device, int nographic)
+{
+	int i;
+
+	/*
+	 * Avoid data segment allocations
+	 */
+	ptphys = totphys;
+	ptmap = totmap;
+	ptavail = totavail;
+	/*
+	 * Form memory descriptors.
+	 */
+	for (i = 0; i < bankc; i++) {
+		totphys[i].theres_more = &totphys[i+1];
+		totphys[i].start_adr = (char*) bankv[i].start;
+		totphys[i].num_bytes = bankv[i].length;
+	}
+	totphys[i-1].theres_more = 0;
+
+	/*
+	 * XXX Merged in normal PROM when full banks touch.
+	 */
+	for (i = 0; i < bankc; i++) {
+		unsigned bankbase = bankv[i].start;
+		unsigned banksize = bankv[i].length;
+		if (hiphybas > bankbase &&
+		    hiphybas < bankbase + banksize) {
+			banksize = hiphybas - bankbase;
+		}
+		totavail[i].theres_more = &totavail[i+1];
+		totavail[i].start_adr = (char*) bankbase;
+		totavail[i].num_bytes = banksize;
+	}
+	totavail[i-1].theres_more = 0;
+
+	totmap[0].theres_more = 0;
+	totmap[0].start_adr = (char*) PROLBASE;
+	totmap[0].num_bytes = PROLSIZE;
+
+	/*
+	 * idprom
+	 */
+	bcopy(idprom, obp_idprom, IDPROM_SIZE);
+
+	// Linux wants a R/W romvec table
+	romvec0.pv_magic_cookie = LINUX_OPPROM_MAGIC;
+	romvec0.pv_plugin_revision = 77;
+	romvec0.pv_printrev = 0x10203;
+	romvec0.pv_v0mem.v0_totphys = &ptphys;
+	romvec0.pv_v0mem.v0_prommap = &ptmap;
+	romvec0.pv_v0mem.v0_available = &ptavail;
+	romvec0.pv_nodeops = &nodeops0;
+	romvec0.pv_bootstr = (void *)doublewalk;
+	romvec0.pv_v0devops.v0_devopen = &obp_devopen;
+	romvec0.pv_v0devops.v0_devclose = &obp_devclose;
+	romvec0.pv_v0devops.v0_rdblkdev = &obp_rdblkdev;
+	romvec0.pv_stdin = &obp_stdin;
+	romvec0.pv_stdout = &obp_stdout;
+	romvec0.pv_getchar = obp_nbgetchar;
+	romvec0.pv_putchar = (void (*)(int))obp_nbputchar;
+	romvec0.pv_nbgetchar = obp_nbgetchar;
+	romvec0.pv_nbputchar = obp_nbputchar;
+	romvec0.pv_reboot = obp_reboot;
+	romvec0.pv_abort = obp_abort;
+	romvec0.pv_halt = obp_halt;
+	romvec0.pv_synchook = &synch_hook;
+	romvec0.pv_v0bootargs = &obp_argp;
+	switch(boot_device) {
+	default:
+	case 'a':
+	    obp_arg.argv[0] = "fd()";
+	    break;
+	case 'c':
+	    obp_arg.argv[0] = "sd()";
+	    break;
+	case 'n':
+	    obp_arg.argv[0] = "le()";
+	    break;
+	}
+	obp_arg.argv[1] = cmdline;
+
+	if (nographic) {
+	    obp_stdin = PROMDEV_TTYA;
+	    obp_stdout = PROMDEV_TTYA;
+	} else {
+	    obp_stdin = PROMDEV_KBD;
+	    obp_stdout = PROMDEV_SCREEN;
+	}
+	return &romvec0;
+}
+
+static const struct property *find_property(int node,char *name)
+{
+	const struct property *prop = &nodes[node].properties[0];
+	while (prop && prop->name) {
+		if (bcmp(prop->name, name, 128) == 0) return prop;
+		prop++;
+	}
+	return NULL;
+}
+
+static int obp_nextnode(int node)
+{
+#ifdef DEBUG_OBP
+        printk("obp_nextnode(%d) = %d\n", node, nodes[node].sibling);
+#endif
+	return nodes[node].sibling;
+}
+
+static int obp_child(int node)
+{
+#ifdef DEBUG_OBP
+        printk("obp_child(%d) = %d\n", node, nodes[node].child);
+#endif
+	return nodes[node].child;
+}
+
+static int obp_proplen(int node, char *name)
+{
+	const struct property *prop = find_property(node,name);
+	if (prop) {
+#ifdef DEBUG_OBP
+	    printk("obp_proplen(%d, %s) = %d\n", node, name, prop->length);
+#endif
+	    return prop->length;
+	}
+#ifdef DEBUG_OBP
+	printk("obp_proplen(%d, %s) (no prop)\n", node, name);
+#endif
+	return -1;
+}
+
+static int obp_getprop(int node, char *name, char *value)
+{
+	const struct property *prop;
+
+	prop = find_property(node,name);
+	if (prop) {
+		memcpy(value,prop->value,prop->length);
+#ifdef DEBUG_OBP
+		printk("obp_getprop(%d, %s) = %s\n", node, name, value);
+#endif
+		return prop->length;
+	}
+#ifdef DEBUG_OBP
+        printk("obp_getprop(%d, %s): not found\n", node, name);
+#endif
+	return -1;
+}
+
+static int obp_setprop(int node, char *name, char *value, int len)
+{
+#ifdef DEBUG_OBP
+        printk("obp_setprop(%d, %s) = %s (%d)\n", node, name, value, len);
+#endif
+	return -1;
+}
+
+static const char *obp_nextprop(int node,char *name)
+{
+	const struct property *prop = find_property(node,name);
+	if (prop) {
+#ifdef DEBUG_OBP
+	    printk("obp_nextprop(%d, %s) = %s\n", node, name, prop[1].name);
+#endif
+	    return prop[1].name;
+	}
+#ifdef DEBUG_OBP
+        printk("obp_nextprop(%d, %s): not found\n", node, name);
+#endif
+	return NULL;
+}
+
+static int obp_nbgetchar(void) {
+	extern struct vconterm dp0;
+	return vcon_getch(&dp0);
+}
+
+static int obp_nbputchar(int ch) {
+	printk("%c", ch);
+	return 0;
+}
+
+static void obp_reboot(char *str) {
+	printk("rebooting (%s): not implemented, freezing\n", str);
+	for (;;) {}
+}
+
+static void obp_abort() {
+	printk("abort, freezing\n");
+	for (;;) {}
+}
+
+static void obp_halt() {
+	printk("halt, freezing\n");
+	for (;;) {}
+}
+
+static int obp_devopen(char *str) {
+#ifdef DEBUG_OBP
+        printk("open %s\n", str);
+#endif
+	return 0;
+}
+
+static int obp_devclose(int dev_desc) {
+#ifdef DEBUG_OBP
+        printk("close %d\n", dev_desc);
+#endif
+	return 0;
+}
+
+static int obp_rdblkdev(int dev_desc, int num_blks, int blk_st, char *buf) {
+#ifdef DEBUG_OBP
+    printk("rdblkdev: fd %d, num_blks %d, blk_st %d, buf 0x%x\n", dev_desc, num_blks, blk_st, buf);
+#endif
+    //buf[8] = 'L';
+    return num_blks;
+}
diff -ruN proll_18.orig/qemu/system_qemu.c proll-patch7/qemu/system_qemu.c
--- proll_18.orig/qemu/system_qemu.c	1970-01-01 00:00:00.000000000 +0000
+++ proll-patch7/qemu/system_qemu.c	2005-03-02 16:10:20.000000000 +0000
@@ -0,0 +1,416 @@
+/**
+ ** Proll (PROM replacement)
+ ** system.c: shared miscallenea.
+ ** Copyright 1999 Pete Zaitcev
+ ** This code is licensed under GNU General Public License.
+ **/
+#include <stdarg.h>
+#include <asi.h>
+#include <crs.h>
+#ifndef NULL
+#define	NULL ((void*)0)
+#endif
+
+#include "pgtsrmmu.h"
+
+#include "vconsole.h"
+#include <timer.h>		/* Local copy of 2.2 style include */
+#include <general.h>		/* __P() */
+#include <net.h>		/* init_net() */
+#include <romlib.h>		/* we are a provider for part of this. */
+#include <netpriv.h>		/* myipaddr */
+#include <arpa.h>
+#include <system.h>		/* our own prototypes */
+
+/*
+ * We export this.
+ */
+char idprom[IDPROM_SIZE];
+
+
+/*
+ * Create an I/O mapping to pa[size].
+ * Returns va of the mapping or 0 if unsuccessful.
+ */
+void *
+map_io(unsigned pa, int size)
+{
+	void *va;
+	unsigned int npages;
+	unsigned int off;
+	unsigned int mva;
+
+	off = pa & (PAGE_SIZE-1);
+	npages = (off + size + (PAGE_SIZE-1)) / PAGE_SIZE;
+	pa &= ~(PAGE_SIZE-1);
+
+	va = mem_alloc(&cio, npages*PAGE_SIZE, PAGE_SIZE);
+	if (va == 0) return va;
+
+	mva = (unsigned int) va;
+    /* printk("map_io: va 0x%x pa 0x%x off 0x%x npages %d\n", va, pa, off, npages); */ /* P3 */
+	while (npages-- != 0) {
+		map_page(pmem.pl1, mva, pa, 1, pmem.pbas);
+		mva += PAGE_SIZE;
+		pa += PAGE_SIZE;
+	}
+
+	return (void *)((unsigned int)va + off);
+}
+
+/*
+ * Tablewalk routine used for testing.
+ * Returns PTP/PTE.
+ */
+unsigned int
+proc_tablewalk(int ctx, unsigned int va)
+{
+	unsigned int pa1;
+
+	__asm__ __volatile__ ("lda [%1] %2, %0" :
+				"=r" (pa1) :
+				"r" (AC_M_CTPR), "i" (ASI_M_MMUREGS));
+	/* printk(" ctpr %x ctx %x\n", pa1, ctx); */ /* P3 */
+	pa1 <<= 4;
+	pa1 = ld_bypass(pa1 + (ctx << 2));
+	if ((pa1 & 0x03) == 0) goto invalid;
+	return mem_tablewalk((pa1 & 0xFFFFFFF0) << 4, va);
+
+invalid:
+	printk(" invalid %x\n", pa1);
+	return 0;
+}
+
+/*
+ * Walk the tables in memory, starting at physical address pa.
+ */
+unsigned int
+mem_tablewalk(unsigned int pa, unsigned int va)
+{
+	unsigned int pa1;
+
+	printk("pa %x va %x", pa, va);
+	pa1 = ld_bypass(pa + (((va&0xFF000000)>>24) << 2));
+	if ((pa1 & 0x03) == 0) goto invalid;
+	printk(" l1 %x", pa1);
+	pa1 <<= 4;    pa1 &= 0xFFFFFF00;
+	pa1 = ld_bypass(pa1 + (((va&0x00FC0000)>>18) << 2));
+	if ((pa1 & 0x03) == 0) goto invalid;
+	printk(" l2 %x", pa1);
+	pa1 <<= 4;    pa1 &= 0xFFFFFF00;
+	pa1 = ld_bypass(pa1 + (((va&0x0003F000)>>12) << 2));
+	if ((pa1 & 0x03) == 0) goto invalid;
+	printk(" l3 %x", pa1);
+	printk(" off %x\n", va&0x00000FFF);
+	return pa1;
+invalid:
+	printk(" invalid %x\n", pa1);
+	return 0;
+}
+
+/*
+ * Make CPU page tables.
+ * Returns pointer to context table.
+ * Here we ignore memory allocation errors which "should not happen"
+ * because we cannot print anything anyways if memory initialization fails.
+ */
+void makepages(struct phym *t, unsigned int highbase)
+{
+	unsigned int *ctp, *l1, pte;
+	int i;
+	unsigned int pa, va;
+
+	ctp = mem_zalloc(&cmem, NCTX_SWIFT*sizeof(int), NCTX_SWIFT*sizeof(int));
+	l1 = mem_zalloc(&cmem, 256*sizeof(int), 256*sizeof(int));
+
+	pte = SRMMU_ET_PTD | (((unsigned int)l1 - PROLBASE + highbase) >> 4);
+	for (i = 0; i < NCTX_SWIFT; i++) {
+		ctp[i] = pte;
+	}
+
+	pa = PROLBASE;
+	for (va = PROLBASE; va < PROLDATA; va += PAGE_SIZE) {
+	        map_page(l1, va, pa, 0, highbase);
+		pa += PAGE_SIZE;
+	}
+	pa = highbase + PROLDATA - PROLBASE;
+	for (va = PROLDATA; va < PROLBASE + PROLSIZE; va += PAGE_SIZE) {
+		map_page(l1, va, pa, 0, highbase);
+		pa += PAGE_SIZE;
+	}
+
+	/* We need to start from LOADBASE, but kernel wants PAGE_SIZE. */
+	pa = 0;
+	for (va = 0; va < LOWMEMSZ; va += PAGE_SIZE) {
+		map_page(l1, va, pa, 0, highbase);
+		pa += PAGE_SIZE;
+	}
+
+	t->pctp = ctp;
+	t->pl1 = l1;
+	t->pbas = highbase;
+}
+
+/*
+ * Create a memory mapping from va to epa in page table pgd.
+ * highbase is used for v2p translation.
+ */
+int
+map_page(unsigned int *pgd, unsigned int va,
+    unsigned int epa, int type, unsigned int highbase)
+{
+	unsigned int pte;
+	unsigned int *p;
+	unsigned int pa;
+
+	pte = pgd[((va)>>SRMMU_PGDIR_SHIFT) & (SRMMU_PTRS_PER_PGD-1)];
+	if ((pte & SRMMU_ET_MASK) == SRMMU_ET_INVALID) {
+		p = mem_zalloc(&cmem, SRMMU_PTRS_PER_PMD*sizeof(int),
+		    SRMMU_PTRS_PER_PMD*sizeof(int));
+		if (p == 0) goto drop;
+		pte = SRMMU_ET_PTD |
+		    (((unsigned int)p - PROLBASE + highbase) >> 4);
+		pgd[((va)>>SRMMU_PGDIR_SHIFT) & (SRMMU_PTRS_PER_PGD-1)] = pte;
+		/* barrier() */
+	}
+
+	pa = ((pte & 0xFFFFFFF0) << 4);
+	pa += (((va)>>SRMMU_PMD_SHIFT & (SRMMU_PTRS_PER_PMD-1)) << 2);
+	pte = ld_bypass(pa);
+	if ((pte & SRMMU_ET_MASK) == SRMMU_ET_INVALID) {
+		p = mem_zalloc(&cmem, SRMMU_PTRS_PER_PTE*sizeof(int),
+		    SRMMU_PTRS_PER_PTE*sizeof(int));
+		if (p == 0) goto drop;
+		pte = SRMMU_ET_PTD |
+		    (((unsigned int)p - PROLBASE + highbase) >> 4);
+		st_bypass(pa, pte);
+	}
+
+	pa = ((pte & 0xFFFFFFF0) << 4);
+	pa += (((va)>>PAGE_SHIFT & (SRMMU_PTRS_PER_PTE-1)) << 2);
+
+	pte = SRMMU_ET_PTE | ((epa & PAGE_MASK) >> 4);
+	if (type) {		/* I/O */
+		pte |= SRMMU_REF;
+		/* SRMMU cannot make Supervisor-only, but not exectutable */
+		pte |= SRMMU_PRIV;
+	} else {		/* memory */
+		pte |= SRMMU_REF|SRMMU_CACHE;
+		pte |= SRMMU_PRIV;		/* Supervisor only access */
+	}
+	st_bypass(pa, pte);
+	return 0;
+
+drop:
+	return -1;
+}
+
+/*
+ * Switch page tables.
+ */
+void
+init_mmu_swift(unsigned int ctp_phy)
+{
+	unsigned int addr;
+
+	/*
+	 * Flush cache
+	 */
+	for (addr = 0; addr < 0x2000; addr += 0x10) {
+		__asm__ __volatile__ ("sta %%g0, [%0] %1\n\t" : :
+		    "r" (addr), "i" (ASI_M_DATAC_TAG));
+		__asm__ __volatile__ ("sta %%g0, [%0] %1\n\t" : :
+		    "r" (addr<<1), "i" (ASI_M_TXTC_TAG));
+	}
+
+	/*
+	 * Switch ctx table
+	 */
+	ctp_phy >>= 4;
+	/* printk("done flushing, switching to %x\n", ctp_phy); */
+	__asm__ __volatile__ ("sta %0, [%1] %2\n\t" : :
+	    "r" (ctp_phy), "r" (AC_M_CTPR), "i" (ASI_M_MMUREGS));
+
+	/*
+	 * Flush old page table references
+	 */
+	__asm__ __volatile__ ("sta %%g0, [%0] %1\n\t" : :
+	    "r" (0x400), "i" (ASI_M_FLUSH_PROBE) : "memory");
+}
+
+/*
+ * add_timer, del_timer
+ * This should go into sched.c, but we have it split for different archs.
+ */
+struct timer_list_head {
+	struct timer_list *head, *tail;
+};
+
+static struct timer_list_head timers;		/* Anonymous heap of timers */
+
+void add_timer(struct timer_list *timer) {
+	struct timer_list *p;
+	if (timer->prev != NULL || timer->next != NULL) {
+		printk("bug: kernel timer added twice at 0x%x.\n",
+		    __builtin_return_address(0));
+		return;
+	}
+	if ((p = timers.tail) != NULL) {
+		timer->prev = p;
+		p->next = timer;
+		timers.tail = timer;
+	} else {
+		timers.head = timer;
+		timers.tail = timer;
+	}
+	return;
+}
+
+int del_timer(struct timer_list *timer) {
+	struct timer_list *p;
+	int ret;
+
+	if (timers.head == timer) timers.head = timer->next;
+	if (timers.tail == timer) timers.tail = timer->prev;
+	if ((p = timer->prev) != NULL) p->next = timer->next;
+	if ((p = timer->next) != NULL) p->prev = timer->prev;
+	ret = timer->next != 0 || timer->prev != 0;
+	timer->next = NULL;
+	timer->prev = NULL;
+	return ret;
+}
+
+void run_timers() {
+	struct timer_list *p;
+
+	p = timers.head;
+	while (p != NULL) {
+		if (p->expires < jiffies) {
+			del_timer(p);		/* XXX make nonstatic member */
+			(*p->function)(p->data);
+			p = timers.head;
+		} else {
+			p = p->next;
+		}
+	}
+}
+
+/*
+ * Allocate memory. This is reusable.
+ */
+void mem_init(struct mem *t, char *begin, char *limit)
+{
+	t->start = begin;
+	t->uplim = limit;
+	t->curp = begin;
+}
+
+void mem_fini(struct mem *t)
+{
+	t->curp = 0;
+}
+
+void *mem_alloc(struct mem *t, int size, int align)
+{
+	char *p;
+
+	p = (char *)((((unsigned int)t->curp) + (align-1)) & ~(align-1));
+	if (p >= t->uplim || p + size > t->uplim) return 0;
+	t->curp = p + size;
+	return p;
+}
+
+void *mem_zalloc(struct mem *t, int size, int align)
+{
+	char *p;
+
+	if ((p = mem_alloc(t, size, align)) != 0) bzero(p, size);
+	return p;
+}
+
+/*
+ * Library functions
+ */
+void bzero(void *s, int len) {
+	while (len--) *((char *)s)++ = 0;
+}
+
+void bcopy(const void *f, void *t, int len) {
+	while (len--) *((char *)t)++ = *((char *)f)++;
+}
+
+/* Comparison is 7-bit */
+int bcmp(const void *s1, const void *s2, int len)
+{
+	int i;
+	char ch;
+
+	while (len--) {
+		ch = *((char *)s1)++;
+		if ((i = ch - *((char *)s2)++) != 0)
+			return i;
+		if (ch == 0)
+			return 0;
+	}
+	return 0;
+}
+
+int strlen(const char *s) {
+	const char *p;
+	for (p = s; *p != 0; p++) { }
+	return p - s;
+}
+
+extern void *printk_fn;
+
+void printk(char *fmt, ...)
+{
+	struct prf_fp {
+		void *xfp;
+		void (*write)(void *, char *, int);
+	} prfa;
+	extern void prf(struct prf_fp *, char *fmt, va_list adx);
+	va_list x1;
+
+	va_start(x1, fmt);
+	prfa.xfp = &dp0;
+	prfa.write = printk_fn;
+	prf(&prfa, fmt, x1);
+	va_end(x1);
+}
+
+void fatal()
+{
+	printk("fatal.");
+loop: goto loop;
+}
+
+/*
+ * Get the highest bit number from the mask.
+ */
+int highc(int mask, int size)
+{
+	int m1;
+
+	m1 = 1 << size;
+	while (size != 0) {
+		size--;
+		m1 >>= 1;
+		if (m1 & mask) break;
+	}
+	return size;
+}
+
+/*
+ */
+unsigned int ld_bp_swap(unsigned int ptr) {
+	unsigned int n;
+	n = ld_bypass(ptr);
+	n = (n>>24 & 0xFF) | (n>>8 & 0xFF00) | ((n&0xFF00) << 8) | (n<<24);
+	return n;
+}
+
+void st_bp_swap(unsigned int ptr, unsigned int n) {
+	n = (n>>24 & 0xFF) | (n>>8 & 0xFF00) | ((n&0xFF00) << 8) | (n<<24);
+	st_bypass(ptr, n);
+};
diff -ruN proll_18.orig/src/arp.c proll-patch7/src/arp.c
--- proll_18.orig/src/arp.c	2001-12-24 05:12:31.000000000 +0000
+++ proll-patch7/src/arp.c	2004-11-13 15:50:49.000000000 +0000
@@ -45,7 +45,7 @@
 #endif
 static struct arp_cache arp_list[ARPNUM];	/* ARP address cache	*/
 static int next_arp;				/* next table entry	*/
-static t_ipaddr def_gw = IP_ANY;		/* default routing	*/
+static t_ipaddr def_gw;				/* default routing	*/
 
 
 
@@ -144,7 +144,7 @@
  * 
  * Resolve IP address and return pointer to hardware address.
  */
-unsigned char *ip_resolve(ip)
+const unsigned char *ip_resolve(ip)
 t_ipaddr ip;
 {
   int i;
@@ -230,14 +230,11 @@
  */
 int init_arp()
 {
-  /* Set name of module for error messages */
-  net_module_name = "arp";
-
 #ifndef NOARP
   /* Register ARP packet type and set send buffer pointer */
   if ((arpbuf = (struct arphdr *)reg_type(htons(ETH_P_ARP), arp_recv)) == NULL)
 	return(FALSE);
 #endif
-
+  def_gw = IP_ANY;
   return(TRUE);
 }
diff -ruN proll_18.orig/src/arp.h proll-patch7/src/arp.h
--- proll_18.orig/src/arp.h	1999-03-18 03:39:43.000000000 +0000
+++ proll-patch7/src/arp.h	2004-11-13 15:50:49.000000000 +0000
@@ -104,7 +104,7 @@
 extern int init_arp __P((void));
 
 /* Resolve IP address and return pointer to hardware address */
-extern unsigned char *ip_resolve __P((t_ipaddr ip));
+extern const unsigned char *ip_resolve __P((t_ipaddr ip));
 
 /* Add a new antry to the ARP cache */
 extern void addcache __P((unsigned char *ha, t_ipaddr ip));
diff -ruN proll_18.orig/src/hconsole.c proll-patch7/src/hconsole.c
--- proll_18.orig/src/hconsole.c	2002-07-23 05:52:48.000000000 +0000
+++ proll-patch7/src/hconsole.c	2005-03-02 17:03:09.000000000 +0000
@@ -29,6 +29,10 @@
        struct raster r_master;	/* For a case of resize, whole fb */
        struct raster r_0;	/* malloc() erzatz */
 
+#ifdef QEMU
+extern unsigned int q_height, q_width;
+#endif
+
 int hcon_init(struct hconsole *t, unsigned int a0)
 {
 	struct raster *q, *r;
@@ -42,7 +46,11 @@
  	 * No probing sequence or argument passing, hardcode everything. XXX
 	 */
 	raster8_cons_a(q, 768, 1024, (char *)a0);
+#ifndef QEMU
 	raster_cons_2(r, q, 768-(24*11)-1, 1024-(8*80)-1, (24*11), (8*80));
+#else
+	raster_cons_2(r, q, 0, 0, q_height, q_width);
+#endif
 	t->r_ = r;
 	t->r0_ = q;
 	t->f_ = &f_master;
diff -ruN proll_18.orig/src/lat7_2.bm proll-patch7/src/lat7_2.bm
--- proll_18.orig/src/lat7_2.bm	1999-02-27 05:48:54.000000000 +0000
+++ proll-patch7/src/lat7_2.bm	2004-11-13 15:50:49.000000000 +0000
@@ -1,6 +1,6 @@
 #define lat7_2_width 128
 #define lat7_2_height 88
-static unsigned char lat7_2_bits[] = {
+static unsigned const char lat7_2_bits[] = {
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0xaa, 0x12, 0x1e, 0x0c, 0x02, 0x70, 0x18,
    0x22, 0x22, 0x18, 0x00, 0x00, 0x18, 0x18, 0xff, 0x18, 0x00, 0x12, 0x02,
diff -ruN proll_18.orig/src/lat7_2_swapped.bm proll-patch7/src/lat7_2_swapped.bm
--- proll_18.orig/src/lat7_2_swapped.bm	1970-01-01 00:00:00.000000000 +0000
+++ proll-patch7/src/lat7_2_swapped.bm	2004-11-13 15:50:49.000000000 +0000
@@ -0,0 +1,121 @@
+#define lat7_2_width 128
+#define lat7_2_height 88
+static unsigned const char lat7_2_bits[] = {
+   0x00, 0x00, 0x18, 0x3c, 0x7e, 0x3c, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 
+   0x55, 0x00, 0x2a, 0x00, 0x55, 0x00, 0x2a, 0x00, 0x55, 0x00, 0x00, 0x48, 
+   0x48, 0x78, 0x48, 0x5f, 0x04, 0x04, 0x04, 0x04, 0x00, 0x00, 0x78, 0x40, 
+   0x70, 0x40, 0x4f, 0x08, 0x0e, 0x08, 0x08, 0x00, 0x00, 0x30, 0x40, 0x40, 
+   0x40, 0x3e, 0x09, 0x0e, 0x0a, 0x09, 0x00, 0x00, 0x40, 0x40, 0x40, 0x40, 
+   0x7f, 0x08, 0x0e, 0x08, 0x08, 0x00, 0x00, 0x0e, 0x0a, 0x0e, 0x00, 0x00, 
+   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x7e, 0x18, 0x18, 0x00, 
+   0x7e, 0x00, 0x00, 0x00, 0x00, 0x44, 0x64, 0x54, 0x4c, 0x54, 0x10, 0x10, 
+   0x10, 0x1f, 0x00, 0x00, 0x44, 0x44, 0x44, 0x28, 0x1f, 0x04, 0x04, 0x04, 
+   0x04, 0x00, 0x00, 0x18, 0x18, 0x18, 0x18, 0xf8, 0x00, 0x00, 0x00, 0x00, 
+   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf8, 0x18, 0x18, 0x18, 0x18, 0x00, 
+   0x00, 0x00, 0x00, 0x00, 0x00, 0x1f, 0x18, 0x18, 0x18, 0x18, 0x00, 0x00, 
+   0x18, 0x18, 0x18, 0x18, 0x1f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 
+   0x18, 0x18, 0x18, 0xff, 0x18, 0x18, 0x18, 0x18, 0x00, 0x00, 0xff, 0x00, 
+   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 
+   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+   0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+   0x00, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+   0x00, 0x00, 0xff, 0x00, 0x00, 0x18, 0x18, 0x18, 0x18, 0x1f, 0x18, 0x18, 
+   0x18, 0x18, 0x00, 0x00, 0x18, 0x18, 0x18, 0x18, 0xf8, 0x18, 0x18, 0x18, 
+   0x18, 0x00, 0x00, 0x18, 0x18, 0x18, 0x18, 0xff, 0x00, 0x00, 0x00, 0x00, 
+   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0x18, 0x18, 0x18, 0x18, 0x00, 
+   0x00, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x00, 0x00, 
+   0x06, 0x0c, 0x18, 0x30, 0x18, 0x6c, 0x36, 0x18, 0x0c, 0x00, 0x00, 0x60, 
+   0x30, 0x18, 0x0c, 0x18, 0x36, 0x6c, 0x18, 0x30, 0x00, 0x00, 0x7f, 0x36, 
+   0x36, 0x36, 0x36, 0x36, 0x36, 0x00, 0x00, 0x00, 0x00, 0x02, 0x04, 0x7e, 
+   0x18, 0x7e, 0x20, 0x40, 0x00, 0x00, 0x00, 0x00, 0x1c, 0x36, 0x30, 0x78, 
+   0x30, 0x72, 0x7e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 
+   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x42, 
+   0x7e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+   0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x18, 0x18, 0x18, 0x00, 0x18, 0x00, 
+   0x00, 0x00, 0x00, 0x66, 0x66, 0x22, 0x44, 0x00, 0x00, 0x00, 0x00, 0x00, 
+   0x00, 0x00, 0x36, 0x7f, 0x36, 0x36, 0x36, 0x7f, 0x36, 0x00, 0x00, 0x00, 
+   0x00, 0x66, 0x3c, 0x66, 0x66, 0x66, 0x3c, 0x66, 0x00, 0x00, 0x00, 0x00, 
+   0x72, 0x56, 0x6c, 0x18, 0x36, 0x6a, 0x4e, 0x00, 0x00, 0x00, 0x00, 0x18, 
+   0x24, 0x28, 0x30, 0x4a, 0x44, 0x3a, 0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 
+   0x08, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0c, 0x18, 0x18, 
+   0x18, 0x18, 0x18, 0x0c, 0x00, 0x00, 0x00, 0x00, 0x30, 0x18, 0x18, 0x18, 
+   0x18, 0x18, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x66, 0x3c, 0x7e, 0x3c, 
+   0x66, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x7e, 0x18, 0x18, 
+   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 
+   0x08, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7e, 0x00, 0x00, 0x00, 0x00, 
+   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x00, 0x00, 
+   0x00, 0x00, 0x02, 0x06, 0x0c, 0x18, 0x30, 0x60, 0x40, 0x00, 0x00, 0x00, 
+   0x00, 0x3c, 0x46, 0x4e, 0x5a, 0x72, 0x62, 0x3c, 0x00, 0x00, 0x00, 0x00, 
+   0x18, 0x38, 0x58, 0x18, 0x18, 0x18, 0x3c, 0x00, 0x00, 0x00, 0x00, 0x3c, 
+   0x66, 0x06, 0x0c, 0x18, 0x32, 0x7e, 0x00, 0x00, 0x00, 0x00, 0x3c, 0x66, 
+   0x06, 0x1c, 0x06, 0x66, 0x3c, 0x00, 0x00, 0x00, 0x00, 0x0c, 0x18, 0x30, 
+   0x66, 0x7e, 0x06, 0x06, 0x00, 0x00, 0x00, 0x00, 0x7e, 0x60, 0x7c, 0x66, 
+   0x06, 0x66, 0x3c, 0x00, 0x00, 0x00, 0x00, 0x3c, 0x60, 0x7c, 0x66, 0x66, 
+   0x66, 0x3c, 0x00, 0x00, 0x00, 0x00, 0x7e, 0x46, 0x06, 0x0c, 0x18, 0x30, 
+   0x30, 0x00, 0x00, 0x00, 0x00, 0x3c, 0x66, 0x66, 0x3c, 0x66, 0x66, 0x3c, 
+   0x00, 0x00, 0x00, 0x00, 0x3c, 0x66, 0x66, 0x66, 0x3e, 0x06, 0x3c, 0x00, 
+   0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x00, 0x18, 0x18, 0x00, 0x00, 
+   0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x00, 0x18, 0x18, 0x08, 0x10, 0x00, 
+   0x00, 0x0c, 0x18, 0x30, 0x60, 0x30, 0x18, 0x0c, 0x00, 0x00, 0x00, 0x00, 
+   0x00, 0x00, 0x7e, 0x00, 0x7e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 
+   0x18, 0x0c, 0x06, 0x0c, 0x18, 0x30, 0x00, 0x00, 0x00, 0x00, 0x3c, 0x66, 
+   0x06, 0x0c, 0x18, 0x00, 0x18, 0x00, 0x00, 0x00, 0x00, 0x3c, 0x42, 0x5e, 
+   0x56, 0x5e, 0x40, 0x3c, 0x00, 0x00, 0x00, 0x00, 0x18, 0x3c, 0x66, 0x66, 
+   0x7e, 0x66, 0x66, 0x00, 0x00, 0x00, 0x00, 0x7c, 0x66, 0x66, 0x7c, 0x66, 
+   0x66, 0x7c, 0x00, 0x00, 0x00, 0x00, 0x3c, 0x66, 0x60, 0x60, 0x60, 0x66, 
+   0x3c, 0x00, 0x00, 0x00, 0x00, 0x7c, 0x66, 0x66, 0x66, 0x66, 0x66, 0x7c, 
+   0x00, 0x00, 0x00, 0x00, 0x7e, 0x62, 0x60, 0x78, 0x60, 0x62, 0x7e, 0x00, 
+   0x00, 0x00, 0x00, 0x7e, 0x62, 0x60, 0x78, 0x60, 0x60, 0x60, 0x00, 0x00, 
+   0x00, 0x00, 0x3c, 0x66, 0x60, 0x6e, 0x66, 0x66, 0x3e, 0x00, 0x00, 0x00, 
+   0x00, 0x66, 0x66, 0x66, 0x7e, 0x66, 0x66, 0x66, 0x00, 0x00, 0x00, 0x00, 
+   0x3c, 0x18, 0x18, 0x18, 0x18, 0x18, 0x3c, 0x00, 0x00, 0x00, 0x00, 0x7e, 
+   0x46, 0x06, 0x06, 0x06, 0x66, 0x3c, 0x00, 0x00, 0x00, 0x00, 0x66, 0x6c, 
+   0x78, 0x70, 0x78, 0x6c, 0x66, 0x00, 0x00, 0x00, 0x00, 0x60, 0x60, 0x60, 
+   0x60, 0x60, 0x62, 0x7e, 0x00, 0x00, 0x00, 0x00, 0x41, 0x63, 0x77, 0x7f, 
+   0x6b, 0x63, 0x63, 0x00, 0x00, 0x00, 0x00, 0x66, 0x66, 0x76, 0x7e, 0x6e, 
+   0x66, 0x66, 0x00, 0x00, 0x00, 0x00, 0x3c, 0x66, 0x66, 0x66, 0x66, 0x66, 
+   0x3c, 0x00, 0x00, 0x00, 0x00, 0x7c, 0x66, 0x66, 0x66, 0x7c, 0x60, 0x60, 
+   0x00, 0x00, 0x00, 0x00, 0x3c, 0x66, 0x66, 0x66, 0x66, 0x6e, 0x3c, 0x02, 
+   0x00, 0x00, 0x00, 0x7c, 0x66, 0x66, 0x66, 0x7c, 0x6c, 0x66, 0x00, 0x00, 
+   0x00, 0x00, 0x3c, 0x66, 0x60, 0x3c, 0x06, 0x66, 0x3c, 0x00, 0x00, 0x00, 
+   0x00, 0x7e, 0x5a, 0x18, 0x18, 0x18, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00, 
+   0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x3c, 0x00, 0x00, 0x00, 0x00, 0x66, 
+   0x66, 0x66, 0x66, 0x66, 0x3c, 0x18, 0x00, 0x00, 0x00, 0x00, 0x63, 0x63, 
+   0x63, 0x6b, 0x6b, 0x7f, 0x36, 0x00, 0x00, 0x00, 0x00, 0x66, 0x66, 0x3c, 
+   0x18, 0x3c, 0x66, 0x66, 0x00, 0x00, 0x00, 0x00, 0x66, 0x66, 0x66, 0x3c, 
+   0x18, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00, 0x7e, 0x46, 0x0c, 0x18, 0x30, 
+   0x62, 0x7e, 0x00, 0x00, 0x00, 0x00, 0x3c, 0x30, 0x30, 0x30, 0x30, 0x30, 
+   0x3c, 0x00, 0x00, 0x00, 0x00, 0x40, 0x60, 0x30, 0x18, 0x0c, 0x06, 0x02, 
+   0x00, 0x00, 0x00, 0x00, 0x3c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x3c, 0x00, 
+   0x00, 0x00, 0x00, 0x18, 0x3c, 0x66, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7e, 0x00, 0x00, 0x00, 
+   0x00, 0x08, 0x10, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+   0x00, 0x3c, 0x06, 0x3e, 0x66, 0x66, 0x3e, 0x00, 0x00, 0x00, 0x00, 0x60, 
+   0x60, 0x60, 0x7c, 0x66, 0x66, 0x7c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+   0x3c, 0x66, 0x60, 0x66, 0x3c, 0x00, 0x00, 0x00, 0x00, 0x06, 0x06, 0x06, 
+   0x3e, 0x66, 0x66, 0x3e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3c, 0x66, 
+   0x7e, 0x60, 0x3c, 0x00, 0x00, 0x00, 0x00, 0x1c, 0x36, 0x30, 0x30, 0x78, 
+   0x30, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3e, 0x66, 0x66, 0x66, 
+   0x3e, 0x06, 0x3c, 0x00, 0x00, 0x60, 0x60, 0x60, 0x7c, 0x66, 0x66, 0x66, 
+   0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x00, 0x18, 0x18, 0x18, 0x1c, 0x00, 
+   0x00, 0x00, 0x00, 0x0c, 0x0c, 0x00, 0x0c, 0x0c, 0x0c, 0x0c, 0x6c, 0x38, 
+   0x00, 0x00, 0x60, 0x60, 0x66, 0x6c, 0x78, 0x7c, 0x66, 0x00, 0x00, 0x00, 
+   0x00, 0x60, 0x30, 0x30, 0x30, 0x30, 0x36, 0x1c, 0x00, 0x00, 0x00, 0x00, 
+   0x00, 0x00, 0x76, 0x7f, 0x6b, 0x6b, 0x6b, 0x00, 0x00, 0x00, 0x00, 0x00, 
+   0x00, 0x6c, 0x76, 0x66, 0x66, 0x66, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+   0x3c, 0x66, 0x66, 0x66, 0x3c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7c, 
+   0x66, 0x66, 0x66, 0x7c, 0x60, 0x60, 0x00, 0x00, 0x00, 0x00, 0x3e, 0x66, 
+   0x66, 0x66, 0x3e, 0x06, 0x06, 0x00, 0x00, 0x00, 0x00, 0x6e, 0x72, 0x60, 
+   0x60, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3c, 0x60, 0x3c, 0x06, 
+   0x3c, 0x00, 0x00, 0x00, 0x00, 0x30, 0x30, 0x78, 0x30, 0x30, 0x36, 0x1c, 
+   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x66, 0x66, 0x66, 0x66, 0x3a, 0x00, 
+   0x00, 0x00, 0x00, 0x00, 0x00, 0x66, 0x66, 0x66, 0x3c, 0x18, 0x00, 0x00, 
+   0x00, 0x00, 0x00, 0x00, 0x63, 0x6b, 0x6b, 0x6b, 0x36, 0x00, 0x00, 0x00, 
+   0x00, 0x00, 0x00, 0x66, 0x3c, 0x18, 0x3c, 0x66, 0x00, 0x00, 0x00, 0x00, 
+   0x00, 0x00, 0x66, 0x66, 0x66, 0x66, 0x3e, 0x06, 0x3c, 0x00, 0x00, 0x00, 
+   0x00, 0x7e, 0x0c, 0x18, 0x30, 0x7e, 0x00, 0x00, 0x00, 0x00, 0x0c, 0x18, 
+   0x18, 0x30, 0x18, 0x18, 0x0c, 0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x18, 
+   0x18, 0x18, 0x18, 0x18, 0x18, 0x00, 0x00, 0x00, 0x30, 0x18, 0x18, 0x0c, 
+   0x18, 0x18, 0x30, 0x00, 0x00, 0x00, 0x00, 0x36, 0x6c, 0x00, 0x00, 0x00, 
+   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7e, 0x42, 0x00, 0x00, 0x00, 0x00, 
+   0x00, 0x00, 0x00, 0x00};
diff -ruN proll_18.orig/src/le.c proll-patch7/src/le.c
--- proll_18.orig/src/le.c	2002-07-23 05:52:49.000000000 +0000
+++ proll-patch7/src/le.c	2004-11-13 15:50:49.000000000 +0000
@@ -185,8 +185,6 @@
 	unsigned short rap;			/* register address port */
 };
 
-int sparc_lance_debug = 2;
-
 /* The Lance uses 24 bit addresses */
 /* On the Sun4c the DVMA will provide the remaining bytes for us */
 /* On the Sun4m we have to instruct the ledma to provide them    */
diff -ruN proll_18.orig/src/netinit.c proll-patch7/src/netinit.c
--- proll_18.orig/src/netinit.c	2002-09-13 21:53:33.000000000 +0000
+++ proll-patch7/src/netinit.c	2004-11-13 15:50:49.000000000 +0000
@@ -49,13 +49,20 @@
 unsigned char     myhwaddr[ETH_ALEN];		/* my own hardware addr	*/
          t_ipaddr myipaddr;			/* my own IP address	*/
          t_ipaddr mynetmask;			/* my own netmask	*/
-         char    *net_module_name;		/* name of init module	*/
          t_ipaddr servaddr;			/* IP of RARP&TFTP server */
 
 /* Broadcast hardware address */
-unsigned char bcasthw[ETH_ALEN] = { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff };
+const unsigned char bcasthw[ETH_ALEN] = { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff };
 
 
+unsigned int seed;
+
+/* This is taken from x86 to be used in network kernel. Returns 15 bits. */
+short int random()
+{
+	seed = (seed + 23968)*0x015A4E35 >> 1;
+	return seed & 0x7FFF;
+}
 
 /*
  **************************************************************************
@@ -104,10 +111,17 @@
  */
 void init_net()
 {
+  /* Avoid data segment allocations */
+  seed = 151;
+
   /* Initialize the different network layer modules */
   init_packet();
-  if (!init_arp() || !init_udp()) {
-	printf("\nERROR: init_%s\n", net_module_name);
+  if (!init_arp()) {
+	printf("\nERROR: init_arp\n");
+	fatal();
+  }
+  if (!init_udp()) {
+	printf("\nERROR: init_udp\n");
 	fatal();
   }
 }
diff -ruN proll_18.orig/src/netpriv.h proll-patch7/src/netpriv.h
--- proll_18.orig/src/netpriv.h	1999-04-27 05:39:37.000000000 +0000
+++ proll-patch7/src/netpriv.h	2004-11-13 15:50:49.000000000 +0000
@@ -130,10 +130,9 @@
  *
  */
 extern unsigned char myhwaddr[ETH_ALEN]; /* my own hardware address	*/
-extern unsigned char bcasthw[ETH_ALEN];  /* broadcast hardware addr	*/
+extern const unsigned char bcasthw[ETH_ALEN];  /* broadcast hardware addr	*/
 extern t_ipaddr      myipaddr;           /* my own IP address		*/
 extern t_ipaddr      mynetmask;		 /* netmask for my network	*/
-extern char         *net_module_name;	 /* initialized module's name	*/
 extern t_ipaddr      servaddr;           /* server IP address		*/
 
 
@@ -150,7 +149,7 @@
 extern unsigned char *reg_type __P((int typeval, int (* receive)()));
 
 /* Write a packet to the network */
-extern int write_packet __P((int bufsize, int typeval, unsigned char *addr));
+extern int write_packet __P((int bufsize, int typeval, const unsigned char *addr));
 
 /* Empty read buffer */
 extern void empty_buf __P((void));
diff -ruN proll_18.orig/src/openprom.h proll-patch7/src/openprom.h
--- proll_18.orig/src/openprom.h	2002-07-14 02:26:30.000000000 +0000
+++ proll-patch7/src/openprom.h	2004-11-13 15:50:49.000000000 +0000
@@ -54,20 +54,20 @@
 };
 
 struct linux_mem_v0 {
-	struct linux_mlist_v0 **v0_totphys;
-	struct linux_mlist_v0 **v0_prommap;
-	struct linux_mlist_v0 **v0_available; /* What we can use */
+	struct linux_mlist_v0 * const *v0_totphys;
+	struct linux_mlist_v0 * const *v0_prommap;
+	struct linux_mlist_v0 * const *v0_available; /* What we can use */
 };
 
 /* Arguments sent to the kernel from the boot prompt. */
 struct linux_arguments_v0 {
-	char *argv[8];
+	const char *argv[8];
 	char args[100];
 	char boot_dev[2];
 	int boot_dev_ctrl;
 	int boot_dev_unit;
 	int dev_partition;
-	char *kernel_file_name;
+	const char *kernel_file_name;
 	void *aieee1;           /* XXX */
 };
 
@@ -91,13 +91,13 @@
 	struct linux_mem_v0 pv_v0mem;
 
 	/* Node operations. */
-	struct linux_nodeops *pv_nodeops;
+	const struct linux_nodeops *pv_nodeops;
 
 	char **pv_bootstr;
 	struct linux_dev_v0_funcs pv_v0devops;
 
-	char *pv_stdin;
-	char *pv_stdout;
+	const char *pv_stdin;
+	const char *pv_stdout;
 #define	PROMDEV_KBD	0		/* input from keyboard */
 #define	PROMDEV_SCREEN	0		/* output to screen */
 #define	PROMDEV_TTYA	1		/* in/out to ttya */
@@ -127,7 +127,7 @@
 		void (*v2_eval)(char *str);
 	} pv_fortheval;
 
-	struct linux_arguments_v0 **pv_v0bootargs;
+	const struct linux_arguments_v0 * const *pv_v0bootargs;
 
 	/* Get ether address. */
 	unsigned int (*pv_enaddr)(int d, char *enaddr);
@@ -175,7 +175,7 @@
 	int (*no_proplen)(int node, char *name);
 	int (*no_getprop)(int node, char *name, char *val);
 	int (*no_setprop)(int node, char *name, char *val, int len);
-	char * (*no_nextprop)(int node, char *name);
+	const char * (*no_nextprop)(int node, char *name);
 };
 
 /* More fun PROM structures for device probing. */
diff -ruN proll_18.orig/src/packet.c proll-patch7/src/packet.c
--- proll_18.orig/src/packet.c	2000-02-11 04:56:45.000000000 +0000
+++ proll-patch7/src/packet.c	2004-11-13 15:50:49.000000000 +0000
@@ -41,7 +41,7 @@
 	int aligner;
 } wbuf;
 static struct sk_buff *rskb;
-static int nqskb = 0;
+static int nqskb;
 
 
 void init_packet()
@@ -62,6 +62,8 @@
 	for (i = 0; i < MAXSKBS; i++) {
 		skev[i].skb.allocn = i;
 	}
+
+	nqskb = 0;
 }
 
 unsigned char *reg_type(int ptype, int (*func)())
@@ -81,7 +83,7 @@
 	return wbuf.s;
 }
 
-int write_packet(int leng, int type, unsigned char *dst)
+int write_packet(int leng, int type, const unsigned char *dst)
 {
 	struct sk_buff *skb;
 	unsigned char *s;
diff -ruN proll_18.orig/src/printf.c proll-patch7/src/printf.c
--- proll_18.orig/src/printf.c	1999-03-19 07:03:59.000000000 +0000
+++ proll-patch7/src/printf.c	2004-11-13 15:50:49.000000000 +0000
@@ -19,7 +19,7 @@
 static void printn(struct prf_fp *, unsigned long, unsigned int);
 static void putchar(char, struct prf_fp *);
 
-static char hextab[] = "0123456789ABCDEF";
+static const char hextab[] = "0123456789ABCDEF";
 
 /*
  * Scaled down version of C Library printf.
@@ -41,7 +41,7 @@
 void
 prf(struct prf_fp *filog, char *fmt, va_list adx)
 {
-        register c;
+        register int c;
         char *s;
 
 	for(;;) {
@@ -60,7 +60,7 @@
                 	putchar(va_arg(adx,unsigned), filog);
         	} else if(c == 's') {
                 	s = va_arg(adx,char*);
-               		while(c = *s++)
+               		while((c = *s++))
                         	putchar(c,filog);
        		} else if (c == 'l' || c == 'O') {
         	        printn(filog, (long)va_arg(adx,long), c=='l'?10:8);
diff -ruN proll_18.orig/src/rconsole.c proll-patch7/src/rconsole.c
--- proll_18.orig/src/rconsole.c	1999-01-16 07:16:55.000000000 +0000
+++ proll-patch7/src/rconsole.c	2004-11-13 15:50:49.000000000 +0000
@@ -28,12 +28,18 @@
  * move to California. Only plain lat7 survived. 
  * I recreated lat7-1 changes in lat7-2.  --zaitcev
  */
+#ifdef ORIG
 #include "lat7_2.bm"	/* lat7_1.bm */
+#else
+#include "lat7_2_swapped.bm"	/* lat7_1.bm */
+#endif
 #define LAT7_NCHARS  128
 #define LAT7_HEIGHT   11
 #define LAT7_WIDTH     8
 
+#ifdef ORIG
 static Rf_scan lat7_body[ LAT7_NCHARS*LAT7_HEIGHT ];
+#endif
 
 #if 1
 /*
@@ -94,6 +100,7 @@
 
 #endif
 
+#ifdef ORIG
 static inline int swapbits(int w0)
 {
   int w1 = 0;
@@ -105,13 +112,16 @@
   }
   return w1;
 }
+#endif
 
 void font_cons_7(struct rfont *p)
 {
+#ifdef ORIG
   int x;
   int col = 0;
   int row = 0;
   int erow = 0;
+
   for (x = 0; x < LAT7_NCHARS*LAT7_HEIGHT; x++ ) {
     lat7_body[ (erow * lat7_2_width/8 + col) * LAT7_HEIGHT + row ] =
                                             swapbits(lat7_2_bits[x]) & 0xFF;
@@ -124,6 +134,9 @@
     }
   }
   p->body_ = lat7_body;
+#else
+  p->body_ = lat7_2_bits;
+#endif
   p->nchars_ = LAT7_NCHARS;
   p->width_ = LAT7_WIDTH;
   p->height_ = LAT7_HEIGHT;
diff -ruN proll_18.orig/src/rconsole.h proll-patch7/src/rconsole.h
--- proll_18.orig/src/rconsole.h	1999-01-16 05:00:59.000000000 +0000
+++ proll-patch7/src/rconsole.h	2004-11-13 15:50:49.000000000 +0000
@@ -13,10 +13,10 @@
  */
 
 #define RF_MAXWIDTH  16
-typedef unsigned short Rf_scan;        /*  __w16 to be used */
+typedef unsigned char Rf_scan;        /*  __w16 to be used */
 
 struct rfont {
-  Rf_scan *body_;
+  const Rf_scan *body_;
   int nchars_;                 /* 128 for ASCII ...  65536 for Unicode   */
   int width_;                  /* [Pixels]. Maximum size is 16.          */
   int height_;                 /* [Pixels == scan lines].                */
diff -ruN proll_18.orig/src/romlib.h proll-patch7/src/romlib.h
--- proll_18.orig/src/romlib.h	1999-04-20 04:26:45.000000000 +0000
+++ proll-patch7/src/romlib.h	2004-11-13 15:50:49.000000000 +0000
@@ -73,12 +73,12 @@
 #define memcpy(dst, src, len)	bcopy(src, dst, len)
 #define memcmp(x1, x2, len)	bcmp(x1, x2, len)
 #define memset(p, len, zero)	bzero(p, len)
-extern void bcopy(void *b1, void *b2, int length);
-extern int  bcmp(void *b1, void *b2, int length);
+extern void bcopy(const void *b1, void *b2, int length);
+extern int  bcmp(const void *b1, const void *b2, int length);
 extern void bzero(void *b, int c);
 /* gcc complains about "conflicting types for builtin function strlen". */
 #define strlen(s)		ssize(s)
-extern int ssize(char *s);
+extern int ssize(const char *s);
 
 
 /*
diff -ruN proll_18.orig/src/sched_4m.c proll-patch7/src/sched_4m.c
--- proll_18.orig/src/sched_4m.c	1999-04-27 05:48:51.000000000 +0000
+++ proll-patch7/src/sched_4m.c	2004-11-13 15:50:49.000000000 +0000
@@ -108,7 +108,7 @@
 static int set_bolt;			/* Tick counter limit */
 static struct handsc hndv[16];
 
-static unsigned int intr_to_mask[16] = {
+static unsigned const int intr_to_mask[16] = {
 	0,	0,	0,	0,	0,	0, SUN4M_INT_ETHERNET,	0,
 	0,	0,	0,	0,	0,	0,	0,	0,
 };
diff -ruN proll_18.orig/src/swap.c proll-patch7/src/swap.c
--- proll_18.orig/src/swap.c	1970-01-01 00:00:00.000000000 +0000
+++ proll-patch7/src/swap.c	2004-11-13 15:50:49.000000000 +0000
@@ -0,0 +1,21 @@
+// Convert the lat7 font so that no conversion is needed at runtime.
+#define ORIG
+#include "rconsole.c"
+
+#include <stdio.h>
+
+int main()
+{
+    struct rfont p;
+    int i;
+
+    font_cons_7(&p);
+
+    printf("   ");
+    for (i = 0; i < LAT7_NCHARS*LAT7_HEIGHT; i++) {
+	printf("0x%02x, ", p.body_[i]);
+	if ((i % 12) == 11)
+	    printf("\n   ");
+    }
+    printf("\n");
+}
diff -ruN proll_18.orig/src/system.c proll-patch7/src/system.c
--- proll_18.orig/src/system.c	2002-07-23 05:52:49.000000000 +0000
+++ proll-patch7/src/system.c	2004-11-13 15:50:49.000000000 +0000
@@ -298,8 +298,8 @@
 	}
 
 	/* We need to start from LOADBASE, but kernel wants PAGE_SIZE. */
-	pa = PAGE_SIZE;
-	for (va = PAGE_SIZE; va < LOWMEMSZ; va += PAGE_SIZE) {
+	pa = 0;
+	for (va = 0; va < LOWMEMSZ; va += PAGE_SIZE) {
 		map_page(l1, va, pa, 0, highbase);
 		pa += PAGE_SIZE;
 	}
@@ -518,12 +518,12 @@
 	while (len--) *((char *)s)++ = 0;
 }
 
-void bcopy(void *f, void *t, int len) {
+void bcopy(const void *f, void *t, int len) {
 	while (len--) *((char *)t)++ = *((char *)f)++;
 }
 
 /* Comparison is 7-bit */
-int bcmp(void *s1, void *s2, int len)
+int bcmp(const void *s1, const void *s2, int len)
 {
 	int i;
 	char ch;
@@ -538,8 +538,8 @@
 	return 0;
 }
 
-int strlen(char *s) {
-	char *p;
+int strlen(const char *s) {
+	const char *p;
 	for (p = s; *p != 0; p++) { }
 	return p - s;
 }
@@ -560,14 +560,6 @@
 	va_end(x1);
 }
 
-/* This is taken from x86 to be used in network kernel. Returns 15 bits. */
-short int random()
-{
-	static unsigned int seed = 151;
-	seed = (seed + 23968)*0x015A4E35 >> 1;
-	return seed & 0x7FFF;
-}
-
 void fatal()
 {
 	printk("fatal.");
diff -ruN proll_18.orig/src/system.h proll-patch7/src/system.h
--- proll_18.orig/src/system.h	2002-09-13 21:53:32.000000000 +0000
+++ proll-patch7/src/system.h	2004-11-13 15:50:49.000000000 +0000
@@ -16,7 +16,7 @@
 #define IOMAPSIZE (1*1024*1024) /* 1 Meg maximum: we do not map framebuffer. */
 #define NCTX_SWIFT  0x100
 
-#define MAX_BANKS      3		/* Allocation for all machines */
+#define MAX_BANKS      8		/* Allocation for all machines */
 
 #ifndef __ASSEMBLY__
 struct bank {
diff -ruN proll_18.orig/src/udp.c proll-patch7/src/udp.c
--- proll_18.orig/src/udp.c	2001-12-24 05:12:53.000000000 +0000
+++ proll-patch7/src/udp.c	2004-11-13 15:50:49.000000000 +0000
@@ -81,7 +81,7 @@
 int      source;
 int      dest;
 {
-  register unsigned char *addr;
+  const register unsigned char *addr;
 
   /* Set global variables */
   usource = source;
@@ -299,9 +299,6 @@
  */
 int init_udp()
 {
-  /* Set module name for error handling */
-  net_module_name = "udp";
-
   /* Register IP packet type and set write buffer pointer */
   if ((writebuf = reg_type(htons(ETH_P_IP), ip_recv)) == NULL)
 	return(FALSE);
diff -ruN proll_18.orig/src/vcons_zs.c proll-patch7/src/vcons_zs.c
--- proll_18.orig/src/vcons_zs.c	1970-01-01 00:00:00.000000000 +0000
+++ proll-patch7/src/vcons_zs.c	2005-03-02 12:07:41.000000000 +0000
@@ -0,0 +1,68 @@
+/**
+ ** Console over 'zs' (Zilog serial port)
+ ** Copyright 1999 Pete Zaitcev
+ ** This code is licensed under GNU General Public License.
+ **/
+
+#include "vconsole.h"
+#include <system.h>
+
+#define ZS_DATA 0x02
+
+int vcon_zs_init(struct vconterm *t, unsigned int a0)
+{
+
+	t->impl = (void *) a0;
+
+	t->vc_x = 0;    t->vc_y = 0;
+	t->backp = 0;    t->backc = 0;
+
+	stb_bypass(a0, 3); // reg 3
+	stb_bypass(a0, 1); // enable rx
+
+	stb_bypass(a0, 5); // reg 5
+	stb_bypass(a0, 8); // enable tx
+
+	return 0;
+}
+
+int vcon_zs_putch(struct vconterm *t, char c)
+{
+	unsigned zs_ptr = (unsigned) t->impl;
+
+	//while ((ldb_bypass(zs_ptr + ZS_LSR) & 0x60) != 0x60) { }
+	stb_bypass(zs_ptr + ZS_DATA, c);
+	return 0;
+}
+
+int vcon_zs_write(struct vconterm *t, char *data, int leng)
+{
+	while (leng != 0) {
+		leng--;
+		vcon_zs_putch(t, *data++);
+	}
+	return leng;
+}
+
+int vcon_zs_read(struct vconterm *t, char *data, int leng)
+{
+	unsigned zs_ptr = (unsigned) t->impl;
+
+	while ((ldb_bypass(zs_ptr) & 1) != 1) { }
+	*data = ldb_bypass(zs_ptr + ZS_DATA);
+	return 0;
+}
+
+int vcon_zs_getch(struct vconterm *t)
+{
+	unsigned zs_ptr = (unsigned) t->impl;
+
+	while ((ldb_bypass(zs_ptr) & 1) != 1) { }
+	return ldb_bypass(zs_ptr + ZS_DATA);
+}
+
+void vcon_zs_fini(struct vconterm *t)
+{
+	/* violent crash in the end */
+	;
+}
diff -ruN proll_18.orig/src/vconsole.c proll-patch7/src/vconsole.c
--- proll_18.orig/src/vconsole.c	1999-11-08 03:10:28.000000000 +0000
+++ proll-patch7/src/vconsole.c	2005-03-02 14:29:05.000000000 +0000
@@ -13,6 +13,10 @@
 
 struct hconsole hcons0;
 
+enum { ESnormal, ESesc, ESsquare, ESgetpars, ESgotpars, ESfunckey,
+	EShash, ESsetG0, ESsetG1, ESpercent, ESignore, ESnonstd,
+	ESpalette };
+
 int vcon_init(struct vconterm *t, unsigned int a0)
 {
 	struct hconsole *hconp;
@@ -25,11 +29,49 @@
 
 	t->vc_x = 0;    t->vc_y = 0;
 	t->backp = 0;    t->backc = 0;
+	t->vc_state = ESnormal;
 
 	hcon_clear(hconp, 0, 0, hconp->ydim_, hconp->xdim_);
 	return 0;
 }
 
+/*
+ * gotoxy() must verify all boundaries, because the arguments
+ * might also be negative. If the given position is out of
+ * bounds, the cursor is placed at the nearest margin.
+ */
+static void gotoxy(struct vconterm *vc, int new_x, int new_y)
+{
+	int max_x, max_y;
+	struct hconsole *hconp = vc->impl;
+
+	max_x = hcon_qxdim(hconp);
+	max_y = hcon_qydim(hconp);
+
+	if (new_x < 0)
+		vc->vc_x = 0;
+	else {
+		if (new_x >= max_x)
+			vc->vc_x = max_x - 1;
+		else
+			vc->vc_x = new_x;
+	}
+
+	if (new_y < 0)
+		vc->vc_y = 0;
+	else if (new_y >= max_y)
+		vc->vc_y = max_y - 1;
+	else
+		vc->vc_y = new_y;
+
+}
+
+/* for absolute user moves, when decom is set */
+static void gotoxay(struct vconterm *t, int new_x, int new_y)
+{
+	gotoxy(t, new_x, new_y);
+}
+
 int vcon_write(struct vconterm *t, char *data, int leng)
 {
 	int l = leng;
@@ -40,29 +82,84 @@
 		if (l <= 0) break;
 		c = *data++;    --l;
 
-		switch (c) {
-		case 0x07:		/* Bell */
-			vcon_i_backflush(t);
-			break;
-		case 0x0A:		/* Linefeed */
-			vcon_i_backflush(t);
-			vcon_i_cursfeed(t);
+		switch(t->vc_state) {
+		case ESesc:
+			t->vc_state = ESnormal;
+			switch (c) {
+			case '[':
+				t->vc_state = ESsquare;
+				break;
+			case 'M':
+				hcon_scroll(hconp, 0, hcon_qydim(hconp), SM_UP, 1);
+				break;
+			}
 			break;
-		case 0x0D:		/* Return */
-			vcon_i_backflush(t);
-			t->vc_x = 0;
+		case ESsquare:
+			for(t->vc_npar = 0 ; t->vc_npar < NPAR ; t->vc_npar++)
+				t->vc_par[t->vc_npar] = 0;
+			t->vc_npar = 0;
+			t->vc_state = ESgetpars;
+		case ESgetpars:
+			if (c==';' && t->vc_npar<NPAR-1) {
+				t->vc_npar++;
+				break;
+			} else if (c>='0' && c<='9') {
+				t->vc_par[t->vc_npar] *= 10;
+				t->vc_par[t->vc_npar] += c-'0';
+				break;
+			} else t->vc_state=ESgotpars;
+		case ESgotpars:
+			t->vc_state = ESnormal;
+			switch(c) {
+			case 'H': case 'f':
+				if (t->vc_par[0]) t->vc_par[0]--;
+				if (t->vc_par[1]) t->vc_par[1]--;
+				gotoxay(t, t->vc_par[1], t->vc_par[0]);
+				break;
+			case 'M':
+				hcon_scroll(hconp, 0, hcon_qydim(hconp), SM_UP, 1);
+				break;
+			}
 			break;
 		default:
-			if (t->backp == 0) {
-				t->backc = 1;
-				t->backp = data-1;
-			} else {
-				t->backc++;
-			}
-			if (t->vc_x + t->backc >= hcon_qxdim(hconp)) {
+			t->vc_state = ESnormal;
+			switch (c) {
+			case 0x07:		/* Bell */
+				vcon_i_backflush(t);
+				break;
+			case 0x08:		/* BS */
+				vcon_i_backflush(t);
+				if (t->vc_x > 0)
+					t->vc_x--;
+				break;
+			case 0x0A:		/* Linefeed */
 				vcon_i_backflush(t);
-				t->vc_x = 0;
 				vcon_i_cursfeed(t);
+				break;
+			case 0x0D:		/* Return */
+				vcon_i_backflush(t);
+				t->vc_x = 0;
+				break;
+			case 24: case 26:
+				vcon_i_backflush(t);
+				t->vc_state = ESnormal;
+				break;
+			case 27:
+				vcon_i_backflush(t);
+				t->vc_state = ESesc;
+				break;
+			default:
+				if (t->backp == 0) {
+					t->backc = 1;
+					t->backp = data-1;
+				} else {
+					t->backc++;
+				}
+				if (t->vc_x + t->backc >= hcon_qxdim(hconp)) {
+					vcon_i_backflush(t);
+					t->vc_x = 0;
+					vcon_i_cursfeed(t);
+				}
 			}
 		}
 	}
diff -ruN proll_18.orig/src/vconsole.h proll-patch7/src/vconsole.h
--- proll_18.orig/src/vconsole.h	1999-11-08 00:58:13.000000000 +0000
+++ proll-patch7/src/vconsole.h	2005-03-02 12:40:12.000000000 +0000
@@ -6,6 +6,8 @@
 #ifndef VCONSOLE_H
 #define VCONSOLE_H
 
+#define NPAR 16
+
 struct vconterm {
 	void *impl;
 
@@ -13,6 +15,8 @@
 	int backc;		/* Same, count */
 
 	int vc_x, vc_y;		/* XXX Make vcon_xxx() to use cellmap->xpos_ */
+	int vc_state;
+	unsigned int	vc_npar,vc_par[NPAR];	/* Parameters of current escape sequence */
 };
 
 int vcon_init(struct vconterm *t, unsigned int a0);
