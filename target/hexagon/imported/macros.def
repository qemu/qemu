/*
 *  Copyright(c) 2019-2021 Qualcomm Innovation Center, Inc. All Rights Reserved.
 *
 *  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation; either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program; if not, see <http://www.gnu.org/licenses/>.
 */

DEF_MACRO(
    LIKELY,    /* NAME */
    __builtin_expect((X),1), /* BEH */
    ()    /* attribs */
)

DEF_MACRO(
    UNLIKELY,    /* NAME */
    __builtin_expect((X),0), /* BEH */
    ()    /* attribs */
)

DEF_MACRO(
    CANCEL, /* macro name */
    {if (thread->last_pkt) thread->last_pkt->slot_cancelled |= (1<<insn->slot); return;} , /* behavior */
    (A_CONDEXEC)
)

DEF_MACRO(
    LOAD_CANCEL, /* macro name */
    {mem_general_load_cancelled(thread,EA,insn);CANCEL;} , /* behavior */
    (A_CONDEXEC)
)

DEF_MACRO(
    STORE_CANCEL, /* macro name */
    {mem_general_store_cancelled(thread,EA,insn);CANCEL;} , /* behavior */
    (A_CONDEXEC)
)

DEF_MACRO(
    fMAX, /* macro name */
    (((A) > (B)) ? (A) : (B)), /* behavior */
    /* optional attributes */
)

DEF_MACRO(
    fMIN, /* macro name */
    (((A) < (B)) ? (A) : (B)), /* behavior */
    /* optional attributes */
)

DEF_MACRO(
    fABS, /* macro name */
    (((A)<0)?(-(A)):(A)), /* behavior */
    /* optional attributes */
)


/* Bit insert */
DEF_MACRO(
    fINSERT_BITS,
        {
            REG = ((REG) & ~(((fCONSTLL(1)<<(WIDTH))-1)<<(OFFSET))) | (((INVAL) & ((fCONSTLL(1)<<(WIDTH))-1)) << (OFFSET));
        },
    /* attribs */
)

/* Bit extract */
DEF_MACRO(
    fEXTRACTU_BITS,
    (fZXTN(WIDTH,32,(INREG >> OFFSET))),
    /* attribs */
)

DEF_MACRO(
    fEXTRACTU_BIDIR,
    (fZXTN(WIDTH,32,fBIDIR_LSHIFTR((INREG),(OFFSET),4_8))),
    /* attribs */
)

DEF_MACRO(
    fEXTRACTU_RANGE,
    (fZXTN((HIBIT-LOWBIT+1),32,(INREG >> LOWBIT))),
    /* attribs */
)


DEF_MACRO(
    fINSERT_RANGE,
        {
            int offset=LOWBIT;
            int width=HIBIT-LOWBIT+1;
            /* clear bits where new bits go */
            INREG &= ~(((fCONSTLL(1)<<width)-1)<<offset);
            /* OR in new bits */
            INREG |= ((INVAL & ((fCONSTLL(1)<<width)-1)) << offset);
        },
    /* attribs */
)


DEF_MACRO(
    f8BITSOF,
    ( (VAL) ? 0xff : 0x00),
    /* attribs */
)

DEF_MACRO(
    fLSBOLD,
    ((VAL) & 1),
    ()
)

DEF_MACRO(
    fLSBNEW,
    predlog_read(thread,PNUM),
    ()
)

DEF_MACRO(
    fLSBNEW0,
    predlog_read(thread,0),
    ()
)

DEF_MACRO(
    fLSBNEW1,
    predlog_read(thread,1),
    ()
)

DEF_MACRO(
    fLSBOLDNOT,
    (!fLSBOLD(VAL)),
    ()
)

DEF_MACRO(
    fLSBNEWNOT,
    (!fLSBNEW(PNUM)),
    ()
)

DEF_MACRO(
    fLSBNEW0NOT,
    (!fLSBNEW0),
    ()
)

DEF_MACRO(
    fLSBNEW1NOT,
    (!fLSBNEW1),
    ()
)

DEF_MACRO(
    fNEWREG,
    ({if (newvalue_missing(thread,RNUM) ||
      IS_CANCELLED(insn->new_value_producer_slot)) CANCEL; reglog_read(thread,RNUM);}),
    (A_DOTNEWVALUE,A_RESTRICT_SLOT0ONLY)
)
// Store new with a missing newvalue or cancelled goes out as a zero byte store in V65
// take advantage of the fact that reglog_read returns zero for not valid rnum
DEF_MACRO(
    fNEWREG_ST,
    ({if (newvalue_missing(thread,RNUM) ||
      IS_CANCELLED(insn->new_value_producer_slot)) { STORE_ZERO; RNUM = -1; }; reglog_read(thread,RNUM);}),
    (A_DOTNEWVALUE,A_RESTRICT_SLOT0ONLY)
)

DEF_MACRO(
    fVSATUVALN,
    ({ ((VAL) < 0) ? 0 : ((1LL<<(N))-1);}),
    ()
)

DEF_MACRO(
    fSATUVALN,
    ({fSET_OVERFLOW(); ((VAL) < 0) ? 0 : ((1LL<<(N))-1);}),
    ()
)

DEF_MACRO(
    fSATVALN,
    ({fSET_OVERFLOW(); ((VAL) < 0) ? (-(1LL<<((N)-1))) : ((1LL<<((N)-1))-1);}),
    ()
)

DEF_MACRO(
    fVSATVALN,
    ({((VAL) < 0) ? (-(1LL<<((N)-1))) : ((1LL<<((N)-1))-1);}),
    ()
)

DEF_MACRO(
    fZXTN, /* macro name */
    ((VAL) & ((1LL<<(N))-1)),
    /* attribs */
)

DEF_MACRO(
    fSXTN, /* macro name */
    ((fZXTN(N,M,VAL) ^ (1LL<<((N)-1))) - (1LL<<((N)-1))),
    /* attribs */
)

DEF_MACRO(
    fSATN,
    ((fSXTN(N,64,VAL) == (VAL)) ? (VAL) : fSATVALN(N,VAL)),
    ()
)
DEF_MACRO(
    fVSATN,
    ((fSXTN(N,64,VAL) == (VAL)) ? (VAL) : fVSATVALN(N,VAL)),
    ()
)

DEF_MACRO(
    fADDSAT64,
    {
        size8u_t __a = fCAST8u(A);
        size8u_t __b = fCAST8u(B);
        size8u_t __sum = __a + __b;
        size8u_t __xor = __a ^ __b;
        const size8u_t __mask = 0x8000000000000000ULL;
        if (__xor & __mask) {
            /* Opposite signs, OK */
            DST = __sum;
        } else if ((__a ^ __sum) & __mask) {
            /* Signs mismatch */
            if (__sum & __mask) {
                /* overflowed to negative, make max pos */
                DST=0x7FFFFFFFFFFFFFFFLL; fSET_OVERFLOW();
            } else {
                /* overflowed to positive, make max neg */
                DST=0x8000000000000000LL; fSET_OVERFLOW();
            }
        } else {
            /* signs did not mismatch, OK */
            DST = __sum;
        }
    },
    ()
)

DEF_MACRO(
    fVSATUN,
    ((fZXTN(N,64,VAL) == (VAL)) ? (VAL) : fVSATUVALN(N,VAL)),
    ()
)

DEF_MACRO(
    fSATUN,
    ((fZXTN(N,64,VAL) == (VAL)) ? (VAL) : fSATUVALN(N,VAL)),
    ()
)

DEF_MACRO(
    fSATH,
    (fSATN(16,VAL)),
    ()
)


DEF_MACRO(
    fSATUH,
    (fSATUN(16,VAL)),
    ()
)

DEF_MACRO(
    fVSATH,
    (fVSATN(16,VAL)),
    ()
)

DEF_MACRO(
    fVSATUH,
    (fVSATUN(16,VAL)),
    ()
)


DEF_MACRO(
    fSATUB,
    (fSATUN(8,VAL)),
    ()
)
DEF_MACRO(
    fSATB,
    (fSATN(8,VAL)),
    ()
)


DEF_MACRO(
    fVSATUB,
    (fVSATUN(8,VAL)),
    ()
)
DEF_MACRO(
    fVSATB,
    (fVSATN(8,VAL)),
    ()
)




/*************************************/
/* immediate extension               */
/*************************************/

DEF_MACRO(
    fIMMEXT,
    (IMM = IMM),
    (A_EXTENDABLE)
)

DEF_MACRO(
    fMUST_IMMEXT,
    fIMMEXT(IMM),
    (A_EXTENDABLE)
)

DEF_MACRO(
    fPCALIGN,
    IMM=(IMM & ~PCALIGN_MASK),
    (A_EXTENDABLE)
)

/*************************************/
/* Read and Write Implicit Regs      */
/*************************************/

DEF_MACRO(
    fREAD_IREG, /* read modifier register */
    (fSXTN(11,64,(((VAL) & 0xf0000000)>>21) | ((VAL>>17)&0x7f) )),          /* behavior */
    ()
)

DEF_MACRO(
    fREAD_LR, /* read link register */
    (READ_RREG(REG_LR)),          /* behavior */
    ()
)

DEF_MACRO(
    fREAD_SSR, /* read SSR register */
    (READ_RREG(REG_SSR)),          /* behavior */
    ()
)

DEF_MACRO(
    fWRITE_LR, /* write lr */
    WRITE_RREG(REG_LR,A),          /* behavior */
    (A_IMPLICIT_WRITES_LR)
)

DEF_MACRO(
    fWRITE_FP, /* write sp */
    WRITE_RREG(REG_FP,A),          /* behavior */
    (A_IMPLICIT_WRITES_FP)
)

DEF_MACRO(
    fWRITE_SP, /* write sp */
    WRITE_RREG(REG_SP,A),          /* behavior */
    (A_IMPLICIT_WRITES_SP)
)

DEF_MACRO(
    fWRITE_GOSP, /* write gosp */
    WRITE_RREG(REG_GOSP,A),          /* behavior */
    (A_IMPLICIT_WRITES_GOSP)
)

DEF_MACRO(
    fREAD_SP, /* read stack pointer */
    (READ_RREG(REG_SP)),          /* behavior */
    ()
)

DEF_MACRO(
    fREAD_GOSP, /* read guest other stack pointer */
    (READ_RREG(REG_GOSP)),          /* behavior */
    ()
)

DEF_MACRO(
    fREAD_GELR, /* read guest other stack pointer */
    (READ_RREG(REG_GELR)),          /* behavior */
    ()
)

DEF_MACRO(
    fREAD_GEVB, /* read guest other stack pointer */
    (READ_RREG(REG_GEVB)),          /* behavior */
    ()
)

DEF_MACRO(
    fREAD_CSREG, /* read  CS register */
    (READ_RREG(REG_CSA+N)),          /* behavior */
    ()
)

DEF_MACRO(
    fREAD_LC0, /* read loop count */
    (READ_RREG(REG_LC0)),          /* behavior */
    ()
)

DEF_MACRO(
    fREAD_LC1, /* read loop count */
    (READ_RREG(REG_LC1)),          /* behavior */
    ()
)

DEF_MACRO(
    fREAD_SA0, /* read start addr */
    (READ_RREG(REG_SA0)),          /* behavior */
    ()
)

DEF_MACRO(
    fREAD_SA1, /* read start addr */
    (READ_RREG(REG_SA1)),          /* behavior */
    ()
)


DEF_MACRO(
    fREAD_FP, /* read frame pointer */
    (READ_RREG(REG_FP)),          /* behavior */
    ()
)

DEF_MACRO(
    fREAD_GP, /* read global pointer */
    (insn->extension_valid ? 0 : READ_RREG(REG_GP)),          /* behavior */
    ()
)

DEF_MACRO(
    fREAD_PC, /* read PC */
    (READ_RREG(REG_PC)),          /* behavior */
    ()
)

DEF_MACRO(
    fREAD_NPC, /* read next PC */
    (thread->next_PC & (0xfffffffe)),          /* behavior */
    ()
)

DEF_MACRO(
    fREAD_P0, /* read Predicate 0 */
    (READ_PREG(0)),          /* behavior */
    ()
)

DEF_MACRO(
    fREAD_P3, /* read Predicate 3 */
    (READ_PREG(3)),          /* behavior */
    ()
)

DEF_MACRO(
    fCHECK_PCALIGN,
    if (((A) & PCALIGN_MASK)) {
        register_error_exception(thread,PRECISE_CAUSE_PC_NOT_ALIGNED,thread->Regs[REG_BADVA0],thread->Regs[REG_BADVA1],GET_SSR_FIELD(SSR_BVS),GET_SSR_FIELD(SSR_V0),GET_SSR_FIELD(SSR_V1),0);
    },
    ()
)

DEF_MACRO(
    fWRITE_NPC, /* write next PC */
    if (!thread->branch_taken) {
        if (A != thread->next_PC) {
            thread->next_pkt_guess=thread->last_pkt->taken_ptr;
        }
        fCHECK_PCALIGN(A);
        thread->branched = 1; thread->branch_taken = 1; thread->next_PC = A; \
        thread->branch_offset = insn->encoding_offset; thread->branch_opcode = insn->opcode;
    },          /* behavior */
    (A_COF)
)

DEF_MACRO(
    fBRANCH,
    fWRITE_NPC(LOC); fCOF_CALLBACK(LOC,TYPE),
    ()
)

DEF_MACRO(
    fJUMPR,    /* A jumpr has executed */
    {fBRANCH(TARGET,COF_TYPE_JUMPR);},
    (A_INDIRECT)
)

DEF_MACRO(
    fHINTJR,    /* A hintjr instruction has executed */
    { },
)

DEF_MACRO(
    fCALL,    /* Do a call */
    if (!thread->branch_taken) {fBP_RAS_CALL(A); fWRITE_LR(fREAD_NPC()); fBRANCH(A,COF_TYPE_CALL);},
    (A_COF,A_IMPLICIT_WRITES_LR,A_CALL)
)

DEF_MACRO(
    fCALLR,    /* Do a call Register */
    if (!thread->branch_taken) {fBP_RAS_CALL(A); fWRITE_LR(fREAD_NPC()); fBRANCH(A,COF_TYPE_CALLR);},
    (A_COF,A_IMPLICIT_WRITES_LR,A_CALL)
)

DEF_MACRO(
    fWRITE_LOOP_REGS0, /* write ln,sa,ea,lc */
    {WRITE_RREG(REG_LC0,COUNT);
     WRITE_RREG(REG_SA0,START);},
    (A_IMPLICIT_WRITES_LC0,A_IMPLICIT_WRITES_SA0)
)

DEF_MACRO(
    fWRITE_LOOP_REGS1, /* write ln,sa,ea,lc */
    {WRITE_RREG(REG_LC1,COUNT);
     WRITE_RREG(REG_SA1,START);},
    (A_IMPLICIT_WRITES_LC1,A_IMPLICIT_WRITES_SA1)
)

DEF_MACRO(
    fWRITE_LC0,
    WRITE_RREG(REG_LC0,VAL),
    (A_IMPLICIT_WRITES_LC0)
)

DEF_MACRO(
    fWRITE_LC1,
    WRITE_RREG(REG_LC1,VAL),
    (A_IMPLICIT_WRITES_LC1)
)

DEF_MACRO(
    fCARRY_FROM_ADD,
    carry_from_add64(A,B,C),
    /* NOTHING */
)

DEF_MACRO(
    fSET_OVERFLOW,
    SET_USR_FIELD(USR_OVF,1),
    ()
)

DEF_MACRO(
    fSET_LPCFG,
    SET_USR_FIELD(USR_LPCFG,(VAL)),
    ()
)


DEF_MACRO(
    fGET_LPCFG,
    (GET_USR_FIELD(USR_LPCFG)),
    ()
)



DEF_MACRO(
    fWRITE_P0, /* write Predicate 0 */
    WRITE_PREG(0,VAL),          /* behavior */
    (A_IMPLICIT_WRITES_P0)
)

DEF_MACRO(
    fWRITE_P1, /* write Predicate 0 */
    WRITE_PREG(1,VAL),          /* behavior */
    (A_IMPLICIT_WRITES_P1)
)

DEF_MACRO(
    fWRITE_P2, /* write Predicate 0 */
    WRITE_PREG(2,VAL),          /* behavior */
    (A_IMPLICIT_WRITES_P2)
)

DEF_MACRO(
    fWRITE_P3, /* write Predicate 0 */
    WRITE_PREG(3,VAL),     /* behavior */
    (A_IMPLICIT_WRITES_P3)
)
DEF_MACRO(
	fWRITE_P3_LATE, /* write Predicate 0 */
	{WRITE_PREG(3,VAL); fHIDE(MARK_LATE_PRED_WRITE(3))} ,          /* behavior */
	(A_IMPLICIT_WRITES_P3,A_RESTRICT_LATEPRED)
)

DEF_MACRO(
    fPART1, /* write Predicate 0 */
    if (insn->part1) { WORK; return; },          /* behavior */
    /* optional attributes */
)


/*************************************/
/* Casting, Sign-Zero extension, etc */
/*************************************/

DEF_MACRO(
    fCAST4u, /* macro name */
    ((size4u_t)(A)),          /* behavior */
    /* optional attributes */
)

DEF_MACRO(
    fCAST4s, /* macro name */
    ((size4s_t)(A)),          /* behavior */
    /* optional attributes */
)

DEF_MACRO(
    fCAST8u, /* macro name */
    ((size8u_t)(A)),          /* behavior */
    /* optional attributes */
)

DEF_MACRO(
    fCAST8s, /* macro name */
    ((size8s_t)(A)),          /* behavior */
    /* optional attributes */
)

DEF_MACRO(
    fCAST2_2s, /* macro name */
    ((size2s_t)(A)),
    /* optional attributes */
)

DEF_MACRO(
    fCAST2_2u, /* macro name */
    ((size2u_t)(A)),
    /* optional attributes */
)

DEF_MACRO(
    fCAST4_4s, /* macro name */
    ((size4s_t)(A)),
    /* optional attributes */
)

DEF_MACRO(
    fCAST4_4u, /* macro name */
    ((size4u_t)(A)),
    /* optional attributes */
)


DEF_MACRO(
    fCAST4_8s, /* macro name */
    ((size8s_t)((size4s_t)(A))),
    /* optional attributes */
)

DEF_MACRO(
    fCAST4_8u, /* macro name */
    ((size8u_t)((size4u_t)(A))),
    /* optional attributes */
)

DEF_MACRO(
    fCAST8_8s, /* macro name */
    ((size8s_t)(A)),
    /* optional attributes */
)

DEF_MACRO(
    fCAST8_8u, /* macro name */
    ((size8u_t)(A)),
    /* optional attributes */
)

DEF_MACRO(
    fCAST2_8s, /* macro name */
    ((size8s_t)((size2s_t)(A))),
    /* optional attributes */
)

DEF_MACRO(
    fCAST2_8u, /* macro name */
    ((size8u_t)((size2u_t)(A))),
    /* optional attributes */
)

DEF_MACRO(
    fZE8_16, /* zero-extend 8 to 16 */
    ((size2s_t)((size1u_t)(A))),
    /* optional attributes */
)
DEF_MACRO(
    fSE8_16, /* sign-extend 8 to 16 */
    ((size2s_t)((size1s_t)(A))),
    /* optional attributes */
)


DEF_MACRO(
    fSE16_32, /* sign-extend 16 to 32 */
    ((size4s_t)((size2s_t)(A))),          /* behavior */
    /* optional attributes */
)

DEF_MACRO(
    fZE16_32, /* zero-extend 16 to 32 */
    ((size4u_t)((size2u_t)(A))),          /* behavior */
    /* optional attributes */
)

DEF_MACRO(
    fSE32_64,
    ( (size8s_t)((size4s_t)(A)) ),          /* behavior */
    /* optional attributes */
)

DEF_MACRO(
    fZE32_64,
    ( (size8u_t)((size4u_t)(A)) ),          /* behavior */
    /* optional attributes */
)

DEF_MACRO(
    fSE8_32, /* sign-extend 8 to 32 */
    ((size4s_t)((size1s_t)(A))),
    /* optional attributes */
)

DEF_MACRO(
    fZE8_32, /* zero-extend 8 to 32 */
    ((size4s_t)((size1u_t)(A))),
    /* optional attributes */
)

/*************************************/
/* DSP arithmetic support            */
/************************************/
DEF_MACRO(
    fMPY8UU, /* multiply half integer */
    (int)(fZE8_16(A)*fZE8_16(B)),     /* behavior */
    ()
)
DEF_MACRO(
    fMPY8US, /* multiply half integer */
    (int)(fZE8_16(A)*fSE8_16(B)),     /* behavior */
    ()
)
DEF_MACRO(
    fMPY8SU, /* multiply half integer */
    (int)(fSE8_16(A)*fZE8_16(B)),     /* behavior */
    ()
)

DEF_MACRO(
    fMPY8SS, /* multiply half integer */
    (int)((short)(A)*(short)(B)),     /* behavior */
    ()
)

DEF_MACRO(
    fMPY16SS, /* multiply half integer */
    fSE32_64(fSE16_32(A)*fSE16_32(B)),     /* behavior */
    ()
)

DEF_MACRO(
    fMPY16UU, /* multiply unsigned half integer */
    fZE32_64(fZE16_32(A)*fZE16_32(B)),     /* behavior */
    ()
)

DEF_MACRO(
    fMPY16SU, /* multiply half integer */
    fSE32_64(fSE16_32(A)*fZE16_32(B)),     /* behavior */
    ()
)

DEF_MACRO(
    fMPY16US, /* multiply half integer */
    fMPY16SU(B,A),
    ()
)

DEF_MACRO(
    fMPY32SS, /* multiply half integer */
    (fSE32_64(A)*fSE32_64(B)),     /* behavior */
    ()
)

DEF_MACRO(
    fMPY32UU, /* multiply half integer */
    (fZE32_64(A)*fZE32_64(B)),     /* behavior */
    ()
)

DEF_MACRO(
    fMPY32SU, /* multiply half integer */
    (fSE32_64(A)*fZE32_64(B)),     /* behavior */
    ()
)

DEF_MACRO(
    fMPY3216SS, /* multiply mixed precision */
    (fSE32_64(A)*fSXTN(16,64,B)),     /* behavior */
    ()
)

DEF_MACRO(
    fMPY3216SU, /* multiply mixed precision */
    (fSE32_64(A)*fZXTN(16,64,B)),     /* behavior */
    ()
)

DEF_MACRO(
    fROUND, /* optional rounding */
    (A+0x8000),
    /* optional attributes */
)

DEF_MACRO(
    fCLIP, /* optional rounding */
    { size4s_t maxv = (1<<U)-1;
      size4s_t minv = -(1<<U);
      DST = fMIN(maxv,fMAX(SRC,minv));
    },
    /* optional attributes */
)

DEF_MACRO(
    fCRND, /* optional rounding */
    ((((A)&0x3)==0x3)?((A)+1):((A))),
    /* optional attributes */
)

DEF_MACRO(
    fRNDN, /* Rounding to a boundary */
    ((((N)==0)?(A):(((fSE32_64(A))+(1<<((N)-1)))))),
    /* optional attributes */
)

DEF_MACRO(
    fCRNDN, /* Rounding to a boundary */
    (conv_round(A,N)),
    /* optional attributes */
)

DEF_MACRO(
    fADD128, /* Rounding to a boundary */
    (add128(A, B)),
    /* optional attributes */
)
DEF_MACRO(
    fSUB128, /* Rounding to a boundary */
    (sub128(A, B)),
    /* optional attributes */
)
DEF_MACRO(
    fSHIFTR128, /* Rounding to a boundary */
    (shiftr128(A, B)),
    /* optional attributes */
)

DEF_MACRO(
    fSHIFTL128, /* Rounding to a boundary */
    (shiftl128(A, B)),
    /* optional attributes */
)

DEF_MACRO(
    fAND128, /* Rounding to a boundary */
    (and128(A, B)),
    /* optional attributes */
)

DEF_MACRO(
    fCAST8S_16S, /* Rounding to a boundary */
    (cast8s_to_16s(A)),
    /* optional attributes */
)
DEF_MACRO(
    fCAST16S_8S, /* Rounding to a boundary */
    (cast16s_to_8s(A)),
    /* optional attributes */
)

DEF_MACRO(
    fEA_RI, /* Calculate EA with Register + Immediate Offset */
    do { EA=REG+IMM; fDOCHKPAGECROSS(REG,EA); } while (0),
    ()
)

DEF_MACRO(
    fEA_RRs, /* Calculate EA with Register + Registers scaled Offset */
    do { EA=REG+(REG2<<SCALE); fDOCHKPAGECROSS(REG,EA); } while (0),
    ()
)

DEF_MACRO(
    fEA_IRs, /* Calculate EA with Immediate + Registers scaled Offset */
    do { EA=IMM+(REG<<SCALE); fDOCHKPAGECROSS(IMM,EA); } while (0),
    ()
)

DEF_MACRO(
    fEA_IMM, /* Calculate EA with Immediate */
    EA=IMM,
    ()
)

DEF_MACRO(
    fEA_REG, /* Calculate EA with REGISTER */
    EA=REG,
    ()
)

DEF_MACRO(
    fEA_BREVR, /* Calculate EA with bit reversed bottom of REGISTER */
    EA=fbrev(REG),
    ()
)

DEF_MACRO(
    fEA_GPI, /* Calculate EA with Global Pointer + Immediate */
    do { EA=fREAD_GP()+IMM; fGP_DOCHKPAGECROSS(fREAD_GP(),EA); } while (0),
    ()
)

DEF_MACRO(
    fPM_I, /* Post Modify Register by Immediate*/
    do { REG = REG + IMM; } while (0),
    ()
)

DEF_MACRO(
    fPM_M, /* Post Modify Register by M register */
    do { REG = REG + MVAL; } while (0),
    ()
)

DEF_MACRO(
    fPM_CIRI, /* Post Modify Register using Circular arithmetic by Immediate */
    do { fcirc_add(REG,siV,MuV); } while (0),
    ()
)

DEF_MACRO(
    fPM_CIRR, /* Post Modify Register using Circular arithmetic by register */
    do { fcirc_add(REG,VAL,MuV); } while (0),
    ()
)



DEF_MACRO(
    fSCALE, /* scale by N */
    (((size8s_t)(A))<<N),
    /* optional attributes */
)
DEF_MACRO(
    fVSATW, /* saturating to 32-bits*/
    fVSATN(32,((long long)A)),
    ()
)

DEF_MACRO(
    fSATW, /* saturating to 32-bits*/
    fSATN(32,((long long)A)),
    ()
)

DEF_MACRO(
    fVSAT, /* saturating to 32-bits*/
    fVSATN(32,(A)),
    ()
)

DEF_MACRO(
    fSAT, /* saturating to 32-bits*/
    fSATN(32,(A)),
    ()
)

DEF_MACRO(
    fSAT_ORIG_SHL, /* Saturating to 32-bits, with original value, for shift left */
    ((((size4s_t)((fSAT(A)) ^ ((size4s_t)(ORIG_REG)))) < 0) ?
        fSATVALN(32,((size4s_t)(ORIG_REG))) :
        ((((ORIG_REG) > 0) && ((A) == 0)) ?
            fSATVALN(32,(ORIG_REG)) :
            fSAT(A))),
    ()
)

DEF_MACRO(
    fPASS,
    A,
)

DEF_MACRO(
    fRND, /* saturating to 32-bits*/
    (((A)+1)>>1),
)


DEF_MACRO(
    fBIDIR_SHIFTL,
    (((SHAMT) < 0) ? ((fCAST##REGSTYPE(SRC) >> ((-(SHAMT))-1)) >>1) : (fCAST##REGSTYPE(SRC) << (SHAMT))),
    ()
)

DEF_MACRO(
    fBIDIR_ASHIFTL,
    fBIDIR_SHIFTL(SRC,SHAMT,REGSTYPE##s),
    ()
)

DEF_MACRO(
    fBIDIR_LSHIFTL,
    fBIDIR_SHIFTL(SRC,SHAMT,REGSTYPE##u),
    ()
)

DEF_MACRO(
    fBIDIR_ASHIFTL_SAT,
    (((SHAMT) < 0) ? ((fCAST##REGSTYPE##s(SRC) >> ((-(SHAMT))-1)) >>1) : fSAT_ORIG_SHL(fCAST##REGSTYPE##s(SRC) << (SHAMT),(SRC))),
    ()
)


DEF_MACRO(
    fBIDIR_SHIFTR,
    (((SHAMT) < 0) ? ((fCAST##REGSTYPE(SRC) << ((-(SHAMT))-1)) << 1) : (fCAST##REGSTYPE(SRC) >> (SHAMT))),
    ()
)

DEF_MACRO(
    fBIDIR_ASHIFTR,
    fBIDIR_SHIFTR(SRC,SHAMT,REGSTYPE##s),
    ()
)

DEF_MACRO(
    fBIDIR_LSHIFTR,
    fBIDIR_SHIFTR(SRC,SHAMT,REGSTYPE##u),
    ()
)

DEF_MACRO(
    fBIDIR_ASHIFTR_SAT,
    (((SHAMT) < 0) ? fSAT_ORIG_SHL((fCAST##REGSTYPE##s(SRC) << ((-(SHAMT))-1)) << 1,(SRC)) : (fCAST##REGSTYPE##s(SRC) >> (SHAMT))),
    ()
)

DEF_MACRO(
    fASHIFTR,
    (fCAST##REGSTYPE##s(SRC) >> (SHAMT)),
    /* */
)

DEF_MACRO(
    fLSHIFTR,
    (((SHAMT) >= 64)?0:(fCAST##REGSTYPE##u(SRC) >> (SHAMT))),
    /* */
)

DEF_MACRO(
    fROTL,
    (((SHAMT)==0) ? (SRC) : ((fCAST##REGSTYPE##u(SRC) << (SHAMT)) | \
        ((fCAST##REGSTYPE##u(SRC) >> ((sizeof(SRC)*8)-(SHAMT)))))),
    /* */
)

DEF_MACRO(
    fROTR,
    (((SHAMT)==0) ? (SRC) : ((fCAST##REGSTYPE##u(SRC) >> (SHAMT)) | \
        ((fCAST##REGSTYPE##u(SRC) << ((sizeof(SRC)*8)-(SHAMT)))))),
    /* */
)

DEF_MACRO(
    fASHIFTL,
    (((SHAMT) >= 64)?0:(fCAST##REGSTYPE##s(SRC) << (SHAMT))),
    /* */
)

/*************************************/
/* Floating-Point Support            */
/************************************/

DEF_MACRO(
    fFLOAT, /* name */
    ({ union { float f; size4u_t i; } _fipun; _fipun.i = (A); _fipun.f; }),     /* behavior */
    (A_FPOP)
)

DEF_MACRO(
    fUNFLOAT, /* multiply half integer */
    ({ union { float f; size4u_t i; } _fipun; _fipun.f = (A); isnan(_fipun.f) ? 0xFFFFFFFFU : _fipun.i; }),     /* behavior */
    (A_FPOP)
)

DEF_MACRO(
    fSFNANVAL,
    0xffffffff,
    ()
)

DEF_MACRO(
    fSFINFVAL,
    (((A) & 0x80000000) | 0x7f800000),
    ()
)

DEF_MACRO(
    fSFONEVAL,
    (((A) & 0x80000000) | fUNFLOAT(1.0)),
    ()
)

DEF_MACRO(
    fCHECKSFNAN,
    do {
        if (isnan(fFLOAT(A))) {
            if ((fGETBIT(22,A)) == 0) fRAISEFLAGS(FE_INVALID);
            DST = fSFNANVAL();
        }
    } while (0),
    ()
)

DEF_MACRO(
    fCHECKSFNAN3,
    do {
        fCHECKSFNAN(DST,A);
        fCHECKSFNAN(DST,B);
        fCHECKSFNAN(DST,C);
    } while (0),
    ()
)

DEF_MACRO(
    fSF_BIAS,
    127,
    ()
)

DEF_MACRO(
    fSF_MANTBITS,
    23,
    ()
)

DEF_MACRO(
    fSF_MUL_POW2,
    (fUNFLOAT(fFLOAT(A) * fFLOAT((fSF_BIAS() + (B)) << fSF_MANTBITS()))),
    ()
)

DEF_MACRO(
    fSF_GETEXP,
    (((A) >> fSF_MANTBITS()) & 0xff),
    ()
)

DEF_MACRO(
    fSF_MAXEXP,
    (254),
    ()
)

DEF_MACRO(
    fSF_RECIP_COMMON,
    arch_sf_recip_common(&N,&D,&O,&A),
    (A_FPOP)
)

DEF_MACRO(
    fSF_INVSQRT_COMMON,
    arch_sf_invsqrt_common(&N,&O,&A),
    (A_FPOP)
)

DEF_MACRO(
    fFMAFX,
    internal_fmafx(A,B,C,fSXTN(8,64,ADJ)),
    ()
)

DEF_MACRO(
    fFMAF,
    internal_fmafx(A,B,C,0),
    ()
)

DEF_MACRO(
    fSFMPY,
    internal_mpyf(A,B),
    ()
)

DEF_MACRO(
    fMAKESF,
    ((((SIGN) & 1) << 31) | (((EXP) & 0xff) << fSF_MANTBITS()) |
        ((MANT) & ((1<<fSF_MANTBITS())-1))),
    ()
)


DEF_MACRO(
    fDOUBLE, /* multiply half integer */
    ({ union { double f; size8u_t i; } _fipun; _fipun.i = (A); _fipun.f; }),     /* behavior */
    (A_FPOP)
)

DEF_MACRO(
    fUNDOUBLE, /* multiply half integer */
    ({ union { double f; size8u_t i; } _fipun; _fipun.f = (A); isnan(_fipun.f) ? 0xFFFFFFFFFFFFFFFFULL : _fipun.i; }),     /* behavior */
    (A_FPOP)
)

DEF_MACRO(
    fDFNANVAL,
    0xffffffffffffffffULL,
    ()
)

DEF_MACRO(
    fDF_ISNORMAL,
    (fpclassify(fDOUBLE(X)) == FP_NORMAL),
    ()
)

DEF_MACRO(
    fDF_ISDENORM,
    (fpclassify(fDOUBLE(X)) == FP_SUBNORMAL),
    ()
)

DEF_MACRO(
    fDF_ISBIG,
    (fDF_GETEXP(X) >= 512),
    ()
)

DEF_MACRO(
    fDF_MANTBITS,
    52,
    ()
)

DEF_MACRO(
    fDF_GETEXP,
    (((A) >> fDF_MANTBITS()) & 0x7ff),
    ()
)

DEF_MACRO(
    fFMA,
    internal_fma(A,B,C),
    /* nothing */
)

DEF_MACRO(
    fDF_MPY_HH,
    internal_mpyhh(A,B,ACC),
    /* nothing */
)

DEF_MACRO(
    fFPOP_START,
    arch_fpop_start(thread),
    /* nothing */
)

DEF_MACRO(
    fFPOP_END,
    arch_fpop_end(thread),
    /* nothing */
)

DEF_MACRO(
    fFPSETROUND_NEAREST,
    fesetround(FE_TONEAREST),
    /* nothing */
)

DEF_MACRO(
    fFPSETROUND_CHOP,
    fesetround(FE_TOWARDZERO),
    /* nothing */
)

DEF_MACRO(
    fFPCANCELFLAGS,
    feclearexcept(FE_ALL_EXCEPT),
    /* nothing */
)

DEF_MACRO(
    fISINFPROD,
    ((isinf(A) && isinf(B)) ||
     (isinf(A) && isfinite(B) && ((B) != 0.0)) ||
     (isinf(B) && isfinite(A) && ((A) != 0.0))),
    /* nothing */
)

DEF_MACRO(
    fISZEROPROD,
    ((((A) == 0.0) && isfinite(B)) || (((B) == 0.0) && isfinite(A))),
    /* nothing */
)

DEF_MACRO(
    fRAISEFLAGS,
    arch_raise_fpflag(A),
    /* NOTHING */
)

DEF_MACRO(
    fDF_MAX,
    (((A)==(B))
    ? fDOUBLE(fUNDOUBLE(A) & fUNDOUBLE(B))
    : fmax(A,B)),
    (A_FPOP)
)

DEF_MACRO(
    fDF_MIN,
    (((A)==(B))
    ? fDOUBLE(fUNDOUBLE(A) | fUNDOUBLE(B))
    : fmin(A,B)),
    (A_FPOP)
)

DEF_MACRO(
    fSF_MAX,
    (((A)==(B))
    ? fFLOAT(fUNFLOAT(A) & fUNFLOAT(B))
    : fmaxf(A,B)),
    (A_FPOP)
)

DEF_MACRO(
    fSF_MIN,
    (((A)==(B))
    ? fFLOAT(fUNFLOAT(A) | fUNFLOAT(B))
    : fminf(A,B)),
    (A_FPOP)
)

/*************************************/
/* Load/Store support                */
/*************************************/

DEF_MACRO(fLOAD,
    { DST = (size##SIZE##SIGN##_t)MEM_LOAD##SIZE(thread,EA,insn); },
    (A_LOAD,A_MEMLIKE)
)

DEF_MACRO(fMEMOP,
    { memop##SIZE##_##FNTYPE(thread,EA,VALUE); },
    (A_LOAD,A_STORE,A_MEMLIKE)
)

DEF_MACRO(fGET_FRAMEKEY,
    READ_RREG(REG_FRAMEKEY),
    ()
)

DEF_MACRO(fFRAME_SCRAMBLE,
    ((VAL) ^ (fCAST8u(fGET_FRAMEKEY()) << 32)),
    /* ATTRIBS */
)

DEF_MACRO(fFRAME_UNSCRAMBLE,
    fFRAME_SCRAMBLE(VAL),
    /* ATTRIBS */
)

DEF_MACRO(fFRAMECHECK,
    sys_check_framelimit(thread,ADDR,EA),
    ()
)

DEF_MACRO(fLOAD_LOCKED,
    {     DST = (size##SIZE##SIGN##_t)mem_load_locked(thread,EA,SIZE,insn); },
    (A_LOAD,A_MEMLIKE)
)

DEF_MACRO(fSTORE,
    { MEM_STORE##SIZE(thread,EA,SRC,insn); },
    (A_STORE,A_MEMLIKE)
)


DEF_MACRO(fSTORE_LOCKED,
    { PRED = (mem_store_conditional(thread,EA,SRC,SIZE,insn) ? 0xff : 0); },
    (A_STORE,A_MEMLIKE)
)

/*************************************/
/* Functions to help with bytes      */
/*************************************/

DEF_MACRO(fGETBYTE,
    ((size1s_t)((SRC>>((N)*8))&0xff)),
    /* nothing */
)

DEF_MACRO(fGETUBYTE,
    ((size1u_t)((SRC>>((N)*8))&0xff)),
    /* nothing */
)

DEF_MACRO(fSETBYTE,
    {
        DST = (DST & ~(0x0ffLL<<((N)*8))) | (((size8u_t)((VAL) & 0x0ffLL)) << ((N)*8));
    },
    /* nothing */
)

DEF_MACRO(fGETHALF,
    ((size2s_t)((SRC>>((N)*16))&0xffff)),
    /* nothing */
)

DEF_MACRO(fGETUHALF,
    ((size2u_t)((SRC>>((N)*16))&0xffff)),
    /* nothing */
)

DEF_MACRO(fSETHALF,
    {
        DST = (DST & ~(0x0ffffLL<<((N)*16))) | (((size8u_t)((VAL) & 0x0ffff)) << ((N)*16));
    },
    /* nothing */
)



DEF_MACRO(fGETWORD,
    ((size8s_t)((size4s_t)((SRC>>((N)*32))&0x0ffffffffLL))),
    /* nothing */
)

DEF_MACRO(fGETUWORD,
    ((size8u_t)((size4u_t)((SRC>>((N)*32))&0x0ffffffffLL))),
    /* nothing */
)

DEF_MACRO(fSETWORD,
    {
        DST = (DST & ~(0x0ffffffffLL<<((N)*32))) | (((VAL) & 0x0ffffffffLL) << ((N)*32));
    },
    /* nothing */
)

DEF_MACRO(fSETBIT,
    {
        DST = (DST & ~(1ULL<<(N))) | (((size8u_t)(VAL))<<(N));
    },
    /* nothing */
)

DEF_MACRO(fGETBIT,
    (((SRC)>>N)&1),
    /* nothing */
)


DEF_MACRO(fSETBITS,
    do {
        int j;
        for (j=LO;j<=HI;j++) {
          fSETBIT(j,DST,VAL);
        }
    } while (0),
    /* nothing */
)

/*************************************/
/* Used for parity, etc........      */
/*************************************/
DEF_MACRO(fCOUNTONES_2,
    count_ones_2(VAL),
    /* nothing */
)

DEF_MACRO(fCOUNTONES_4,
    count_ones_4(VAL),
    /* nothing */
)

DEF_MACRO(fCOUNTONES_8,
    count_ones_8(VAL),
    /* nothing */
)

DEF_MACRO(fBREV_8,
    reverse_bits_8(VAL),
    /* nothing */
)

DEF_MACRO(fBREV_4,
    reverse_bits_4(VAL),
    /* nothing */
)

DEF_MACRO(fCL1_8,
    count_leading_ones_8(VAL),
    /* nothing */
)

DEF_MACRO(fCL1_4,
    count_leading_ones_4(VAL),
    /* nothing */
)

DEF_MACRO(fCL1_2,
    count_leading_ones_2(VAL),
    /* nothing */
)

DEF_MACRO(fINTERLEAVE,
    interleave(ODD,EVEN),
    /* nothing */
)

DEF_MACRO(fDEINTERLEAVE,
    deinterleave(MIXED),
    /* nothing */
)

DEF_MACRO(fHIDE,
    A,
    ()
)

DEF_MACRO(fCONSTLL,
    A##LL,
)

/* Do the things in the parens, but don't print the parens. */
DEF_MACRO(fECHO,
    (A),
    /* nothing */
)


/********************************************/
/* OS interface and stop/wait               */
/********************************************/

DEF_MACRO(RUNNABLE_THREADS_MAX,
    (thread->processor_ptr->runnable_threads_max),
    ()
)

DEF_MACRO(THREAD_IS_ON,
    ((PROC->arch_proc_options->thread_enable_mask>>TNUM) & 0x1),
    ()
)

DEF_MACRO(THREAD_EN_MASK,
    ((PROC->arch_proc_options->thread_enable_mask)),
    ()
)



DEF_MACRO(READ_IMASK,
    (((TH) >= (thread->processor_ptr->runnable_threads_max)) ? 0 : (thread->processor_ptr->thread[TH]->Regs[REG_IMASK])),
    ()
)
DEF_MACRO(WRITE_IMASK,
    if ((TH) < (thread->processor_ptr->runnable_threads_max)) { thread->processor_ptr->thread[TH]->Regs[REG_IMASK]=(VAL & reg_mutability[REG_IMASK] ); },
    (A_IMPLICIT_WRITES_IMASK_ANYTHREAD)
)


DEF_MACRO(WRITE_PRIO,
    {
        if ((TH) < (thread->processor_ptr->runnable_threads_max)) {
            size4u_t tid_reg = thread->processor_ptr->thread[TH]->Regs[REG_TID];
            fINSERT_BITS(tid_reg, reg_field_info[STID_PRIO].width, reg_field_info[STID_PRIO].offset, VAL);
            LOG_OTHER_THREAD_REG_WRITE(thread,REG_TID,tid_reg,TH);
        }
    },
    (A_IMPLICIT_WRITES_STID_PRIO_ANYTHREAD)
)


DEF_MACRO(DO_IASSIGNW,
    {
        int i;
        int intbitpos = ((REG>>16)&0xF);
        for (i=0;i<RUNNABLE_THREADS_MAX;i++) {
            if(( (thread->processor_ptr->arch_proc_options->thread_enable_mask>>i) & 0x1)) {
                fINSERT_BITS(thread->processor_ptr->thread[i]->Regs[REG_IMASK],1, intbitpos, (REG>>i) & 1);
           }
        }
    },
    (A_IMPLICIT_WRITES_IMASK_ANYTHREAD)
)




DEF_MACRO(fDO_NMI,
    {
        int i;
        for (i=0;i<RUNNABLE_THREADS_MAX;i++) {
            if( ( (thread->processor_ptr->arch_proc_options->thread_enable_mask>>i) & 0x1) ) {
                if (SREG & (1<<i)) {
                    register_nmi_interrupt(thread->processor_ptr->thread[i]);
                }
            }
        }
    },
)

DEF_MACRO(fDO_TRACE,
    {
        fHIDE(HEX_CALLBACK(thread->processor_ptr->options->trace_callback,
            thread->system_ptr,thread->processor_ptr,
            thread->threadId,SREG);)
    },
)

DEF_MACRO(DO_IASSIGNR,
    {
        int i;
        int result=0;
        int intbitpos = ((SREG>>16)&0xF);
        for (i=0;i<RUNNABLE_THREADS_MAX;i++) {
            if(( (thread->processor_ptr->arch_proc_options->thread_enable_mask>>i) & 0x1)) {
                result |= (((thread->processor_ptr->thread[i]->Regs[REG_IMASK]>>intbitpos)&1)<<i);
            }
        }
        DREG=result;
    },
    ()
)

DEF_MACRO(DO_SWI,
        {fHIDE(HEX_CALLBACK(thread->processor_ptr->options->swi_callback,
         thread->system_ptr,thread->processor_ptr,
         thread->threadId,REG));
         LOG_GLOBAL_REG_WRITE(REG_IPEND,(GLOBAL_REG_READ(REG_IPEND) | (REG & GLOBAL_REG_READ(REG_IEL))));
        },
        (A_EXCEPTION_SWI)
)

DEF_MACRO(DO_CSWI,
        LOG_GLOBAL_REG_WRITE(REG_IPEND,GLOBAL_REG_READ(REG_IPEND) & ~((REG) & GLOBAL_REG_READ(REG_IEL)));,
        ()
)

DEF_MACRO(DO_CIAD,
        sys_ciad(thread,VAL); LOG_GLOBAL_REG_WRITE(REG_IAD,GLOBAL_REG_READ(REG_IAD) & ~(VAL));,
        (A_EXCEPTION_SWI)
)

DEF_MACRO(DO_SIAD,
        sys_siad(thread,VAL); LOG_GLOBAL_REG_WRITE(REG_IAD,GLOBAL_REG_READ(REG_IAD) | (VAL));,
        (A_EXCEPTION_SWI)
)

DEF_MACRO(fBREAK,
    {isdb_brkpt_insn(thread->processor_ptr,thread->threadId);},
    ()
)

DEF_MACRO(fPAUSE,
    {sys_pause(thread, insn->slot, IMM);},
    ()
)


DEF_MACRO(fTRAP,
    warn("Trap NPC=%x ",fREAD_NPC());
    warn("Trap exception, PCYCLE=%lld TYPE=%d NPC=%x IMM=0x%x",thread->processor_ptr->pstats[pcycles],TRAPTYPE,fREAD_NPC(),IMM);
    register_trap_exception(thread,fREAD_NPC(),TRAPTYPE,IMM);,
    (A_EXCEPTION_SWI)
)

DEF_MACRO(fINTERNAL_CLEAR_SAMEPAGE,
    /* force re-xlate at next fetch, refresh of in_user_mode, etc */
    /* Permissions change too... */
    sys_utlb_invalidate(thread->processor_ptr,thread),
    /* NOTHING */
)

DEF_MACRO(fCLEAR_RTE_EX,
      {
        fLOG_REG_FIELD(SSR,SSR_EX,0);
        fINTERNAL_CLEAR_SAMEPAGE();
      },
      ()
)

DEF_MACRO(fTLB_LOCK_AVAILABLE,
    (fREAD_GLOBAL_REG_FIELD(SYSCONF,SYSCFG_TLBLOCK) == 0),
    ()
)

DEF_MACRO(fK0_LOCK_AVAILABLE,
    (fREAD_GLOBAL_REG_FIELD(SYSCONF,SYSCFG_K0LOCK) == 0),
    ()
)

DEF_MACRO(fSET_TLB_LOCK,
      {
      if (fTLB_LOCK_AVAILABLE()) {
        fLOG_GLOBAL_REG_FIELD(SYSCONF,SYSCFG_TLBLOCK,1);
      } else {
        sys_waiting_for_tlb_lock(thread);
      }
      },
      ()
)

DEF_MACRO(fSET_K0_LOCK,
      {
          if (fK0_LOCK_AVAILABLE() && sys_k0lock_queue_ready(thread)) {
              warn("k0lock: T%d: PC=0x%x: PCycle=%lld",thread->threadId,thread->Regs[REG_PC],thread->processor_ptr->pstats[pcycles]);
              fLOG_GLOBAL_REG_FIELD(SYSCONF,SYSCFG_K0LOCK,1);
          } else {
              warn("k0lock_waiting: T%d: PC=0x%x: PCycle=%lld",thread->threadId,thread->Regs[REG_PC],thread->processor_ptr->pstats[pcycles]);
                sys_waiting_for_k0_lock(thread);
          }
      },
      ()
)

DEF_MACRO(fCLEAR_TLB_LOCK,
      {
          int i;
          fLOG_GLOBAL_REG_FIELD(SYSCONF,SYSCFG_TLBLOCK,0);
          for (i = 0; i < RUNNABLE_THREADS_MAX; i++) {
              if(( (thread->processor_ptr->arch_proc_options->thread_enable_mask>>i) & 0x1)) {
                  thread->processor_ptr->thread[i]->cu_tlb_lock_waiting = 0;
              }
          }
      },
      ()
)

DEF_MACRO(fCLEAR_K0_LOCK,
      do {
      warn("k0unlock: T%d: PC=0x%x: Pcycle=%lld",thread->threadId,thread->Regs[REG_PC], thread->processor_ptr->pstats[pcycles]);
      sys_initiate_clear_k0_lock(thread);
      } while (0),
      ()
)

DEF_MACRO(fALIGN_REG_FIELD_VALUE,
    ((VAL)<<reg_field_info[FIELD].offset),
    /* */
)

DEF_MACRO(fGET_REG_FIELD_MASK,
    (((1<<reg_field_info[FIELD].width)-1)<<reg_field_info[FIELD].offset),
    /* */
)

DEF_MACRO(fLOG_REG_FIELD,
    LOG_MASKED_REG_WRITE(thread,REG_##REG,
    fALIGN_REG_FIELD_VALUE(FIELD,VAL),
    fGET_REG_FIELD_MASK(FIELD)),
    ()
)

DEF_MACRO(fWRITE_GLOBAL_REG_FIELD,
    fINSERT_BITS(thread->processor_ptr->global_regs[REG_##REG],
            reg_field_info[FIELD].width,
            reg_field_info[FIELD].offset,VAL),
)

DEF_MACRO(fLOG_GLOBAL_REG_FIELD,
    LOG_MASKED_GLOBAL_REG_WRITE(REG_##REG,
        fALIGN_REG_FIELD_VALUE(FIELD,VAL),
        fGET_REG_FIELD_MASK(FIELD)),
    ()
)

DEF_MACRO(fREAD_REG_FIELD,
    fEXTRACTU_BITS(thread->Regs[REG_##REG],
        reg_field_info[FIELD].width,
        reg_field_info[FIELD].offset),
    /* ATTRIBS */
)

DEF_MACRO(fREAD_GLOBAL_REG_FIELD,
    fEXTRACTU_BITS(thread->processor_ptr->global_regs[REG_##REG],
        reg_field_info[FIELD].width,
        reg_field_info[FIELD].offset),
    /* ATTRIBS */
)

DEF_MACRO(fGET_FIELD,
    fEXTRACTU_BITS(VAL,
        reg_field_info[FIELD].width,
        reg_field_info[FIELD].offset),
    /* ATTRIBS */
)

DEF_MACRO(fSET_FIELD,
    fINSERT_BITS(VAL,
        reg_field_info[FIELD].width,
        reg_field_info[FIELD].offset,
        (NEWVAL)),
    /* ATTRIBS */
)

DEF_MACRO(fSET_RUN_MODE_NOW,
        {thread->processor_ptr->global_regs[REG_MODECTL] |= (1<<TNUM);
         thread->last_commit_cycle = thread->processor_ptr->pcycle_counter;
         sys_recalc_num_running_threads(thread->processor_ptr);},
)

DEF_MACRO(fIN_DEBUG_MODE,
    (thread->debug_mode || (fREAD_GLOBAL_REG_FIELD(ISDBST,ISDBST_DEBUGMODE) & 1<<TNUM)),
    ()
)
DEF_MACRO(fIN_DEBUG_MODE_NO_ISDB,
    (thread->debug_mode),
    ()
)


DEF_MACRO(fIN_DEBUG_MODE_WARN,
    {
        if (fREAD_GLOBAL_REG_FIELD(ISDBST,ISDBST_DEBUGMODE) & 1<<TNUM)
            warn("In ISDB debug mode, but TB told me to step normally");
    },
    ()
)

DEF_MACRO(fCLEAR_RUN_MODE,
    {fLOG_GLOBAL_REG_FIELD(MODECTL,MODECTL_E,
     fREAD_GLOBAL_REG_FIELD(MODECTL,MODECTL_E) & ~(1<<(TNUM)))},
    /* NOTHING */
)

DEF_MACRO(fCLEAR_RUN_MODE_NOW,
    do {
        fWRITE_GLOBAL_REG_FIELD(MODECTL,MODECTL_E,
        fREAD_GLOBAL_REG_FIELD(MODECTL,MODECTL_E) & ~(1<<(TNUM)));
        sys_recalc_num_running_threads(thread->processor_ptr);
    } while (0),
    /* NOTHING */
)

DEF_MACRO(fGET_RUN_MODE,
        ((thread->processor_ptr->global_regs[REG_MODECTL]>>TNUM)&0x1),
)

DEF_MACRO(fSET_WAIT_MODE,
    {fLOG_GLOBAL_REG_FIELD(MODECTL,MODECTL_W,
    fREAD_GLOBAL_REG_FIELD(MODECTL,MODECTL_W) | 1<<(TNUM))},
    /* NOTHING */
)

DEF_MACRO(fCLEAR_WAIT_MODE,
        {thread->processor_ptr->global_regs[REG_MODECTL] &= ~(1<<(TNUM+16));
         thread->last_commit_cycle = thread->processor_ptr->pcycle_counter;
         sys_recalc_num_running_threads(thread->processor_ptr);},
)

DEF_MACRO(fGET_WAIT_MODE,
        ((thread->processor_ptr->global_regs[REG_MODECTL]>>(TNUM+16))&0x1),
)


DEF_MACRO(fRESET_THREAD,
        register_reset_interrupt(T,NUM),
)

DEF_MACRO(fREAD_CURRENT_EVB,
    (GLOBAL_REG_READ(REG_EVB)),
    /* nothing */
)

DEF_MACRO(fREAD_ELR,
    READ_RREG(REG_ELR),
    ()
)

DEF_MACRO(fPOW2_HELP_ROUNDUP,
    ((VAL) | ((VAL) >> 1) | ((VAL) >> 2) | ((VAL) >> 4) | ((VAL) >> 8) | ((VAL) >> 16)),
    ()
)

DEF_MACRO(fPOW2_ROUNDUP,
    fPOW2_HELP_ROUNDUP((VAL)-1)+1,
    ()
)

DEF_MACRO(fTLB_IDXMASK,
    ((INDEX) & (fPOW2_ROUNDUP(fCAST4u(thread->processor_ptr->arch_proc_options->jtlb_size)) - 1)),
    ()
)

DEF_MACRO(fTLB_NONPOW2WRAP,
    (((INDEX) >= thread->processor_ptr->arch_proc_options->jtlb_size) ? ((INDEX) - thread->processor_ptr->arch_proc_options->jtlb_size) : (INDEX)),
    /* ATTRIBS */
)

DEF_MACRO(fTLBW,
    do {size4u_t __myidx = fTLB_NONPOW2WRAP(fTLB_IDXMASK(INDEX));
        TLB_REG_WRITE(__myidx,VALUE);
        fHIDE(HEX_CALLBACK(thread->processor_ptr->options->tlbw_callback,thread->system_ptr,thread->processor_ptr,thread->threadId,__myidx);)
        fHIDE(sys_tlb_write(thread,__myidx,VALUE);)} while (0),
    /* ATTRIBS */
)

DEF_MACRO(fTLB_ENTRY_OVERLAP,
    fHIDE( (sys_check_overlap(thread,VALUE)!=-2) ),
    /* ATTRIBS */
)

DEF_MACRO(fTLB_ENTRY_OVERLAP_IDX,
    fHIDE(sys_check_overlap(thread,VALUE)),
    /* ATTRIBS */
)


DEF_MACRO(fTLBR,
    TLB_REG_READ(fTLB_NONPOW2WRAP(fTLB_IDXMASK(INDEX))),
    /* ATTRIBS */
)

DEF_MACRO(fTLBP,
    tlb_lookup(thread,((TLBHI)>>12),((TLBHI)<<12),1),
    /* attribs */
)



DEF_MACRO(READ_SGP0,
    READ_RREG(REG_SGP),
    ()
)

DEF_MACRO(READ_SGP1,
    READ_RREG(REG_SGP+1),
    ()
)

DEF_MACRO(READ_SGP10,
    READ_RREG_PAIR(REG_SGP),
    ()
)

DEF_MACRO(READ_UGP,
    READ_RREG(REG_UGP),
)

DEF_MACRO(WRITE_SGP0,
    WRITE_RREG(REG_SGP,VAL),
    (A_IMPLICIT_WRITES_SGP0)
)

DEF_MACRO(WRITE_SGP1,
    WRITE_RREG(REG_SGP+1,VAL),
    (A_IMPLICIT_WRITES_SGP1)
)

DEF_MACRO(WRITE_SGP10,
    WRITE_RREG_PAIR(REG_SGP,VAL),
    (A_IMPLICIT_WRITES_SGP0,A_IMPLICIT_WRITES_SGP1)
)

DEF_MACRO(WRITE_UGP,
        WRITE_RREG(REG_UGP,VAL),
)

DEF_MACRO(fSTART,
    fLOG_GLOBAL_REG_FIELD(MODECTL,MODECTL_E, fREAD_GLOBAL_REG_FIELD(MODECTL,MODECTL_E) | (((REG & ((1<<RUNNABLE_THREADS_MAX)-1))) & THREAD_EN_MASK(thread->processor_ptr))),
    ()
)

DEF_MACRO(fRESUME,
    fLOG_GLOBAL_REG_FIELD(MODECTL,MODECTL_W,
    fREAD_GLOBAL_REG_FIELD(MODECTL,MODECTL_W) & (~(REG))),
    ()
)

DEF_MACRO(fGET_TNUM,
    thread->threadId,
    ()
)

/********************************************/
/* Cache Management                         */
/********************************************/

DEF_MACRO(fBARRIER,
    {
        sys_barrier(thread, insn->slot);
    },
    ()
)

DEF_MACRO(fSYNCH,
    {
        sys_sync(thread, insn->slot);
    },
    ()
)

DEF_MACRO(fISYNC,
    {
        sys_isync(thread, insn->slot);
    },
    ()
)


DEF_MACRO(fICFETCH,
    ,
    ()
)

DEF_MACRO(fDCFETCH,
    sys_dcfetch(thread, (REG), insn->slot),
    (A_MEMLIKE)
)

DEF_MACRO(fICINVA,
    {
        arch_internal_flush(thread->processor_ptr, 0, 0xffffffff);
        sys_icinva(thread, (REG),insn->slot);
    },
    (A_ICINVA)
)

DEF_MACRO(fDCTAGR,
    ({DST=sys_dctagr(thread, INDEX, insn->slot,DSTREGNO);})/* FIXME */,
    ()
)

DEF_MACRO(fDCTAGW,
    (sys_dctagw(thread, INDEX, PART2, insn->slot)),
    ()
)
DEF_MACRO(fICTAGR,
    ({DST=sys_ictagr(thread, INDEX, insn->slot,REGNO);}),
    ()
)

DEF_MACRO(fICDATAR,
    ({DST=sys_icdatar(thread, INDEX, insn->slot);}),
    ()
)

DEF_MACRO(fICTAGW,
    (sys_ictagw(thread, INDEX, PART2, insn->slot)),
    ()
)
DEF_MACRO(fICDATAW,
    ({ fHIDE(); }),
    ()
)

DEF_MACRO(fL2FETCH,
    sys_l2fetch(thread, ADDR,HEIGHT,WIDTH,STRIDE,FLAGS, insn->slot),
    (A_MEMLIKE,A_L2FETCH)
)

DEF_MACRO(fDCCLEANA,
    sys_dccleana(thread, (REG)),
    (A_MEMLIKE)
)

DEF_MACRO(fDCCLEANINVA,
    sys_dccleaninva(thread, (REG), insn->slot),
    (A_MEMLIKE,A_DCCLEANINVA)
)

DEF_MACRO(fDCZEROA,
    sys_dczeroa(thread, (REG)),
    (A_MEMLIKE)
)

DEF_MACRO(fDCINVA,
    sys_dcinva(thread, (REG)),
    (A_MEMLIKE)
)


DEF_MACRO(fCHECKFORPRIV,
    {sys_check_privs(thread); if (EXCEPTION_DETECTED) return; },
    ()
)

DEF_MACRO(fCHECKFORGUEST,
    {sys_check_guest(thread); if (EXCEPTION_DETECTED) return; },
    ()
)

DEF_MACRO(fTAKEN_INTERRUPT_EDGECLEAR,
        { proc->global_regs[REG_IPEND] &= ~(INT_NUMTOMASK(intnum) & proc->global_regs[REG_IEL]); },
        ()
)

DEF_MACRO(fSET_IAD,
        { sys_siad(thread,INT_NUMTOMASK(intnum)); thread->processor_ptr->global_regs[REG_IAD] |= INT_NUMTOMASK(intnum); },
        ()
)

DEF_MACRO(fBRANCH_SPECULATE_STALL,
    {
        sys_speculate_branch_stall(thread, insn->slot, JUMP_COND(JUMP_PRED_SET),
            SPEC_DIR,
            DOTNEWVAL,
            HINTBITNUM,
            STRBITNUM,
            0,
            thread->last_pkt->pkt_has_dual_jump,
            insn->is_2nd_jump,
            (thread->fetch_access.vaddr + insn->encoding_offset*4));
    },
    ()
)

DEF_MACRO(IV1DEAD,
    ,
    ()
)

DEF_MACRO(fIN_MONITOR_MODE,
    sys_in_monitor_mode(thread),
    ()
)

DEF_MACRO(fIN_USER_MODE,
    sys_in_user_mode(thread),
    ()
)

DEF_MACRO(fIN_GUEST_MODE,
    sys_in_guest_mode(thread),
    ()
)

DEF_MACRO(fGRE_ENABLED,
    fREAD_REG_FIELD(CCR,CCR_GRE),
    ()
)

DEF_MACRO(fGTE_ENABLED,
    fREAD_REG_FIELD(CCR,CCR_GRE),
    ()
)

DEF_MACRO(fTRAP1_VIRTINSN,
    ((fIN_GUEST_MODE())
     && (fGRE_ENABLED())
     && (   ((IMM) == 1)
         || ((IMM) == 3)
         || ((IMM) == 4)
         || ((IMM) == 6))),
    ()
)

DEF_MACRO(fVIRTINSN_RTE,
    do {
        thread->trap1_info = TRAP1_VIRTINSN_RTE;
        fLOG_REG_FIELD(SSR,SSR_SS,fREAD_REG_FIELD(GSR,GSR_SS));
        fLOG_REG_FIELD(CCR,CCR_GIE,fREAD_REG_FIELD(GSR,GSR_IE));
        fLOG_REG_FIELD(SSR,SSR_GM,!fREAD_REG_FIELD(GSR,GSR_UM));
        fBRANCH((fREAD_GELR() & -4),COF_TYPE_RTE);
        fINTERNAL_CLEAR_SAMEPAGE();
    } while (0),
    (A_IMPLICIT_WRITES_CCR,A_IMPLICIT_WRITES_SSR)
)

DEF_MACRO(fVIRTINSN_SETIE,
    do {
        fLOG_REG_FIELD(CCR,CCR_GIE,(REG) & 1);
        REG = fREAD_REG_FIELD(CCR,CCR_GIE);
        thread->trap1_info = TRAP1_VIRTINSN_SETIE;
    } while (0),
    (A_IMPLICIT_WRITES_CCR)
)

DEF_MACRO(fVIRTINSN_GETIE,
    {
        thread->trap1_info = TRAP1_VIRTINSN_GETIE;
        REG = fREAD_REG_FIELD(CCR,CCR_GIE);
    },
    ()
)

DEF_MACRO(fVIRTINSN_SPSWAP,
    do {
        if (fREAD_REG_FIELD(GSR,GSR_UM)) {
            size4u_t TEMP = REG;
            REG = fREAD_GOSP();
            fWRITE_GOSP(TEMP);
            thread->trap1_info = TRAP1_VIRTINSN_SPSWAP;
        }
    } while (0),
    (A_IMPLICIT_WRITES_GOSP)
)
