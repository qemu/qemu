# -*- Mode: Python -*-
# vim: filetype=python

##
# = Block devices
##

{ 'include': 'block-core.json' }

##
# == Additional block stuff (VM related)
##

##
# @BiosAtaTranslation:
#
# Policy that BIOS should use to interpret cylinder/head/sector
# addresses.  Note that Bochs BIOS and SeaBIOS will not actually
# translate logical CHS to physical; instead, they will use logical
# block addressing.
#
# @auto: If cylinder/heads/sizes are passed, choose between none and LBA
#        depending on the size of the disk.  If they are not passed,
#        choose none if QEMU can guess that the disk had 16 or fewer
#        heads, large if QEMU can guess that the disk had 131072 or
#        fewer tracks across all heads (i.e. cylinders*heads<131072),
#        otherwise LBA.
#
# @none: The physical disk geometry is equal to the logical geometry.
#
# @lba: Assume 63 sectors per track and one of 16, 32, 64, 128 or 255
#       heads (if fewer than 255 are enough to cover the whole disk
#       with 1024 cylinders/head).  The number of cylinders/head is
#       then computed based on the number of sectors and heads.
#
# @large: The number of cylinders per head is scaled down to 1024
#         by correspondingly scaling up the number of heads.
#
# @rechs: Same as @large, but first convert a 16-head geometry to
#         15-head, by proportionally scaling up the number of
#         cylinders/head.
#
# Since: 2.0
##
{ 'enum': 'BiosAtaTranslation',
  'data': ['auto', 'none', 'lba', 'large', 'rechs']}

##
# @FloppyDriveType:
#
# Type of Floppy drive to be emulated by the Floppy Disk Controller.
#
# @144:  1.44MB 3.5" drive
# @288:  2.88MB 3.5" drive
# @120:  1.2MB 5.25" drive
# @none: No drive connected
# @auto: Automatically determined by inserted media at boot
#
# Since: 2.6
##
{ 'enum': 'FloppyDriveType',
  'data': ['144', '288', '120', 'none', 'auto']}

##
# @PRManagerInfo:
#
# Information about a persistent reservation manager
#
# @id: the identifier of the persistent reservation manager
#
# @connected: true if the persistent reservation manager is connected to
#             the underlying storage or helper
#
# Since: 3.0
##
{ 'struct': 'PRManagerInfo',
  'data': {'id': 'str', 'connected': 'bool'} }

##
# @query-pr-managers:
#
# Returns a list of information about each persistent reservation manager.
#
# Returns: a list of @PRManagerInfo for each persistent reservation manager
#
# Since: 3.0
##
{ 'command': 'query-pr-managers', 'returns': ['PRManagerInfo'],
  'allow-preconfig': true }

##
# @eject:
#
# Ejects the medium from a removable drive.
#
# @device: Block device name
#
# @id: The name or QOM path of the guest device (since: 2.8)
#
# @force: If true, eject regardless of whether the drive is locked.
#         If not specified, the default value is false.
#
# Features:
# @deprecated: Member @device is deprecated.  Use @id instead.
#
# Returns: - Nothing on success
#          - If @device is not a valid block device, DeviceNotFound
# Notes:    Ejecting a device with no media results in success
#
# Since: 0.14.0
#
# Example:
#
# -> { "execute": "eject", "arguments": { "id": "ide1-0-1" } }
# <- { "return": {} }
##
{ 'command': 'eject',
  'data': { '*device': { 'type': 'str', 'features': [ 'deprecated' ] },
            '*id': 'str',
            '*force': 'bool' } }

##
# @blockdev-open-tray:
#
# Opens a block device's tray. If there is a block driver state tree inserted as
# a medium, it will become inaccessible to the guest (but it will remain
# associated to the block device, so closing the tray will make it accessible
# again).
#
# If the tray was already open before, this will be a no-op.
#
# Once the tray opens, a DEVICE_TRAY_MOVED event is emitted. There are cases in
# which no such event will be generated, these include:
#
# - if the guest has locked the tray, @force is false and the guest does not
#   respond to the eject request
# - if the BlockBackend denoted by @device does not have a guest device attached
#   to it
# - if the guest device does not have an actual tray
#
# @device: Block device name
#
# @id: The name or QOM path of the guest device (since: 2.8)
#
# @force: if false (the default), an eject request will be sent to
#         the guest if it has locked the tray (and the tray will not be opened
#         immediately); if true, the tray will be opened regardless of whether
#         it is locked
#
# Features:
# @deprecated: Member @device is deprecated.  Use @id instead.
#
# Since: 2.5
#
# Example:
#
# -> { "execute": "blockdev-open-tray",
#      "arguments": { "id": "ide0-1-0" } }
#
# <- { "timestamp": { "seconds": 1418751016,
#                     "microseconds": 716996 },
#      "event": "DEVICE_TRAY_MOVED",
#      "data": { "device": "ide1-cd0",
#                "id": "ide0-1-0",
#                "tray-open": true } }
#
# <- { "return": {} }
#
##
{ 'command': 'blockdev-open-tray',
  'data': { '*device': { 'type': 'str', 'features': [ 'deprecated' ] },
            '*id': 'str',
            '*force': 'bool' } }

##
# @blockdev-close-tray:
#
# Closes a block device's tray. If there is a block driver state tree associated
# with the block device (which is currently ejected), that tree will be loaded
# as the medium.
#
# If the tray was already closed before, this will be a no-op.
#
# @device: Block device name
#
# @id: The name or QOM path of the guest device (since: 2.8)
#
# Features:
# @deprecated: Member @device is deprecated.  Use @id instead.
#
# Since: 2.5
#
# Example:
#
# -> { "execute": "blockdev-close-tray",
#      "arguments": { "id": "ide0-1-0" } }
#
# <- { "timestamp": { "seconds": 1418751345,
#                     "microseconds": 272147 },
#      "event": "DEVICE_TRAY_MOVED",
#      "data": { "device": "ide1-cd0",
#                "id": "ide0-1-0",
#                "tray-open": false } }
#
# <- { "return": {} }
#
##
{ 'command': 'blockdev-close-tray',
  'data': { '*device': { 'type': 'str', 'features': [ 'deprecated' ] },
            '*id': 'str' } }

##
# @blockdev-remove-medium:
#
# Removes a medium (a block driver state tree) from a block device. That block
# device's tray must currently be open (unless there is no attached guest
# device).
#
# If the tray is open and there is no medium inserted, this will be a no-op.
#
# @id: The name or QOM path of the guest device
#
# Since: 2.12
#
# Example:
#
# -> { "execute": "blockdev-remove-medium",
#      "arguments": { "id": "ide0-1-0" } }
#
# <- { "error": { "class": "GenericError",
#                 "desc": "Tray of device 'ide0-1-0' is not open" } }
#
# -> { "execute": "blockdev-open-tray",
#      "arguments": { "id": "ide0-1-0" } }
#
# <- { "timestamp": { "seconds": 1418751627,
#                     "microseconds": 549958 },
#      "event": "DEVICE_TRAY_MOVED",
#      "data": { "device": "ide1-cd0",
#                "id": "ide0-1-0",
#                "tray-open": true } }
#
# <- { "return": {} }
#
# -> { "execute": "blockdev-remove-medium",
#      "arguments": { "id": "ide0-1-0" } }
#
# <- { "return": {} }
#
##
{ 'command': 'blockdev-remove-medium',
  'data': { 'id': 'str' } }

##
# @blockdev-insert-medium:
#
# Inserts a medium (a block driver state tree) into a block device. That block
# device's tray must currently be open (unless there is no attached guest
# device) and there must be no medium inserted already.
#
# @id: The name or QOM path of the guest device
#
# @node-name: name of a node in the block driver state graph
#
# Since: 2.12
#
# Example:
#
# -> { "execute": "blockdev-add",
#      "arguments": {
#          "node-name": "node0",
#          "driver": "raw",
#          "file": { "driver": "file",
#                    "filename": "fedora.iso" } } }
# <- { "return": {} }
#
# -> { "execute": "blockdev-insert-medium",
#      "arguments": { "id": "ide0-1-0",
#                     "node-name": "node0" } }
#
# <- { "return": {} }
#
##
{ 'command': 'blockdev-insert-medium',
  'data': { 'id': 'str',
            'node-name': 'str'} }


##
# @BlockdevChangeReadOnlyMode:
#
# Specifies the new read-only mode of a block device subject to the
# @blockdev-change-medium command.
#
# @retain: Retains the current read-only mode
#
# @read-only: Makes the device read-only
#
# @read-write: Makes the device writable
#
# Since: 2.3
#
##
{ 'enum': 'BlockdevChangeReadOnlyMode',
  'data': ['retain', 'read-only', 'read-write'] }


##
# @blockdev-change-medium:
#
# Changes the medium inserted into a block device by ejecting the current medium
# and loading a new image file which is inserted as the new medium (this command
# combines blockdev-open-tray, blockdev-remove-medium, blockdev-insert-medium
# and blockdev-close-tray).
#
# @device: Block device name
#
# @id: The name or QOM path of the guest device
#      (since: 2.8)
#
# @filename: filename of the new image to be loaded
#
# @format: format to open the new image with (defaults to
#          the probed format)
#
# @read-only-mode: change the read-only mode of the device; defaults
#                  to 'retain'
#
# Features:
# @deprecated: Member @device is deprecated.  Use @id instead.
#
# Since: 2.5
#
# Examples:
#
# 1. Change a removable medium
#
# -> { "execute": "blockdev-change-medium",
#      "arguments": { "id": "ide0-1-0",
#                     "filename": "/srv/images/Fedora-12-x86_64-DVD.iso",
#                     "format": "raw" } }
# <- { "return": {} }
#
# 2. Load a read-only medium into a writable drive
#
# -> { "execute": "blockdev-change-medium",
#      "arguments": { "id": "floppyA",
#                     "filename": "/srv/images/ro.img",
#                     "format": "raw",
#                     "read-only-mode": "retain" } }
#
# <- { "error":
#      { "class": "GenericError",
#        "desc": "Could not open '/srv/images/ro.img': Permission denied" } }
#
# -> { "execute": "blockdev-change-medium",
#      "arguments": { "id": "floppyA",
#                     "filename": "/srv/images/ro.img",
#                     "format": "raw",
#                     "read-only-mode": "read-only" } }
#
# <- { "return": {} }
#
##
{ 'command': 'blockdev-change-medium',
  'data': { '*device': { 'type': 'str', 'features': [ 'deprecated' ] },
            '*id': 'str',
            'filename': 'str',
            '*format': 'str',
            '*read-only-mode': 'BlockdevChangeReadOnlyMode' } }


##
# @DEVICE_TRAY_MOVED:
#
# Emitted whenever the tray of a removable device is moved by the guest or by
# HMP/QMP commands
#
# @device: Block device name. This is always present for compatibility
#          reasons, but it can be empty ("") if the image does not
#          have a device name associated.
#
# @id: The name or QOM path of the guest device (since 2.8)
#
# @tray-open: true if the tray has been opened or false if it has been closed
#
# Since: 1.1
#
# Example:
#
# <- { "event": "DEVICE_TRAY_MOVED",
#      "data": { "device": "ide1-cd0",
#                "id": "/machine/unattached/device[22]",
#                "tray-open": true
#      },
#      "timestamp": { "seconds": 1265044230, "microseconds": 450486 } }
#
##
{ 'event': 'DEVICE_TRAY_MOVED',
  'data': { 'device': 'str', 'id': 'str', 'tray-open': 'bool' } }

##
# @PR_MANAGER_STATUS_CHANGED:
#
# Emitted whenever the connected status of a persistent reservation
# manager changes.
#
# @id: The id of the PR manager object
#
# @connected: true if the PR manager is connected to a backend
#
# Since: 3.0
#
# Example:
#
# <- { "event": "PR_MANAGER_STATUS_CHANGED",
#      "data": { "id": "pr-helper0",
#                "connected": true
#      },
#      "timestamp": { "seconds": 1519840375, "microseconds": 450486 } }
#
##
{ 'event': 'PR_MANAGER_STATUS_CHANGED',
  'data': { 'id': 'str', 'connected': 'bool' } }

##
# @block_set_io_throttle:
#
# Change I/O throttle limits for a block drive.
#
# Since QEMU 2.4, each device with I/O limits is member of a throttle
# group.
#
# If two or more devices are members of the same group, the limits
# will apply to the combined I/O of the whole group in a round-robin
# fashion. Therefore, setting new I/O limits to a device will affect
# the whole group.
#
# The name of the group can be specified using the 'group' parameter.
# If the parameter is unset, it is assumed to be the current group of
# that device. If it's not in any group yet, the name of the device
# will be used as the name for its group.
#
# The 'group' parameter can also be used to move a device to a
# different group. In this case the limits specified in the parameters
# will be applied to the new group only.
#
# I/O limits can be disabled by setting all of them to 0. In this case
# the device will be removed from its group and the rest of its
# members will not be affected. The 'group' parameter is ignored.
#
# Returns: - Nothing on success
#          - If @device is not a valid block device, DeviceNotFound
#
# Since: 1.1
#
# Example:
#
# -> { "execute": "block_set_io_throttle",
#      "arguments": { "id": "virtio-blk-pci0/virtio-backend",
#                     "bps": 0,
#                     "bps_rd": 0,
#                     "bps_wr": 0,
#                     "iops": 512,
#                     "iops_rd": 0,
#                     "iops_wr": 0,
#                     "bps_max": 0,
#                     "bps_rd_max": 0,
#                     "bps_wr_max": 0,
#                     "iops_max": 0,
#                     "iops_rd_max": 0,
#                     "iops_wr_max": 0,
#                     "bps_max_length": 0,
#                     "iops_size": 0 } }
# <- { "return": {} }
#
# -> { "execute": "block_set_io_throttle",
#      "arguments": { "id": "ide0-1-0",
#                     "bps": 1000000,
#                     "bps_rd": 0,
#                     "bps_wr": 0,
#                     "iops": 0,
#                     "iops_rd": 0,
#                     "iops_wr": 0,
#                     "bps_max": 8000000,
#                     "bps_rd_max": 0,
#                     "bps_wr_max": 0,
#                     "iops_max": 0,
#                     "iops_rd_max": 0,
#                     "iops_wr_max": 0,
#                     "bps_max_length": 60,
#                     "iops_size": 0 } }
# <- { "return": {} }
##
{ 'command': 'block_set_io_throttle', 'boxed': true,
  'data': 'BlockIOThrottle' }

##
# @block-latency-histogram-set:
#
# Manage read, write and flush latency histograms for the device.
#
# If only @id parameter is specified, remove all present latency histograms
# for the device. Otherwise, add/reset some of (or all) latency histograms.
#
# @id: The name or QOM path of the guest device.
#
# @boundaries: list of interval boundary values (see description in
#              BlockLatencyHistogramInfo definition). If specified, all
#              latency histograms are removed, and empty ones created for all
#              io types with intervals corresponding to @boundaries (except for
#              io types, for which specific boundaries are set through the
#              following parameters).
#
# @boundaries-read: list of interval boundary values for read latency
#                   histogram. If specified, old read latency histogram is
#                   removed, and empty one created with intervals
#                   corresponding to @boundaries-read. The parameter has higher
#                   priority then @boundaries.
#
# @boundaries-write: list of interval boundary values for write latency
#                    histogram.
#
# @boundaries-flush: list of interval boundary values for flush latency
#                    histogram.
#
# Returns: error if device is not found or any boundary arrays are invalid.
#
# Since: 4.0
#
# Example: set new histograms for all io types with intervals
# [0, 10), [10, 50), [50, 100), [100, +inf):
#
# -> { "execute": "block-latency-histogram-set",
#      "arguments": { "id": "drive0",
#                     "boundaries": [10, 50, 100] } }
# <- { "return": {} }
#
# Example: set new histogram only for write, other histograms will remain
# not changed (or not created):
#
# -> { "execute": "block-latency-histogram-set",
#      "arguments": { "id": "drive0",
#                     "boundaries-write": [10, 50, 100] } }
# <- { "return": {} }
#
# Example: set new histograms with the following intervals:
#   read, flush: [0, 10), [10, 50), [50, 100), [100, +inf)
#   write: [0, 1000), [1000, 5000), [5000, +inf)
#
# -> { "execute": "block-latency-histogram-set",
#      "arguments": { "id": "drive0",
#                     "boundaries": [10, 50, 100],
#                     "boundaries-write": [1000, 5000] } }
# <- { "return": {} }
#
# Example: remove all latency histograms:
#
# -> { "execute": "block-latency-histogram-set",
#      "arguments": { "id": "drive0" } }
# <- { "return": {} }
##
{ 'command': 'block-latency-histogram-set',
  'data': {'id': 'str',
           '*boundaries': ['uint64'],
           '*boundaries-read': ['uint64'],
           '*boundaries-write': ['uint64'],
           '*boundaries-flush': ['uint64'] } }
