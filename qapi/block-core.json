# -*- Mode: Python -*-
#
# QAPI block core definitions (vm unrelated)

# QAPI common definitions
{ 'include': 'common.json' }

##
# @SnapshotInfo
#
# @id: unique snapshot id
#
# @name: user chosen name
#
# @vm-state-size: size of the VM state
#
# @date-sec: UTC date of the snapshot in seconds
#
# @date-nsec: fractional part in nano seconds to be used with date-sec
#
# @vm-clock-sec: VM clock relative to boot in seconds
#
# @vm-clock-nsec: fractional part in nano seconds to be used with vm-clock-sec
#
# Since: 1.3
#
##

{ 'type': 'SnapshotInfo',
  'data': { 'id': 'str', 'name': 'str', 'vm-state-size': 'int',
            'date-sec': 'int', 'date-nsec': 'int',
            'vm-clock-sec': 'int', 'vm-clock-nsec': 'int' } }

##
# @ImageInfoSpecificQCow2:
#
# @compat: compatibility level
#
# @lazy-refcounts: #optional on or off; only valid for compat >= 1.1
#
# Since: 1.7
##
{ 'type': 'ImageInfoSpecificQCow2',
  'data': {
      'compat': 'str',
      '*lazy-refcounts': 'bool'
  } }

##
# @ImageInfoSpecificVmdk:
#
# @create-type: The create type of VMDK image
#
# @cid: Content id of image
#
# @parent-cid: Parent VMDK image's cid
#
# @extents: List of extent files
#
# Since: 1.7
##
{ 'type': 'ImageInfoSpecificVmdk',
  'data': {
      'create-type': 'str',
      'cid': 'int',
      'parent-cid': 'int',
      'extents': ['ImageInfo']
  } }

##
# @ImageInfoSpecific:
#
# A discriminated record of image format specific information structures.
#
# Since: 1.7
##

{ 'union': 'ImageInfoSpecific',
  'data': {
      'qcow2': 'ImageInfoSpecificQCow2',
      'vmdk': 'ImageInfoSpecificVmdk'
  } }

##
# @ImageInfo:
#
# Information about a QEMU image file
#
# @filename: name of the image file
#
# @format: format of the image file
#
# @virtual-size: maximum capacity in bytes of the image
#
# @actual-size: #optional actual size on disk in bytes of the image
#
# @dirty-flag: #optional true if image is not cleanly closed
#
# @cluster-size: #optional size of a cluster in bytes
#
# @encrypted: #optional true if the image is encrypted
#
# @compressed: #optional true if the image is compressed (Since 1.7)
#
# @backing-filename: #optional name of the backing file
#
# @full-backing-filename: #optional full path of the backing file
#
# @backing-filename-format: #optional the format of the backing file
#
# @snapshots: #optional list of VM snapshots
#
# @backing-image: #optional info of the backing image (since 1.6)
#
# @format-specific: #optional structure supplying additional format-specific
# information (since 1.7)
#
# Since: 1.3
#
##

{ 'type': 'ImageInfo',
  'data': {'filename': 'str', 'format': 'str', '*dirty-flag': 'bool',
           '*actual-size': 'int', 'virtual-size': 'int',
           '*cluster-size': 'int', '*encrypted': 'bool', '*compressed': 'bool',
           '*backing-filename': 'str', '*full-backing-filename': 'str',
           '*backing-filename-format': 'str', '*snapshots': ['SnapshotInfo'],
           '*backing-image': 'ImageInfo',
           '*format-specific': 'ImageInfoSpecific' } }

##
# @ImageCheck:
#
# Information about a QEMU image file check
#
# @filename: name of the image file checked
#
# @format: format of the image file checked
#
# @check-errors: number of unexpected errors occurred during check
#
# @image-end-offset: #optional offset (in bytes) where the image ends, this
#                    field is present if the driver for the image format
#                    supports it
#
# @corruptions: #optional number of corruptions found during the check if any
#
# @leaks: #optional number of leaks found during the check if any
#
# @corruptions-fixed: #optional number of corruptions fixed during the check
#                     if any
#
# @leaks-fixed: #optional number of leaks fixed during the check if any
#
# @total-clusters: #optional total number of clusters, this field is present
#                  if the driver for the image format supports it
#
# @allocated-clusters: #optional total number of allocated clusters, this
#                      field is present if the driver for the image format
#                      supports it
#
# @fragmented-clusters: #optional total number of fragmented clusters, this
#                       field is present if the driver for the image format
#                       supports it
#
# @compressed-clusters: #optional total number of compressed clusters, this
#                       field is present if the driver for the image format
#                       supports it
#
# Since: 1.4
#
##

{ 'type': 'ImageCheck',
  'data': {'filename': 'str', 'format': 'str', 'check-errors': 'int',
           '*image-end-offset': 'int', '*corruptions': 'int', '*leaks': 'int',
           '*corruptions-fixed': 'int', '*leaks-fixed': 'int',
           '*total-clusters': 'int', '*allocated-clusters': 'int',
           '*fragmented-clusters': 'int', '*compressed-clusters': 'int' } }

##
# @BlockDeviceInfo:
#
# Information about the backing device for a block device.
#
# @file: the filename of the backing device
#
# @node-name: #optional the name of the block driver node (Since 2.0)
#
# @ro: true if the backing device was open read-only
#
# @drv: the name of the block format used to open the backing device. As of
#       0.14.0 this can be: 'blkdebug', 'bochs', 'cloop', 'cow', 'dmg',
#       'file', 'file', 'ftp', 'ftps', 'host_cdrom', 'host_device',
#       'host_floppy', 'http', 'https', 'nbd', 'parallels', 'qcow',
#       'qcow2', 'raw', 'tftp', 'vdi', 'vmdk', 'vpc', 'vvfat'
#
# @backing_file: #optional the name of the backing file (for copy-on-write)
#
# @backing_file_depth: number of files in the backing file chain (since: 1.2)
#
# @encrypted: true if the backing device is encrypted
#
# @encryption_key_missing: true if the backing device is encrypted but an
#                          valid encryption key is missing
#
# @detect_zeroes: detect and optimize zero writes (Since 2.1)
#
# @bps: total throughput limit in bytes per second is specified
#
# @bps_rd: read throughput limit in bytes per second is specified
#
# @bps_wr: write throughput limit in bytes per second is specified
#
# @iops: total I/O operations per second is specified
#
# @iops_rd: read I/O operations per second is specified
#
# @iops_wr: write I/O operations per second is specified
#
# @image: the info of image used (since: 1.6)
#
# @bps_max: #optional total max in bytes (Since 1.7)
#
# @bps_rd_max: #optional read max in bytes (Since 1.7)
#
# @bps_wr_max: #optional write max in bytes (Since 1.7)
#
# @iops_max: #optional total I/O operations max (Since 1.7)
#
# @iops_rd_max: #optional read I/O operations max (Since 1.7)
#
# @iops_wr_max: #optional write I/O operations max (Since 1.7)
#
# @iops_size: #optional an I/O size in bytes (Since 1.7)
#
# Since: 0.14.0
#
##
{ 'type': 'BlockDeviceInfo',
  'data': { 'file': 'str', '*node-name': 'str', 'ro': 'bool', 'drv': 'str',
            '*backing_file': 'str', 'backing_file_depth': 'int',
            'encrypted': 'bool', 'encryption_key_missing': 'bool',
            'detect_zeroes': 'BlockdevDetectZeroesOptions',
            'bps': 'int', 'bps_rd': 'int', 'bps_wr': 'int',
            'iops': 'int', 'iops_rd': 'int', 'iops_wr': 'int',
            'image': 'ImageInfo',
            '*bps_max': 'int', '*bps_rd_max': 'int',
            '*bps_wr_max': 'int', '*iops_max': 'int',
            '*iops_rd_max': 'int', '*iops_wr_max': 'int',
            '*iops_size': 'int' } }

##
# @BlockDeviceIoStatus:
#
# An enumeration of block device I/O status.
#
# @ok: The last I/O operation has succeeded
#
# @failed: The last I/O operation has failed
#
# @nospace: The last I/O operation has failed due to a no-space condition
#
# Since: 1.0
##
{ 'enum': 'BlockDeviceIoStatus', 'data': [ 'ok', 'failed', 'nospace' ] }

##
# @BlockDeviceMapEntry:
#
# Entry in the metadata map of the device (returned by "qemu-img map")
#
# @start: Offset in the image of the first byte described by this entry
#         (in bytes)
#
# @length: Length of the range described by this entry (in bytes)
#
# @depth: Number of layers (0 = top image, 1 = top image's backing file, etc.)
#         before reaching one for which the range is allocated.  The value is
#         in the range 0 to the depth of the image chain - 1.
#
# @zero: the sectors in this range read as zeros
#
# @data: reading the image will actually read data from a file (in particular,
#        if @offset is present this means that the sectors are not simply
#        preallocated, but contain actual data in raw format)
#
# @offset: if present, the image file stores the data for this range in
#          raw format at the given offset.
#
# Since 1.7
##
{ 'type': 'BlockDeviceMapEntry',
  'data': { 'start': 'int', 'length': 'int', 'depth': 'int', 'zero': 'bool',
            'data': 'bool', '*offset': 'int' } }

##
# @BlockDirtyInfo:
#
# Block dirty bitmap information.
#
# @count: number of dirty bytes according to the dirty bitmap
#
# @granularity: granularity of the dirty bitmap in bytes (since 1.4)
#
# Since: 1.3
##
{ 'type': 'BlockDirtyInfo',
  'data': {'count': 'int', 'granularity': 'int'} }

##
# @BlockInfo:
#
# Block device information.  This structure describes a virtual device and
# the backing device associated with it.
#
# @device: The device name associated with the virtual device.
#
# @type: This field is returned only for compatibility reasons, it should
#        not be used (always returns 'unknown')
#
# @removable: True if the device supports removable media.
#
# @locked: True if the guest has locked this device from having its media
#          removed
#
# @tray_open: #optional True if the device has a tray and it is open
#             (only present if removable is true)
#
# @dirty-bitmaps: #optional dirty bitmaps information (only present if the
#                 driver has one or more dirty bitmaps) (Since 2.0)
#
# @io-status: #optional @BlockDeviceIoStatus. Only present if the device
#             supports it and the VM is configured to stop on errors
#
# @inserted: #optional @BlockDeviceInfo describing the device if media is
#            present
#
# Since:  0.14.0
##
{ 'type': 'BlockInfo',
  'data': {'device': 'str', 'type': 'str', 'removable': 'bool',
           'locked': 'bool', '*inserted': 'BlockDeviceInfo',
           '*tray_open': 'bool', '*io-status': 'BlockDeviceIoStatus',
           '*dirty-bitmaps': ['BlockDirtyInfo'] } }

##
# @query-block:
#
# Get a list of BlockInfo for all virtual block devices.
#
# Returns: a list of @BlockInfo describing each virtual block device
#
# Since: 0.14.0
##
{ 'command': 'query-block', 'returns': ['BlockInfo'] }

##
# @BlockDeviceStats:
#
# Statistics of a virtual block device or a block backing device.
#
# @rd_bytes:      The number of bytes read by the device.
#
# @wr_bytes:      The number of bytes written by the device.
#
# @rd_operations: The number of read operations performed by the device.
#
# @wr_operations: The number of write operations performed by the device.
#
# @flush_operations: The number of cache flush operations performed by the
#                    device (since 0.15.0)
#
# @flush_total_time_ns: Total time spend on cache flushes in nano-seconds
#                       (since 0.15.0).
#
# @wr_total_time_ns: Total time spend on writes in nano-seconds (since 0.15.0).
#
# @rd_total_time_ns: Total_time_spend on reads in nano-seconds (since 0.15.0).
#
# @wr_highest_offset: The offset after the greatest byte written to the
#                     device.  The intended use of this information is for
#                     growable sparse files (like qcow2) that are used on top
#                     of a physical device.
#
# Since: 0.14.0
##
{ 'type': 'BlockDeviceStats',
  'data': {'rd_bytes': 'int', 'wr_bytes': 'int', 'rd_operations': 'int',
           'wr_operations': 'int', 'flush_operations': 'int',
           'flush_total_time_ns': 'int', 'wr_total_time_ns': 'int',
           'rd_total_time_ns': 'int', 'wr_highest_offset': 'int' } }

##
# @BlockStats:
#
# Statistics of a virtual block device or a block backing device.
#
# @device: #optional If the stats are for a virtual block device, the name
#          corresponding to the virtual block device.
#
# @stats:  A @BlockDeviceStats for the device.
#
# @parent: #optional This describes the file block device if it has one.
#
# @backing: #optional This describes the backing block device if it has one.
#           (Since 2.0)
#
# Since: 0.14.0
##
{ 'type': 'BlockStats',
  'data': {'*device': 'str', 'stats': 'BlockDeviceStats',
           '*parent': 'BlockStats',
           '*backing': 'BlockStats'} }

##
# @query-blockstats:
#
# Query the @BlockStats for all virtual block devices.
#
# Returns: A list of @BlockStats for each virtual block devices.
#
# Since: 0.14.0
##
{ 'command': 'query-blockstats', 'returns': ['BlockStats'] }

##
# @BlockdevOnError:
#
# An enumeration of possible behaviors for errors on I/O operations.
# The exact meaning depends on whether the I/O was initiated by a guest
# or by a block job
#
# @report: for guest operations, report the error to the guest;
#          for jobs, cancel the job
#
# @ignore: ignore the error, only report a QMP event (BLOCK_IO_ERROR
#          or BLOCK_JOB_ERROR)
#
# @enospc: same as @stop on ENOSPC, same as @report otherwise.
#
# @stop: for guest operations, stop the virtual machine;
#        for jobs, pause the job
#
# Since: 1.3
##
{ 'enum': 'BlockdevOnError',
  'data': ['report', 'ignore', 'enospc', 'stop'] }

##
# @MirrorSyncMode:
#
# An enumeration of possible behaviors for the initial synchronization
# phase of storage mirroring.
#
# @top: copies data in the topmost image to the destination
#
# @full: copies data from all images to the destination
#
# @none: only copy data written from now on
#
# Since: 1.3
##
{ 'enum': 'MirrorSyncMode',
  'data': ['top', 'full', 'none'] }

##
# @BlockJobType:
#
# Type of a block job.
#
# @commit: block commit job type, see "block-commit"
#
# @stream: block stream job type, see "block-stream"
#
# @mirror: drive mirror job type, see "drive-mirror"
#
# @backup: drive backup job type, see "drive-backup"
#
# Since: 1.7
##
{ 'enum': 'BlockJobType',
  'data': ['commit', 'stream', 'mirror', 'backup'] }

##
# @BlockJobInfo:
#
# Information about a long-running block device operation.
#
# @type: the job type ('stream' for image streaming)
#
# @device: the block device name
#
# @len: the maximum progress value
#
# @busy: false if the job is known to be in a quiescent state, with
#        no pending I/O.  Since 1.3.
#
# @paused: whether the job is paused or, if @busy is true, will
#          pause itself as soon as possible.  Since 1.3.
#
# @offset: the current progress value
#
# @speed: the rate limit, bytes per second
#
# @io-status: the status of the job (since 1.3)
#
# Since: 1.1
##
{ 'type': 'BlockJobInfo',
  'data': {'type': 'str', 'device': 'str', 'len': 'int',
           'offset': 'int', 'busy': 'bool', 'paused': 'bool', 'speed': 'int',
           'io-status': 'BlockDeviceIoStatus'} }

##
# @query-block-jobs:
#
# Return information about long-running block device operations.
#
# Returns: a list of @BlockJobInfo for each active block job
#
# Since: 1.1
##
{ 'command': 'query-block-jobs', 'returns': ['BlockJobInfo'] }

##
# @block_passwd:
#
# This command sets the password of a block device that has not been open
# with a password and requires one.
#
# The two cases where this can happen are a block device is created through
# QEMU's initial command line or a block device is changed through the legacy
# @change interface.
#
# In the event that the block device is created through the initial command
# line, the VM will start in the stopped state regardless of whether '-S' is
# used.  The intention is for a management tool to query the block devices to
# determine which ones are encrypted, set the passwords with this command, and
# then start the guest with the @cont command.
#
# Either @device or @node-name must be set but not both.
#
# @device: #optional the name of the block backend device to set the password on
#
# @node-name: #optional graph node name to set the password on (Since 2.0)
#
# @password: the password to use for the device
#
# Returns: nothing on success
#          If @device is not a valid block device, DeviceNotFound
#          If @device is not encrypted, DeviceNotEncrypted
#
# Notes:  Not all block formats support encryption and some that do are not
#         able to validate that a password is correct.  Disk corruption may
#         occur if an invalid password is specified.
#
# Since: 0.14.0
##
{ 'command': 'block_passwd', 'data': {'*device': 'str',
                                      '*node-name': 'str', 'password': 'str'} }

##
# @block_resize
#
# Resize a block image while a guest is running.
#
# Either @device or @node-name must be set but not both.
#
# @device: #optional the name of the device to get the image resized
#
# @node-name: #optional graph node name to get the image resized (Since 2.0)
#
# @size:  new image size in bytes
#
# Returns: nothing on success
#          If @device is not a valid block device, DeviceNotFound
#
# Since: 0.14.0
##
{ 'command': 'block_resize', 'data': { '*device': 'str',
                                       '*node-name': 'str',
                                       'size': 'int' }}

##
# @NewImageMode
#
# An enumeration that tells QEMU how to set the backing file path in
# a new image file.
#
# @existing: QEMU should look for an existing image file.
#
# @absolute-paths: QEMU should create a new image with absolute paths
# for the backing file. If there is no backing file available, the new
# image will not be backed either.
#
# Since: 1.1
##
{ 'enum': 'NewImageMode',
  'data': [ 'existing', 'absolute-paths' ] }

##
# @BlockdevSnapshot
#
# Either @device or @node-name must be set but not both.
#
# @device: #optional the name of the device to generate the snapshot from.
#
# @node-name: #optional graph node name to generate the snapshot from (Since 2.0)
#
# @snapshot-file: the target of the new image. A new file will be created.
#
# @snapshot-node-name: #optional the graph node name of the new image (Since 2.0)
#
# @format: #optional the format of the snapshot image, default is 'qcow2'.
#
# @mode: #optional whether and how QEMU should create a new image, default is
#        'absolute-paths'.
##
{ 'type': 'BlockdevSnapshot',
  'data': { '*device': 'str', '*node-name': 'str',
            'snapshot-file': 'str', '*snapshot-node-name': 'str',
            '*format': 'str', '*mode': 'NewImageMode' } }

##
# @DriveBackup
#
# @device: the name of the device which should be copied.
#
# @target: the target of the new image. If the file exists, or if it
#          is a device, the existing file/device will be used as the new
#          destination.  If it does not exist, a new file will be created.
#
# @format: #optional the format of the new destination, default is to
#          probe if @mode is 'existing', else the format of the source
#
# @sync: what parts of the disk image should be copied to the destination
#        (all the disk, only the sectors allocated in the topmost image, or
#        only new I/O).
#
# @mode: #optional whether and how QEMU should create a new image, default is
#        'absolute-paths'.
#
# @speed: #optional the maximum speed, in bytes per second
#
# @on-source-error: #optional the action to take on an error on the source,
#                   default 'report'.  'stop' and 'enospc' can only be used
#                   if the block device supports io-status (see BlockInfo).
#
# @on-target-error: #optional the action to take on an error on the target,
#                   default 'report' (no limitations, since this applies to
#                   a different block device than @device).
#
# Note that @on-source-error and @on-target-error only affect background I/O.
# If an error occurs during a guest write request, the device's rerror/werror
# actions will be used.
#
# Since: 1.6
##
{ 'type': 'DriveBackup',
  'data': { 'device': 'str', 'target': 'str', '*format': 'str',
            'sync': 'MirrorSyncMode', '*mode': 'NewImageMode',
            '*speed': 'int',
            '*on-source-error': 'BlockdevOnError',
            '*on-target-error': 'BlockdevOnError' } }

##
# @blockdev-snapshot-sync
#
# Generates a synchronous snapshot of a block device.
#
# For the arguments, see the documentation of BlockdevSnapshot.
#
# Returns: nothing on success
#          If @device is not a valid block device, DeviceNotFound
#
# Since 0.14.0
##
{ 'command': 'blockdev-snapshot-sync',
  'data': 'BlockdevSnapshot' }

##
# @change-backing-file
#
# Change the backing file in the image file metadata.  This does not
# cause QEMU to reopen the image file to reparse the backing filename
# (it may, however, perform a reopen to change permissions from
# r/o -> r/w -> r/o, if needed). The new backing file string is written
# into the image file metadata, and the QEMU internal strings are
# updated.
#
# @image-node-name: The name of the block driver state node of the
#                   image to modify.
#
# @device:          The name of the device that owns image-node-name.
#
# @backing-file:    The string to write as the backing file.  This
#                   string is not validated, so care should be taken
#                   when specifying the string or the image chain may
#                   not be able to be reopened again.
#
# Since: 2.1
##
{ 'command': 'change-backing-file',
  'data': { 'device': 'str', 'image-node-name': 'str',
            'backing-file': 'str' } }

##
# @block-commit
#
# Live commit of data from overlay image nodes into backing nodes - i.e.,
# writes data between 'top' and 'base' into 'base'.
#
# @device:  the name of the device
#
# @base:   #optional The file name of the backing image to write data into.
#                    If not specified, this is the deepest backing image
#
# @top:    #optional The file name of the backing image within the image chain,
#                    which contains the topmost data to be committed down. If
#                    not specified, this is the active layer.
#
# @backing-file:  #optional The backing file string to write into the overlay
#                           image of 'top'.  If 'top' is the active layer,
#                           specifying a backing file string is an error. This
#                           filename is not validated.
#
#                           If a pathname string is such that it cannot be
#                           resolved by QEMU, that means that subsequent QMP or
#                           HMP commands must use node-names for the image in
#                           question, as filename lookup methods will fail.
#
#                           If not specified, QEMU will automatically determine
#                           the backing file string to use, or error out if
#                           there is no obvious choice. Care should be taken
#                           when specifying the string, to specify a valid
#                           filename or protocol.
#                           (Since 2.1)
#
#                    If top == base, that is an error.
#                    If top == active, the job will not be completed by itself,
#                    user needs to complete the job with the block-job-complete
#                    command after getting the ready event. (Since 2.0)
#
#                    If the base image is smaller than top, then the base image
#                    will be resized to be the same size as top.  If top is
#                    smaller than the base image, the base will not be
#                    truncated.  If you want the base image size to match the
#                    size of the smaller top, you can safely truncate it
#                    yourself once the commit operation successfully completes.
#
# @speed:  #optional the maximum speed, in bytes per second
#
# Returns: Nothing on success
#          If commit or stream is already active on this device, DeviceInUse
#          If @device does not exist, DeviceNotFound
#          If image commit is not supported by this device, NotSupported
#          If @base or @top is invalid, a generic error is returned
#          If @speed is invalid, InvalidParameter
#
# Since: 1.3
#
##
{ 'command': 'block-commit',
  'data': { 'device': 'str', '*base': 'str', '*top': 'str',
            '*backing-file': 'str', '*speed': 'int' } }

##
# @drive-backup
#
# Start a point-in-time copy of a block device to a new destination.  The
# status of ongoing drive-backup operations can be checked with
# query-block-jobs where the BlockJobInfo.type field has the value 'backup'.
# The operation can be stopped before it has completed using the
# block-job-cancel command.
#
# For the arguments, see the documentation of DriveBackup.
#
# Returns: nothing on success
#          If @device is not a valid block device, DeviceNotFound
#
# Since 1.6
##
{ 'command': 'drive-backup', 'data': 'DriveBackup' }

##
# @query-named-block-nodes
#
# Get the named block driver list
#
# Returns: the list of BlockDeviceInfo
#
# Since 2.0
##
{ 'command': 'query-named-block-nodes', 'returns': [ 'BlockDeviceInfo' ] }

##
# @drive-mirror
#
# Start mirroring a block device's writes to a new destination.
#
# @device:  the name of the device whose writes should be mirrored.
#
# @target: the target of the new image. If the file exists, or if it
#          is a device, the existing file/device will be used as the new
#          destination.  If it does not exist, a new file will be created.
#
# @format: #optional the format of the new destination, default is to
#          probe if @mode is 'existing', else the format of the source
#
# @node-name: #optional the new block driver state node name in the graph
#             (Since 2.1)
#
# @replaces: #optional with sync=full graph node name to be replaced by the new
#            image when a whole image copy is done. This can be used to repair
#            broken Quorum files. (Since 2.1)
#
# @mode: #optional whether and how QEMU should create a new image, default is
#        'absolute-paths'.
#
# @speed:  #optional the maximum speed, in bytes per second
#
# @sync: what parts of the disk image should be copied to the destination
#        (all the disk, only the sectors allocated in the topmost image, or
#        only new I/O).
#
# @granularity: #optional granularity of the dirty bitmap, default is 64K
#               if the image format doesn't have clusters, 4K if the clusters
#               are smaller than that, else the cluster size.  Must be a
#               power of 2 between 512 and 64M (since 1.4).
#
# @buf-size: #optional maximum amount of data in flight from source to
#            target (since 1.4).
#
# @on-source-error: #optional the action to take on an error on the source,
#                   default 'report'.  'stop' and 'enospc' can only be used
#                   if the block device supports io-status (see BlockInfo).
#
# @on-target-error: #optional the action to take on an error on the target,
#                   default 'report' (no limitations, since this applies to
#                   a different block device than @device).
#
# Returns: nothing on success
#          If @device is not a valid block device, DeviceNotFound
#
# Since 1.3
##
{ 'command': 'drive-mirror',
  'data': { 'device': 'str', 'target': 'str', '*format': 'str',
            '*node-name': 'str', '*replaces': 'str',
            'sync': 'MirrorSyncMode', '*mode': 'NewImageMode',
            '*speed': 'int', '*granularity': 'uint32',
            '*buf-size': 'int', '*on-source-error': 'BlockdevOnError',
            '*on-target-error': 'BlockdevOnError' } }

##
# @block_set_io_throttle:
#
# Change I/O throttle limits for a block drive.
#
# @device: The name of the device
#
# @bps: total throughput limit in bytes per second
#
# @bps_rd: read throughput limit in bytes per second
#
# @bps_wr: write throughput limit in bytes per second
#
# @iops: total I/O operations per second
#
# @ops_rd: read I/O operations per second
#
# @iops_wr: write I/O operations per second
#
# @bps_max: #optional total max in bytes (Since 1.7)
#
# @bps_rd_max: #optional read max in bytes (Since 1.7)
#
# @bps_wr_max: #optional write max in bytes (Since 1.7)
#
# @iops_max: #optional total I/O operations max (Since 1.7)
#
# @iops_rd_max: #optional read I/O operations max (Since 1.7)
#
# @iops_wr_max: #optional write I/O operations max (Since 1.7)
#
# @iops_size: #optional an I/O size in bytes (Since 1.7)
#
# Returns: Nothing on success
#          If @device is not a valid block device, DeviceNotFound
#
# Since: 1.1
##
{ 'command': 'block_set_io_throttle',
  'data': { 'device': 'str', 'bps': 'int', 'bps_rd': 'int', 'bps_wr': 'int',
            'iops': 'int', 'iops_rd': 'int', 'iops_wr': 'int',
            '*bps_max': 'int', '*bps_rd_max': 'int',
            '*bps_wr_max': 'int', '*iops_max': 'int',
            '*iops_rd_max': 'int', '*iops_wr_max': 'int',
            '*iops_size': 'int' } }

##
# @block-stream:
#
# Copy data from a backing file into a block device.
#
# The block streaming operation is performed in the background until the entire
# backing file has been copied.  This command returns immediately once streaming
# has started.  The status of ongoing block streaming operations can be checked
# with query-block-jobs.  The operation can be stopped before it has completed
# using the block-job-cancel command.
#
# If a base file is specified then sectors are not copied from that base file and
# its backing chain.  When streaming completes the image file will have the base
# file as its backing file.  This can be used to stream a subset of the backing
# file chain instead of flattening the entire image.
#
# On successful completion the image file is updated to drop the backing file
# and the BLOCK_JOB_COMPLETED event is emitted.
#
# @device: the device name
#
# @base:   #optional the common backing file name
#
# @speed:  #optional the maximum speed, in bytes per second
#
# @on-error: #optional the action to take on an error (default report).
#            'stop' and 'enospc' can only be used if the block device
#            supports io-status (see BlockInfo).  Since 1.3.
#
# Returns: Nothing on success
#          If @device does not exist, DeviceNotFound
#
# Since: 1.1
##
{ 'command': 'block-stream',
  'data': { 'device': 'str', '*base': 'str', '*speed': 'int',
            '*on-error': 'BlockdevOnError' } }

##
# @block-job-set-speed:
#
# Set maximum speed for a background block operation.
#
# This command can only be issued when there is an active block job.
#
# Throttling can be disabled by setting the speed to 0.
#
# @device: the device name
#
# @speed:  the maximum speed, in bytes per second, or 0 for unlimited.
#          Defaults to 0.
#
# Returns: Nothing on success
#          If no background operation is active on this device, DeviceNotActive
#
# Since: 1.1
##
{ 'command': 'block-job-set-speed',
  'data': { 'device': 'str', 'speed': 'int' } }

##
# @block-job-cancel:
#
# Stop an active background block operation.
#
# This command returns immediately after marking the active background block
# operation for cancellation.  It is an error to call this command if no
# operation is in progress.
#
# The operation will cancel as soon as possible and then emit the
# BLOCK_JOB_CANCELLED event.  Before that happens the job is still visible when
# enumerated using query-block-jobs.
#
# For streaming, the image file retains its backing file unless the streaming
# operation happens to complete just as it is being cancelled.  A new streaming
# operation can be started at a later time to finish copying all data from the
# backing file.
#
# @device: the device name
#
# @force: #optional whether to allow cancellation of a paused job (default
#         false).  Since 1.3.
#
# Returns: Nothing on success
#          If no background operation is active on this device, DeviceNotActive
#
# Since: 1.1
##
{ 'command': 'block-job-cancel', 'data': { 'device': 'str', '*force': 'bool' } }

##
# @block-job-pause:
#
# Pause an active background block operation.
#
# This command returns immediately after marking the active background block
# operation for pausing.  It is an error to call this command if no
# operation is in progress.  Pausing an already paused job has no cumulative
# effect; a single block-job-resume command will resume the job.
#
# The operation will pause as soon as possible.  No event is emitted when
# the operation is actually paused.  Cancelling a paused job automatically
# resumes it.
#
# @device: the device name
#
# Returns: Nothing on success
#          If no background operation is active on this device, DeviceNotActive
#
# Since: 1.3
##
{ 'command': 'block-job-pause', 'data': { 'device': 'str' } }

##
# @block-job-resume:
#
# Resume an active background block operation.
#
# This command returns immediately after resuming a paused background block
# operation.  It is an error to call this command if no operation is in
# progress.  Resuming an already running job is not an error.
#
# This command also clears the error status of the job.
#
# @device: the device name
#
# Returns: Nothing on success
#          If no background operation is active on this device, DeviceNotActive
#
# Since: 1.3
##
{ 'command': 'block-job-resume', 'data': { 'device': 'str' } }

##
# @block-job-complete:
#
# Manually trigger completion of an active background block operation.  This
# is supported for drive mirroring, where it also switches the device to
# write to the target path only.  The ability to complete is signaled with
# a BLOCK_JOB_READY event.
#
# This command completes an active background block operation synchronously.
# The ordering of this command's return with the BLOCK_JOB_COMPLETED event
# is not defined.  Note that if an I/O error occurs during the processing of
# this command: 1) the command itself will fail; 2) the error will be processed
# according to the rerror/werror arguments that were specified when starting
# the operation.
#
# A cancelled or paused job cannot be completed.
#
# @device: the device name
#
# Returns: Nothing on success
#          If no background operation is active on this device, DeviceNotActive
#
# Since: 1.3
##
{ 'command': 'block-job-complete', 'data': { 'device': 'str' } }

##
# @BlockdevDiscardOptions
#
# Determines how to handle discard requests.
#
# @ignore:      Ignore the request
# @unmap:       Forward as an unmap request
#
# Since: 1.7
##
{ 'enum': 'BlockdevDiscardOptions',
  'data': [ 'ignore', 'unmap' ] }

##
# @BlockdevDetectZeroesOptions
#
# Describes the operation mode for the automatic conversion of plain
# zero writes by the OS to driver specific optimized zero write commands.
#
# @off:      Disabled (default)
# @on:       Enabled
# @unmap:    Enabled and even try to unmap blocks if possible. This requires
#            also that @BlockdevDiscardOptions is set to unmap for this device.
#
# Since: 2.1
##
{ 'enum': 'BlockdevDetectZeroesOptions',
  'data': [ 'off', 'on', 'unmap' ] }

##
# @BlockdevAioOptions
#
# Selects the AIO backend to handle I/O requests
#
# @threads:     Use qemu's thread pool
# @native:      Use native AIO backend (only Linux and Windows)
#
# Since: 1.7
##
{ 'enum': 'BlockdevAioOptions',
  'data': [ 'threads', 'native' ] }

##
# @BlockdevCacheOptions
#
# Includes cache-related options for block devices
#
# @writeback:   #optional enables writeback mode for any caches (default: true)
# @direct:      #optional enables use of O_DIRECT (bypass the host page cache;
#               default: false)
# @no-flush:    #optional ignore any flush requests for the device (default:
#               false)
#
# Since: 1.7
##
{ 'type': 'BlockdevCacheOptions',
  'data': { '*writeback': 'bool',
            '*direct': 'bool',
            '*no-flush': 'bool' } }

##
# @BlockdevDriver
#
# Drivers that are supported in block device operations.
#
# @host_device, @host_cdrom, @host_floppy: Since 2.1
#
# Since: 2.0
##
{ 'enum': 'BlockdevDriver',
  'data': [ 'file', 'host_device', 'host_cdrom', 'host_floppy',
            'http', 'https', 'ftp', 'ftps', 'tftp', 'vvfat', 'blkdebug',
            'blkverify', 'bochs', 'cloop', 'cow', 'dmg', 'parallels', 'qcow',
            'qcow2', 'qed', 'raw', 'vdi', 'vhdx', 'vmdk', 'vpc', 'quorum' ] }

##
# @BlockdevOptionsBase
#
# Options that are available for all block devices, independent of the block
# driver.
#
# @driver:        block driver name
# @id:            #optional id by which the new block device can be referred to.
#                 This is a required option on the top level of blockdev-add, and
#                 currently not allowed on any other level.
# @node-name:     #optional the name of a block driver state node (Since 2.0)
# @discard:       #optional discard-related options (default: ignore)
# @cache:         #optional cache-related options
# @aio:           #optional AIO backend (default: threads)
# @rerror:        #optional how to handle read errors on the device
#                 (default: report)
# @werror:        #optional how to handle write errors on the device
#                 (default: enospc)
# @read-only:     #optional whether the block device should be read-only
#                 (default: false)
# @detect-zeroes: #optional detect and optimize zero writes (Since 2.1)
#                 (default: off)
#
# Since: 1.7
##
{ 'type': 'BlockdevOptionsBase',
  'data': { 'driver': 'BlockdevDriver',
            '*id': 'str',
            '*node-name': 'str',
            '*discard': 'BlockdevDiscardOptions',
            '*cache': 'BlockdevCacheOptions',
            '*aio': 'BlockdevAioOptions',
            '*rerror': 'BlockdevOnError',
            '*werror': 'BlockdevOnError',
            '*read-only': 'bool',
            '*detect-zeroes': 'BlockdevDetectZeroesOptions' } }

##
# @BlockdevOptionsFile
#
# Driver specific block device options for the file backend and similar
# protocols.
#
# @filename:    path to the image file
#
# Since: 1.7
##
{ 'type': 'BlockdevOptionsFile',
  'data': { 'filename': 'str' } }

##
# @BlockdevOptionsVVFAT
#
# Driver specific block device options for the vvfat protocol.
#
# @dir:         directory to be exported as FAT image
# @fat-type:    #optional FAT type: 12, 16 or 32
# @floppy:      #optional whether to export a floppy image (true) or
#               partitioned hard disk (false; default)
# @rw:          #optional whether to allow write operations (default: false)
#
# Since: 1.7
##
{ 'type': 'BlockdevOptionsVVFAT',
  'data': { 'dir': 'str', '*fat-type': 'int', '*floppy': 'bool',
            '*rw': 'bool' } }

##
# @BlockdevOptionsGenericFormat
#
# Driver specific block device options for image format that have no option
# besides their data source.
#
# @file:        reference to or definition of the data source block device
#
# Since: 1.7
##
{ 'type': 'BlockdevOptionsGenericFormat',
  'data': { 'file': 'BlockdevRef' } }

##
# @BlockdevOptionsGenericCOWFormat
#
# Driver specific block device options for image format that have no option
# besides their data source and an optional backing file.
#
# @backing:     #optional reference to or definition of the backing file block
#               device (if missing, taken from the image file content). It is
#               allowed to pass an empty string here in order to disable the
#               default backing file.
#
# Since: 1.7
##
{ 'type': 'BlockdevOptionsGenericCOWFormat',
  'base': 'BlockdevOptionsGenericFormat',
  'data': { '*backing': 'BlockdevRef' } }

##
# @BlockdevOptionsQcow2
#
# Driver specific block device options for qcow2.
#
# @lazy-refcounts:        #optional whether to enable the lazy refcounts
#                         feature (default is taken from the image file)
#
# @pass-discard-request:  #optional whether discard requests to the qcow2
#                         device should be forwarded to the data source
#
# @pass-discard-snapshot: #optional whether discard requests for the data source
#                         should be issued when a snapshot operation (e.g.
#                         deleting a snapshot) frees clusters in the qcow2 file
#
# @pass-discard-other:    #optional whether discard requests for the data source
#                         should be issued on other occasions where a cluster
#                         gets freed
#
# Since: 1.7
##
{ 'type': 'BlockdevOptionsQcow2',
  'base': 'BlockdevOptionsGenericCOWFormat',
  'data': { '*lazy-refcounts': 'bool',
            '*pass-discard-request': 'bool',
            '*pass-discard-snapshot': 'bool',
            '*pass-discard-other': 'bool' } }

##
# @BlkdebugEvent
#
# Trigger events supported by blkdebug.
##
{ 'enum': 'BlkdebugEvent',
  'data': [ 'l1_update', 'l1_grow.alloc_table', 'l1_grow.write_table',
            'l1_grow.activate_table', 'l2_load', 'l2_update',
            'l2_update_compressed', 'l2_alloc.cow_read', 'l2_alloc.write',
            'read_aio', 'read_backing_aio', 'read_compressed', 'write_aio',
            'write_compressed', 'vmstate_load', 'vmstate_save', 'cow_read',
            'cow_write', 'reftable_load', 'reftable_grow', 'reftable_update',
            'refblock_load', 'refblock_update', 'refblock_update_part',
            'refblock_alloc', 'refblock_alloc.hookup', 'refblock_alloc.write',
            'refblock_alloc.write_blocks', 'refblock_alloc.write_table',
            'refblock_alloc.switch_table', 'cluster_alloc',
            'cluster_alloc_bytes', 'cluster_free', 'flush_to_os',
            'flush_to_disk' ] }

##
# @BlkdebugInjectErrorOptions
#
# Describes a single error injection for blkdebug.
#
# @event:       trigger event
#
# @state:       #optional the state identifier blkdebug needs to be in to
#               actually trigger the event; defaults to "any"
#
# @errno:       #optional error identifier (errno) to be returned; defaults to
#               EIO
#
# @sector:      #optional specifies the sector index which has to be affected
#               in order to actually trigger the event; defaults to "any
#               sector"
#
# @once:        #optional disables further events after this one has been
#               triggered; defaults to false
#
# @immediately: #optional fail immediately; defaults to false
#
# Since: 2.0
##
{ 'type': 'BlkdebugInjectErrorOptions',
  'data': { 'event': 'BlkdebugEvent',
            '*state': 'int',
            '*errno': 'int',
            '*sector': 'int',
            '*once': 'bool',
            '*immediately': 'bool' } }

##
# @BlkdebugSetStateOptions
#
# Describes a single state-change event for blkdebug.
#
# @event:       trigger event
#
# @state:       #optional the current state identifier blkdebug needs to be in;
#               defaults to "any"
#
# @new_state:   the state identifier blkdebug is supposed to assume if
#               this event is triggered
#
# Since: 2.0
##
{ 'type': 'BlkdebugSetStateOptions',
  'data': { 'event': 'BlkdebugEvent',
            '*state': 'int',
            'new_state': 'int' } }

##
# @BlockdevOptionsBlkdebug
#
# Driver specific block device options for blkdebug.
#
# @image:           underlying raw block device (or image file)
#
# @config:          #optional filename of the configuration file
#
# @align:           #optional required alignment for requests in bytes
#
# @inject-error:    #optional array of error injection descriptions
#
# @set-state:       #optional array of state-change descriptions
#
# Since: 2.0
##
{ 'type': 'BlockdevOptionsBlkdebug',
  'data': { 'image': 'BlockdevRef',
            '*config': 'str',
            '*align': 'int',
            '*inject-error': ['BlkdebugInjectErrorOptions'],
            '*set-state': ['BlkdebugSetStateOptions'] } }

##
# @BlockdevOptionsBlkverify
#
# Driver specific block device options for blkverify.
#
# @test:    block device to be tested
#
# @raw:     raw image used for verification
#
# Since: 2.0
##
{ 'type': 'BlockdevOptionsBlkverify',
  'data': { 'test': 'BlockdevRef',
            'raw': 'BlockdevRef' } }

##
# @BlockdevOptionsQuorum
#
# Driver specific block device options for Quorum
#
# @blkverify:      #optional true if the driver must print content mismatch
#                  set to false by default
#
# @children:       the children block devices to use
#
# @vote-threshold: the vote limit under which a read will fail
#
# @rewrite-corrupted: #optional rewrite corrupted data when quorum is reached
#                     (Since 2.1)
#
# Since: 2.0
##
{ 'type': 'BlockdevOptionsQuorum',
  'data': { '*blkverify': 'bool',
            'children': [ 'BlockdevRef' ],
            'vote-threshold': 'int', '*rewrite-corrupted': 'bool' } }

##
# @BlockdevOptions
#
# Options for creating a block device.
#
# Since: 1.7
##
{ 'union': 'BlockdevOptions',
  'base': 'BlockdevOptionsBase',
  'discriminator': 'driver',
  'data': {
      'file':       'BlockdevOptionsFile',
      'host_device':'BlockdevOptionsFile',
      'host_cdrom': 'BlockdevOptionsFile',
      'host_floppy':'BlockdevOptionsFile',
      'http':       'BlockdevOptionsFile',
      'https':      'BlockdevOptionsFile',
      'ftp':        'BlockdevOptionsFile',
      'ftps':       'BlockdevOptionsFile',
      'tftp':       'BlockdevOptionsFile',
# TODO gluster: Wait for structured options
# TODO iscsi: Wait for structured options
# TODO nbd: Should take InetSocketAddress for 'host'?
# TODO nfs: Wait for structured options
# TODO rbd: Wait for structured options
# TODO sheepdog: Wait for structured options
# TODO ssh: Should take InetSocketAddress for 'host'?
      'vvfat':      'BlockdevOptionsVVFAT',
      'blkdebug':   'BlockdevOptionsBlkdebug',
      'blkverify':  'BlockdevOptionsBlkverify',
      'bochs':      'BlockdevOptionsGenericFormat',
      'cloop':      'BlockdevOptionsGenericFormat',
      'cow':        'BlockdevOptionsGenericCOWFormat',
      'dmg':        'BlockdevOptionsGenericFormat',
      'parallels':  'BlockdevOptionsGenericFormat',
      'qcow':       'BlockdevOptionsGenericCOWFormat',
      'qcow2':      'BlockdevOptionsQcow2',
      'qed':        'BlockdevOptionsGenericCOWFormat',
      'raw':        'BlockdevOptionsGenericFormat',
      'vdi':        'BlockdevOptionsGenericFormat',
      'vhdx':       'BlockdevOptionsGenericFormat',
      'vmdk':       'BlockdevOptionsGenericCOWFormat',
      'vpc':        'BlockdevOptionsGenericFormat',
      'quorum':     'BlockdevOptionsQuorum'
  } }

##
# @BlockdevRef
#
# Reference to a block device.
#
# @definition:      defines a new block device inline
# @reference:       references the ID of an existing block device. An
#                   empty string means that no block device should be
#                   referenced.
#
# Since: 1.7
##
{ 'union': 'BlockdevRef',
  'discriminator': {},
  'data': { 'definition': 'BlockdevOptions',
            'reference': 'str' } }

##
# @blockdev-add:
#
# Creates a new block device.
#
# @options: block device options for the new device
#
# Since: 1.7
##
{ 'command': 'blockdev-add', 'data': { 'options': 'BlockdevOptions' } }


##
# @BlockErrorAction
#
# An enumeration of action that has been taken when a DISK I/O occurs
#
# @ignore: error has been ignored
#
# @report: error has been reported to the device
#
# @stop: error caused VM to be stopped
#
# Since: 2.1
##
{ 'enum': 'BlockErrorAction',
  'data': [ 'ignore', 'report', 'stop' ] }


##
# @BLOCK_IMAGE_CORRUPTED
#
# Emitted when a disk image is being marked corrupt
#
# @device: device name
#
# @msg: informative message for human consumption, such as the kind of
#       corruption being detected. It should not be parsed by machine as it is
#       not guaranteed to be stable
#
# @offset: #optional, if the corruption resulted from an image access, this is
#          the access offset into the image
#
# @size: #optional, if the corruption resulted from an image access, this is
#        the access size
#
# Since: 1.7
##
{ 'event': 'BLOCK_IMAGE_CORRUPTED',
  'data': { 'device' : 'str',
            'msg'    : 'str',
            '*offset': 'int',
            '*size'  : 'int' } }

##
# @BLOCK_IO_ERROR
#
# Emitted when a disk I/O error occurs
#
# @device: device name
#
# @operation: I/O operation
#
# @action: action that has been taken
#
# Note: If action is "stop", a STOP event will eventually follow the
# BLOCK_IO_ERROR event
#
# Since: 0.13.0
##
{ 'event': 'BLOCK_IO_ERROR',
  'data': { 'device': 'str', 'operation': 'IoOperationType',
            'action': 'BlockErrorAction' } }

##
# @BLOCK_JOB_COMPLETED
#
# Emitted when a block job has completed
#
# @type: job type
#
# @device: device name
#
# @len: maximum progress value
#
# @offset: current progress value. On success this is equal to len.
#          On failure this is less than len
#
# @speed: rate limit, bytes per second
#
# @error: #optional, error message. Only present on failure. This field
#         contains a human-readable error message. There are no semantics
#         other than that streaming has failed and clients should not try to
#         interpret the error string
#
# Since: 1.1
##
{ 'event': 'BLOCK_JOB_COMPLETED',
  'data': { 'type'  : 'BlockJobType',
            'device': 'str',
            'len'   : 'int',
            'offset': 'int',
            'speed' : 'int',
            '*error': 'str' } }

##
# @BLOCK_JOB_CANCELLED
#
# Emitted when a block job has been cancelled
#
# @type: job type
#
# @device: device name
#
# @len: maximum progress value
#
# @offset: current progress value. On success this is equal to len.
#          On failure this is less than len
#
# @speed: rate limit, bytes per second
#
# Since: 1.1
##
{ 'event': 'BLOCK_JOB_CANCELLED',
  'data': { 'type'  : 'BlockJobType',
            'device': 'str',
            'len'   : 'int',
            'offset': 'int',
            'speed' : 'int' } }

##
# @BLOCK_JOB_ERROR
#
# Emitted when a block job encounters an error
#
# @device: device name
#
# @operation: I/O operation
#
# @action: action that has been taken
#
# Since: 1.3
##
{ 'event': 'BLOCK_JOB_ERROR',
  'data': { 'device'   : 'str',
            'operation': 'IoOperationType',
            'action'   : 'BlockErrorAction' } }

##
# @BLOCK_JOB_READY
#
# Emitted when a block job is ready to complete
#
# @type: job type
#
# @device: device name
#
# @len: maximum progress value
#
# @offset: current progress value. On success this is equal to len.
#          On failure this is less than len
#
# @speed: rate limit, bytes per second
#
# Note: The "ready to complete" status is always reset by a @BLOCK_JOB_ERROR
# event
#
# Since: 1.3
##
{ 'event': 'BLOCK_JOB_READY',
  'data': { 'type'  : 'BlockJobType',
            'device': 'str',
            'len'   : 'int',
            'offset': 'int',
            'speed' : 'int' } }
