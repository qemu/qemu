#!/usr/bin/env python3

import argparse
import os
import sys
from typing import Optional


def print_array(name: str, values: list[str]) -> None:
    if len(values) == 0:
        return
    list = ", ".join(values)
    print(f"    .{name} = ((const char*[]){{ {list}, NULL }}),")

def parse_line(line: str) -> tuple[str, str]:
    kind = ""
    data = ""
    get_kind = False
    get_data = False
    for item in line.split():
        if item == "MODINFO_START":
            get_kind = True
            continue
        if item.startswith("MODINFO_END"):
            get_data = False
            continue
        if get_kind:
            kind = item
            get_kind = False
            get_data = True
            continue
        if get_data:
            data += " " + item
            continue
    return (kind, data)

def generate(name: str, lines: list[str], enabled: set[str]) -> Optional[set[str]]:
    arch = ""
    objs = []
    deps = []
    opts = []
    for line in lines:
        if "MODINFO_START" in line:
            (kind, data) = parse_line(line)
            if kind == 'obj':
                objs.append(data)
            elif kind == 'dep':
                deps.append(data)
            elif kind == 'opts':
                opts.append(data)
            elif kind == 'arch':
                arch = data
            elif kind == 'kconfig':
                # don't add a module which dependency is not enabled
                # in kconfig
                if data.strip() not in enabled:
                    print(f"    /* module {data.strip()} isn't enabled in Kconfig. */")
                    print("/* },{ */")
                    return None
            else:
                print("unknown:", kind)
                exit(1)

    print(f'    .name = "{name}",')
    if arch != "":
        print(f"    .arch = {arch},")
    print_array("objs", objs)
    print_array("deps", deps)
    print_array("opts", opts)
    print("},{")
    return {dep.strip('" ') for dep in deps}

def print_pre() -> None:
    print("/* generated by scripts/modinfo-generate.py */")
    print("#include \"qemu/osdep.h\"")
    print("#include \"qemu/module.h\"")
    print("const QemuModinfo qemu_modinfo[] = {{")

def print_post() -> None:
    print("    /* end of list */")
    print("}};")

def main() -> None:
    parser = argparse.ArgumentParser(
        description='Generate C code for QEMU module info'
    )
    parser.add_argument('--devices',
                        help='path to config-device.mak')
    parser.add_argument('modinfo', nargs='+',
                        help='modinfo files to process')
    args = parser.parse_args()

    # get all devices enabled in kconfig, from *-config-device.mak
    enabled = set()
    if args.devices:
        with open(args.devices) as file:
            for line in file.readlines():
                config = line.split('=')
                if config[1].rstrip() == 'y':
                    enabled.add(config[0][7:])  # remove CONFIG_

    deps = set()
    modules = set()
    print_pre()
    for modinfo in args.modinfo:
        with open(modinfo) as f:
            lines = f.readlines()
        print(f"    /* {modinfo} */")
        (basename, _) = os.path.splitext(modinfo)
        moddeps = generate(basename, lines, enabled)
        if moddeps is not None:
            modules.add(basename)
            deps.update(moddeps)
    print_post()

    error = False
    for dep in deps.difference(modules):
        print(f"Dependency {dep} cannot be satisfied", file=sys.stderr)
        error = True

    if error:
        exit(1)

if __name__ == "__main__":
    main()
