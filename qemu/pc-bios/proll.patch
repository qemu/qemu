diff -ruN proll_18.orig/Makefile proll-patch-15/Makefile
--- proll_18.orig/Makefile	2002-09-13 14:16:59.000000000 +0000
+++ proll-patch-15/Makefile	2005-11-09 18:14:51.000000000 +0000
@@ -4,6 +4,7 @@
 	make -C krups-ser    all
 	make -C espresso     all
 	make -C espresso-ser all
+	make -C qemu all
 
 clean:
 	make -C mrcoffee clean
@@ -11,3 +12,4 @@
 	make -C krups-ser    clean
 	make -C espresso     clean
 	make -C espresso-ser clean
+	make -C qemu clean
diff -ruN proll_18.orig/qemu/Makefile proll-patch-15/qemu/Makefile
--- proll_18.orig/qemu/Makefile	1970-01-01 00:00:00.000000000 +0000
+++ proll-patch-15/qemu/Makefile	2005-08-14 10:25:06.000000000 +0000
@@ -0,0 +1,123 @@
+#
+# proll:
+# qemu/Makefile - make PROLL for QEMU
+# $Id: proll.patch,v 1.6 2005/11/11 00:24:57 bellard Exp $
+#
+# Copyright 1999 Pete Zaitcev
+# This is Free Software is licensed under terms of GNU General Public License.
+#
+
+CC = gcc
+
+#CROSS = /usr/local/sparc/bin/sparc-sun-linux-
+CROSS = sparc-unknown-linux-gnu-
+
+CROSSCC = $(CROSS)gcc
+CROSSLD = $(CROSS)ld
+CROSSNM = $(CROSS)nm
+
+RM = /bin/rm -f
+ELFTOAOUT = elftoaout
+
+#
+SRC = ../src
+
+# Due to remapping algorithm PROLBASE should be algned on PMD.
+# We make PROLBASE a define instead of using _start because we
+# want to shift it to form a PGD entry. A relocatable label will not work.
+# Linux kernel expects us to be at LINUX_OPPROM_BEGVM <asm-sparc/openprom.h>.
+PROLBASE =   0xffd00000
+PROLRODATA = 0xffd08000
+PROLDATA =   0xffd0b000
+PROLSIZE = 240*1024
+
+# Linux
+# Fixed %g6 is for arch/sparc/kernel/head.S, it seems ok w/o -ffixed-g6.
+# Kernel uses -fcall-used-g5 -fcall-used-g7, we probably do not need them.
+# __ANSI__ is supposed to be on by default but it is not.
+CFLAGS = -O2 -W -Wall -DPROLBASE=$(PROLBASE) -DPROLDATA=$(PROLDATA) -DPROLRODATA=$(PROLRODATA) -D__ANSI__=1 -I$(SRC) -mcpu=hypersparc -Wa,-xarch=v8 -g -DQEMU -m32 -fno-builtin
+ASFLAGS = -D__ASSEMBLY__ -I$(SRC) -DPROLRODATA=$(PROLRODATA) -DPROLDATA=$(PROLDATA) -DPROLSIZE=$(PROLSIZE) -g -Wa,-xarch=v8 -Wa,-32
+# Solaris or Linux/i386 cross compilation
+#CFLAGS = -Iinclude -O
+
+LDFLAGS = -N -Ttext $(PROLBASE) --section-start .rodata=$(PROLRODATA) -Tdata $(PROLDATA) -Tbss $(PROLDATA)
+
+ALL = proll.aout
+PROLLEXE = proll.elf
+
+OBJS = head.o wuf.o wof.o main.o $(CONSOLE) \
+ printf.o le.o system_qemu.o iommu.o \
+ arp.o netinit.o bootp.o packet.o tftp.o udp.o sched_4m.o openprom.o \
+ vconsole.o hconsole.o rconsole.o vcons_zs.o esp.o
+
+all:           $(ALL)
+
+$(PROLLEXE):   $(OBJS)
+	$(CROSSLD) $(LDFLAGS) -o $(PROLLEXE) $(OBJS)
+
+head.o:         head.S $(SRC)/phys_jj.h \
+  $(SRC)/asi.h $(SRC)/psr.h $(SRC)/crs.h
+	$(CROSSCC) $(ASFLAGS) -DPROLBASE=$(PROLBASE) -o $*.o -c $*.S
+
+main.o:         main.c $(SRC)/asi.h $(SRC)/pgtsrmmu.h $(SRC)/iommu.h \
+  $(SRC)/phys_jj.h $(SRC)/vconsole.h $(SRC)/version.h $(SRC)/general.h \
+  $(SRC)/net.h $(SRC)/romlib.h $(SRC)/netpriv.h $(SRC)/arpa.h $(SRC)/system.h
+	$(CROSSCC) $(CFLAGS) -c $*.c
+openprom.o:	openprom.c $(SRC)/openprom.h $(SRC)/general.h $(SRC)/romlib.h \
+  $(SRC)/vconsole.h $(SRC)/system.h $(SRC)/phys_jj.h
+	$(CROSSCC) $(CFLAGS) -c $*.c
+
+system_qemu.o:       system_qemu.c $(SRC)/vconsole.h $(SRC)/pgtsrmmu.h \
+  $(SRC)/timer.h $(SRC)/general.h $(SRC)/net.h $(SRC)/romlib.h $(SRC)/asi.h \
+  $(SRC)/netpriv.h $(SRC)/arpa.h $(SRC)/system.h $(SRC)/crs.h
+	$(CROSSCC) $(CFLAGS) -c $*.c
+iommu.o:        $(SRC)/iommu.c $(SRC)/pgtsrmmu.h $(SRC)/phys_jj.h $(SRC)/iommu.h \
+ $(SRC)/vconsole.h $(SRC)/general.h $(SRC)/romlib.h $(SRC)/system.h $(SRC)/asi.h
+	$(CROSSCC) $(CFLAGS) -c $(SRC)/$*.c
+vconsole.o:	$(SRC)/vconsole.c $(SRC)/vconsole.h $(SRC)/hconsole.h
+	$(CROSSCC) $(CFLAGS) -c $(SRC)/$*.c
+vcons_zs.o:	$(SRC)/vcons_zs.c $(SRC)/vconsole.h $(SRC)/system.h
+	$(CROSSCC) $(CFLAGS) -c $(SRC)/$*.c
+hconsole.o:	$(SRC)/hconsole.c $(SRC)/hconsole.h $(SRC)/rconsole.h $(SRC)/phys_jj.h
+	$(CROSSCC) $(CFLAGS) -c $(SRC)/$*.c
+rconsole.o:	$(SRC)/rconsole.c $(SRC)/rconsole.h
+	$(CROSSCC) $(CFLAGS) -c $(SRC)/$*.c
+printf.o:       $(SRC)/printf.c
+	$(CROSSCC) $(CFLAGS) -c $(SRC)/$*.c
+le.o:		$(SRC)/le.c $(SRC)/dma.h $(SRC)/system.h $(SRC)/netpriv.h $(SRC)/romlib.h $(SRC)/general.h $(SRC)/net.h $(SRC)/phys_jj.h
+	$(CROSSCC) $(CFLAGS) -c $(SRC)/$*.c
+esp.o:		$(SRC)/esp.c $(SRC)/dma.h $(SRC)/system.h $(SRC)/romlib.h $(SRC)/general.h $(SRC)/phys_jj.h
+	$(CROSSCC) $(CFLAGS) -c $(SRC)/$*.c
+arp.o:		$(SRC)/arp.c $(SRC)/general.h $(SRC)/net.h $(SRC)/romlib.h $(SRC)/netpriv.h $(SRC)/arp.h
+	$(CROSSCC) $(CFLAGS) -c $(SRC)/$*.c
+netinit.o:	$(SRC)/netinit.c $(SRC)/general.h $(SRC)/net.h $(SRC)/romlib.h $(SRC)/netpriv.h $(SRC)/arp.h $(SRC)/ip.h $(SRC)/udp.h
+	$(CROSSCC) $(CFLAGS) -c $(SRC)/$*.c
+tftp.o:		$(SRC)/tftp.c $(SRC)/general.h $(SRC)/net.h $(SRC)/arpa.h $(SRC)/romlib.h $(SRC)/tftp.h
+	$(CROSSCC) $(CFLAGS) -c $(SRC)/$*.c
+udp.o:		$(SRC)/udp.c $(SRC)/general.h $(SRC)/net.h $(SRC)/romlib.h $(SRC)/netpriv.h $(SRC)/arp.h $(SRC)/ip.h $(SRC)/udp.h
+	$(CROSSCC) $(CFLAGS) -c $(SRC)/$*.c
+packet.o:	$(SRC)/packet.c $(SRC)/general.h $(SRC)/net.h $(SRC)/romlib.h $(SRC)/netpriv.h
+	$(CROSSCC) $(CFLAGS) -c $(SRC)/$*.c
+sched_4m.o:	$(SRC)/sched_4m.c $(SRC)/system.h $(SRC)/general.h $(SRC)/romlib.h $(SRC)/phys_jj.h
+	$(CROSSCC) $(CFLAGS) -c $(SRC)/$*.c
+bootp.o:	$(SRC)/bootp.c $(SRC)/general.h $(SRC)/net.h \
+  $(SRC)/arpa.h $(SRC)/romlib.h $(SRC)/system.h $(SRC)/bootp.h
+	$(CROSSCC) $(CFLAGS) -DNOBPEXT=1 -c $(SRC)/$*.c
+
+wuf.o:		$(SRC)/wuf.S
+	$(CROSSCC) $(ASFLAGS) -o $*.o -c $(SRC)/$*.S
+wof.o:		$(SRC)/wof.S
+	$(CROSSCC) $(ASFLAGS) -o $*.o -c $(SRC)/$*.S
+
+#genlab.o:      genlab.c
+#	$(CC) -c $*.c
+#
+#genlab:        genlab.o
+#	$(CC) -o genlab genlab.o
+
+clean:
+	$(RM) $(OBJS)
+	$(RM) $(PROLLEXE) proll.aout
+
+proll.aout:	$(PROLLEXE)
+	$(ELFTOAOUT) -o proll.aout $(PROLLEXE)
diff -ruN proll_18.orig/qemu/head.S proll-patch-15/qemu/head.S
--- proll_18.orig/qemu/head.S	1970-01-01 00:00:00.000000000 +0000
+++ proll-patch-15/qemu/head.S	2005-07-12 22:24:17.000000000 +0000
@@ -0,0 +1,543 @@
+/**
+ ** Standalone startup code for Linux PROM emulator.
+ ** Copyright 1999 Pete A. Zaitcev
+ ** This code is licensed under GNU General Public License.
+ **/
+/*
+ * $Id: proll.patch,v 1.6 2005/11/11 00:24:57 bellard Exp $
+ */
+
+#include <psr.h>
+#include <asi.h>
+#include <crs.h>
+/* #include <asm/head.h> */	/* Trap entries. Do not use. */
+#include "phys_jj.h"
+
+#define C_LABEL(name)	name
+#define REGWIN_SZ   0x40
+
+#define WRITE_PAUSE    nop; nop; nop; /* Have to do this after %wim/%psr chg */
+
+  /* 22 is 24-2, (va)>>(SRMMU_PGDIR_SHIFT-PTESIZESHFT) */
+#define VATOPGDOFF(va) (((va)>>22)&0x3FC)
+#define VATOPMDOFF(va) (((va)>>16)&0xFC)
+
+#define NOP_INSN       0x01000000     /* Used to patch sparc_save_state */
+
+/* Here are some trap goodies */
+
+#if 0
+/* Generic trap entry. */
+#define TRAP_ENTRY(type, label) \
+	rd %psr, %l0; b label; rd %wim, %l3; nop;
+#endif
+
+/* Data/text faults. */
+#define SRMMU_TFAULT rd %psr, %l0; rd %wim, %l3; b C_LABEL(srmmu_fault); mov 1, %l7;
+#define SRMMU_DFAULT rd %psr, %l0; rd %wim, %l3; b C_LABEL(srmmu_fault); mov 0, %l7;
+
+#if 0
+/* This is for traps we should NEVER get. */
+#define BAD_TRAP(num) \
+        rd %psr, %l0; mov num, %l7; b bad_trap_handler; rd %wim, %l3;
+
+/* This is for traps when we want just skip the instruction which caused it */
+#define SKIP_TRAP(type, name) \
+	jmpl %l2, %g0; rett %l2 + 4; nop; nop;
+
+/* Notice that for the system calls we pull a trick.  We load up a
+ * different pointer to the system call vector table in %l7, but call
+ * the same generic system call low-level entry point.  The trap table
+ * entry sequences are also HyperSparc pipeline friendly ;-)
+ */
+
+/* Software trap for Linux system calls. */
+#define LINUX_SYSCALL_TRAP \
+        sethi %hi(C_LABEL(sys_call_table)), %l7; \
+        or %l7, %lo(C_LABEL(sys_call_table)), %l7; \
+        b linux_sparc_syscall; \
+        rd %psr, %l0;
+
+/* Software trap for SunOS4.1.x system calls. */
+#define SUNOS_SYSCALL_TRAP \
+        rd %psr, %l0; \
+        sethi %hi(C_LABEL(sunos_sys_table)), %l7; \
+        b linux_sparc_syscall; \
+        or %l7, %lo(C_LABEL(sunos_sys_table)), %l7;
+
+/* Software trap for Slowaris system calls. */
+#define SOLARIS_SYSCALL_TRAP \
+        b solaris_syscall; \
+        rd %psr, %l0; \
+        nop; \
+        nop;
+
+#define INDIRECT_SOLARIS_SYSCALL(x) \
+	mov x, %g1; \
+	b solaris_syscall; \
+	rd %psr, %l0; \
+	nop;
+
+#define BREAKPOINT_TRAP \
+	b breakpoint_trap; \
+	rd %psr,%l0; \
+	nop; \
+	nop;
+
+/* Software trap for Sparc-netbsd system calls. */
+#define NETBSD_SYSCALL_TRAP \
+        sethi %hi(C_LABEL(sys_call_table)), %l7; \
+        or %l7, %lo(C_LABEL(sys_call_table)), %l7; \
+        b bsd_syscall; \
+        rd %psr, %l0;
+
+/* The Get Condition Codes software trap for userland. */
+#define GETCC_TRAP \
+        b getcc_trap_handler; mov %psr, %l0; nop; nop;
+
+/* The Set Condition Codes software trap for userland. */
+#define SETCC_TRAP \
+        b setcc_trap_handler; mov %psr, %l0; nop; nop;
+
+/* This is for hard interrupts from level 1-14, 15 is non-maskable (nmi) and
+ * gets handled with another macro.
+ */
+#define TRAP_ENTRY_INTERRUPT(int_level) \
+        mov int_level, %l7; rd %psr, %l0; b real_irq_entry; rd %wim, %l3;
+
+/* NMI's (Non Maskable Interrupts) are special, you can't keep them
+ * from coming in, and basically if you get one, the shows over. ;(
+ * On the sun4c they are usually asynchronous memory errors, on the
+ * the sun4m they could be either due to mem errors or a software
+ * initiated interrupt from the prom/kern on an SMP box saying "I
+ * command you to do CPU tricks, read your mailbox for more info."
+ */
+#define NMI_TRAP \
+        rd %wim, %l3; b linux_trap_nmi_sun4c; mov %psr, %l0; nop;
+
+#endif
+
+/* Window overflows/underflows are special and we need to try to be as
+ * efficient as possible here....
+ */
+#define WINDOW_SPILL \
+        rd %psr, %l0; rd %wim, %l3; b spill_window_entry; nop;
+
+#define WINDOW_FILL \
+        rd %psr, %l0; rd %wim, %l3; b fill_window_entry; nop;
+
+#define STUB_TRAP	ba stub_trap; nop; nop; nop;
+
+#define TRAP_ENTRY(a,b)		STUB_TRAP
+#define SKIP_TRAP(a,b)		STUB_TRAP
+#define SUNOS_SYSCALL_TRAP	STUB_TRAP
+#define SOLARIS_SYSCALL_TRAP	STUB_TRAP
+#define NETBSD_SYSCALL_TRAP	STUB_TRAP
+#define LINUX_SYSCALL_TRAP	STUB_TRAP
+#define BREAKPOINT_TRAP		STUB_TRAP
+#define NMI_TRAP		STUB_TRAP
+#define GETCC_TRAP		STUB_TRAP
+#define SETCC_TRAP		STUB_TRAP
+#define BAD_TRAP(n)		STUB_TRAP
+#define	TRAP_ENTRY_INTERRUPT(i)		STUB_TRAP
+#define	INDIRECT_SOLARIS_SYSCALL(i)	STUB_TRAP
+
+	.section ".text"
+	.globl start, _start
+_start:
+start:
+	.globl spill_window_entry, fill_window_entry
+
+#define	EXPORT_TRAP(trap) \
+	.globl trap; \
+	.type trap,function; \
+	.size trap, 16
+
+EXPORT_TRAP(t_zero)
+EXPORT_TRAP(t_wovf)
+EXPORT_TRAP(t_wunf)
+EXPORT_TRAP(t_irq1)
+EXPORT_TRAP(t_irq2)
+EXPORT_TRAP(t_irq3)
+EXPORT_TRAP(t_irq4)
+EXPORT_TRAP(t_irq5)
+EXPORT_TRAP(t_irq6)
+EXPORT_TRAP(t_irq7)
+EXPORT_TRAP(t_irq8)
+EXPORT_TRAP(t_irq9)
+EXPORT_TRAP(t_irq10)
+EXPORT_TRAP(t_irq11)
+EXPORT_TRAP(t_irq12)
+EXPORT_TRAP(t_irq13)
+EXPORT_TRAP(t_irq14)
+EXPORT_TRAP(t_irq15)
+
+C_LABEL(trapbase):
+t_zero:	b goprol; nop; nop; nop;
+t_tflt:	SRMMU_TFAULT                        /* Inst. Access Exception        */
+t_bins:	TRAP_ENTRY(0x2, bad_instruction)    /* Illegal Instruction           */
+t_pins:	TRAP_ENTRY(0x3, priv_instruction)   /* Privileged Instruction        */
+t_fpd:	TRAP_ENTRY(0x4, fpd_trap_handler)   /* Floating Point Disabled       */
+t_wovf:	WINDOW_SPILL                        /* Window Overflow               */
+t_wunf:	WINDOW_FILL                         /* Window Underflow              */
+t_mna:	TRAP_ENTRY(0x7, mna_handler)        /* Memory Address Not Aligned    */
+t_fpe:	TRAP_ENTRY(0x8, fpe_trap_handler)   /* Floating Point Exception      */
+t_dflt:	SRMMU_DFAULT                        /* Data Miss Exception           */
+t_tio:	TRAP_ENTRY(0xa, do_tag_overflow)    /* Tagged Instruction Ovrflw     */
+t_wpt:	TRAP_ENTRY(0xb, do_watchpoint)      /* Watchpoint Detected           */
+t_badc:	BAD_TRAP(0xc) BAD_TRAP(0xd) BAD_TRAP(0xe) BAD_TRAP(0xf) BAD_TRAP(0x10)
+t_irq1:	TRAP_ENTRY_INTERRUPT(1)             /* IRQ Software/SBUS Level 1     */
+t_irq2:	TRAP_ENTRY_INTERRUPT(2)             /* IRQ SBUS Level 2              */
+t_irq3:	TRAP_ENTRY_INTERRUPT(3)             /* IRQ SCSI/DMA/SBUS Level 3     */
+t_irq4:	TRAP_ENTRY_INTERRUPT(4)             /* IRQ Software Level 4          */
+t_irq5:	TRAP_ENTRY_INTERRUPT(5)             /* IRQ SBUS/Ethernet Level 5     */
+t_irq6:	TRAP_ENTRY_INTERRUPT(6)             /* IRQ Software Level 6          */
+t_irq7:	TRAP_ENTRY_INTERRUPT(7)             /* IRQ Video/SBUS Level 5        */
+t_irq8:	TRAP_ENTRY_INTERRUPT(8)             /* IRQ SBUS Level 6              */
+t_irq9:	TRAP_ENTRY_INTERRUPT(9)             /* IRQ SBUS Level 7              */
+t_irq10:TRAP_ENTRY_INTERRUPT(10)            /* IRQ Timer #1 (one we use)     */
+t_irq11:TRAP_ENTRY_INTERRUPT(11)            /* IRQ Floppy Intr.              */
+t_irq12:TRAP_ENTRY_INTERRUPT(12)            /* IRQ Zilog serial chip         */
+t_irq13:TRAP_ENTRY_INTERRUPT(13)            /* IRQ Audio Intr.               */
+t_irq14:TRAP_ENTRY_INTERRUPT(14)            /* IRQ Timer #2                  */
+t_nmi:	NMI_TRAP                            /* Level 15 (NMI)                */
+t_racc:	TRAP_ENTRY(0x20, do_reg_access)     /* General Register Access Error */
+t_iacce:BAD_TRAP(0x21)                      /* Instr Access Error            */
+t_bad22:BAD_TRAP(0x22) BAD_TRAP(0x23)
+t_cpdis:TRAP_ENTRY(0x24, do_cp_disabled)    /* Co-Processor Disabled         */
+t_uflsh:SKIP_TRAP(0x25, unimp_flush)        /* Unimplemented FLUSH inst.     */
+t_bad26:BAD_TRAP(0x26) BAD_TRAP(0x27)
+t_cpexc:TRAP_ENTRY(0x28, do_cp_exception)   /* Co-Processor Exception        */
+t_dacce:SRMMU_DFAULT                        /* Data Access Error             */
+t_hwdz:	TRAP_ENTRY(0x2a, do_hw_divzero)     /* Division by zero, you lose... */
+t_dserr:BAD_TRAP(0x2b)                      /* Data Store Error              */
+t_daccm:BAD_TRAP(0x2c)                      /* Data Access MMU-Miss          */
+t_bad2d:               BAD_TRAP(0x2d) BAD_TRAP(0x2e) BAD_TRAP(0x2f)
+        BAD_TRAP(0x30) BAD_TRAP(0x31) BAD_TRAP(0x32) BAD_TRAP(0x33)
+        BAD_TRAP(0x34) BAD_TRAP(0x35) BAD_TRAP(0x36) BAD_TRAP(0x37)
+        BAD_TRAP(0x38) BAD_TRAP(0x39) BAD_TRAP(0x3a) BAD_TRAP(0x3b)
+t_iaccm:BAD_TRAP(0x3c)                      /* Instr Access MMU-Miss         */
+ BAD_TRAP(0x3d) BAD_TRAP(0x3e) BAD_TRAP(0x3f)
+ BAD_TRAP(0x40) BAD_TRAP(0x41) BAD_TRAP(0x42) BAD_TRAP(0x43)
+ BAD_TRAP(0x44) BAD_TRAP(0x45) BAD_TRAP(0x46) BAD_TRAP(0x47)
+ BAD_TRAP(0x48) BAD_TRAP(0x49) BAD_TRAP(0x4a) BAD_TRAP(0x4b)
+ BAD_TRAP(0x4c) BAD_TRAP(0x4d) BAD_TRAP(0x4e) BAD_TRAP(0x4f)
+ BAD_TRAP(0x50) BAD_TRAP(0x51) BAD_TRAP(0x52) BAD_TRAP(0x53)
+ BAD_TRAP(0x54) BAD_TRAP(0x55) BAD_TRAP(0x56) BAD_TRAP(0x57)
+ BAD_TRAP(0x58) BAD_TRAP(0x59) BAD_TRAP(0x5a) BAD_TRAP(0x5b)
+ BAD_TRAP(0x5c) BAD_TRAP(0x5d) BAD_TRAP(0x5e) BAD_TRAP(0x5f)
+ BAD_TRAP(0x60) BAD_TRAP(0x61) BAD_TRAP(0x62) BAD_TRAP(0x63)
+ BAD_TRAP(0x64) BAD_TRAP(0x65) BAD_TRAP(0x66) BAD_TRAP(0x67)
+ BAD_TRAP(0x68) BAD_TRAP(0x69) BAD_TRAP(0x6a) BAD_TRAP(0x6b)
+ BAD_TRAP(0x6c) BAD_TRAP(0x6d) BAD_TRAP(0x6e) BAD_TRAP(0x6f)
+ BAD_TRAP(0x70) BAD_TRAP(0x71) BAD_TRAP(0x72) BAD_TRAP(0x73)
+ BAD_TRAP(0x74) BAD_TRAP(0x75) BAD_TRAP(0x76) BAD_TRAP(0x77)
+ BAD_TRAP(0x78) BAD_TRAP(0x79) BAD_TRAP(0x7a) BAD_TRAP(0x7b)
+ BAD_TRAP(0x7c) BAD_TRAP(0x7d) BAD_TRAP(0x7e) BAD_TRAP(0x7f)
+t_sunos:SUNOS_SYSCALL_TRAP                  /* SunOS System Call             */
+t_sbkpt:BREAKPOINT_TRAP                     /* Software Breakpoint/KGDB      */
+t_divz:	BAD_TRAP(0x82)                      /* Divide by zero trap           */
+t_flwin:TRAP_ENTRY(0x83, do_flush_windows)  /* Flush Windows Trap            */
+t_clwin:BAD_TRAP(0x84)                      /* Clean Windows Trap            */
+t_rchk:	BAD_TRAP(0x85)                      /* Range Check                   */
+t_funal:BAD_TRAP(0x86)                      /* Fix Unaligned Access Trap     */
+t_iovf:	BAD_TRAP(0x87)                      /* Integer Overflow Trap         */
+t_slowl:SOLARIS_SYSCALL_TRAP                /* Slowaris System Call          */
+t_netbs:NETBSD_SYSCALL_TRAP                 /* Net-B.S. System Call          */
+t_bad8a:BAD_TRAP(0x8a) BAD_TRAP(0x8b) BAD_TRAP(0x8c) BAD_TRAP(0x8d)
+ BAD_TRAP(0x8e) BAD_TRAP(0x8f)
+t_linux:LINUX_SYSCALL_TRAP                  /* Linux System Call             */
+t_bad91:BAD_TRAP(0x91) BAD_TRAP(0x92) BAD_TRAP(0x93)
+ BAD_TRAP(0x94) BAD_TRAP(0x95) BAD_TRAP(0x96) BAD_TRAP(0x97)
+ BAD_TRAP(0x98) BAD_TRAP(0x99) BAD_TRAP(0x9a) BAD_TRAP(0x9b) BAD_TRAP(0x9c) BAD_TRAP(0x9d) BAD_TRAP(0x9e) BAD_TRAP(0x9f)
+t_getcc:GETCC_TRAP                          /* Get Condition Codes           */
+t_setcc:SETCC_TRAP                          /* Set Condition Codes           */
+t_bada2:BAD_TRAP(0xa2) BAD_TRAP(0xa3)
+ BAD_TRAP(0xa4) BAD_TRAP(0xa5) BAD_TRAP(0xa6)
+t_slowi:INDIRECT_SOLARIS_SYSCALL(156)
+ BAD_TRAP(0xa8) BAD_TRAP(0xa9) BAD_TRAP(0xaa) BAD_TRAP(0xab)
+ BAD_TRAP(0xac) BAD_TRAP(0xad) BAD_TRAP(0xae) BAD_TRAP(0xaf)
+ BAD_TRAP(0xb0) BAD_TRAP(0xb1) BAD_TRAP(0xb2) BAD_TRAP(0xb3)
+ BAD_TRAP(0xb4) BAD_TRAP(0xb5) BAD_TRAP(0xb6) BAD_TRAP(0xb7)
+ BAD_TRAP(0xb8) BAD_TRAP(0xb9) BAD_TRAP(0xba) BAD_TRAP(0xbb)
+ BAD_TRAP(0xbc) BAD_TRAP(0xbd) BAD_TRAP(0xbe) BAD_TRAP(0xbf)
+t_badc0:BAD_TRAP(0xc0) BAD_TRAP(0xc1) BAD_TRAP(0xc2) BAD_TRAP(0xc3)
+ BAD_TRAP(0xc4) BAD_TRAP(0xc5) BAD_TRAP(0xc6) BAD_TRAP(0xc7)
+ BAD_TRAP(0xc8) BAD_TRAP(0xc9) BAD_TRAP(0xca) BAD_TRAP(0xcb)
+ BAD_TRAP(0xcc) BAD_TRAP(0xcd) BAD_TRAP(0xce) BAD_TRAP(0xcf)
+ BAD_TRAP(0xd0) BAD_TRAP(0xd1) BAD_TRAP(0xd2) BAD_TRAP(0xd3)
+t_badd4:BAD_TRAP(0xd4) BAD_TRAP(0xd5) BAD_TRAP(0xd6) BAD_TRAP(0xd7)
+ BAD_TRAP(0xd8) BAD_TRAP(0xd9) BAD_TRAP(0xda) BAD_TRAP(0xdb)
+ BAD_TRAP(0xdc) BAD_TRAP(0xdd) BAD_TRAP(0xde) BAD_TRAP(0xdf)
+ BAD_TRAP(0xe0) BAD_TRAP(0xe1) BAD_TRAP(0xe2) BAD_TRAP(0xe3)
+ BAD_TRAP(0xe4) BAD_TRAP(0xe5) BAD_TRAP(0xe6) BAD_TRAP(0xe7)
+t_bade8:BAD_TRAP(0xe8) BAD_TRAP(0xe9) BAD_TRAP(0xea) BAD_TRAP(0xeb)
+ BAD_TRAP(0xec) BAD_TRAP(0xed) BAD_TRAP(0xee) BAD_TRAP(0xef)
+ BAD_TRAP(0xf0) BAD_TRAP(0xf1) BAD_TRAP(0xf2) BAD_TRAP(0xf3)
+ BAD_TRAP(0xf4) BAD_TRAP(0xf5) BAD_TRAP(0xf6) BAD_TRAP(0xf7)
+ BAD_TRAP(0xf8) BAD_TRAP(0xf9) BAD_TRAP(0xfa) BAD_TRAP(0xfb)
+t_badfc:BAD_TRAP(0xfc) BAD_TRAP(0xfd)
+dbtrap:	BAD_TRAP(0xfe)                      /* Debugger/PROM breakpoint #1   */
+dbtrap2:BAD_TRAP(0xff)                      /* Debugger/PROM breakpoint #2   */	
+
+stub_trap:
+   set (PHYS_JJ_TCX_FB + 0xbf0), %g5	/* 2 cells from side */
+   set 0x00ffffff, %g4
+   sta %g4, [%g5] ASI_M_BYPASS
+1:	ba 1b; nop
+
+	.section ".bss"
+	.align 8
+bss_start:
+	.align	0x1000		! PAGE_SIZE
+	.globl C_LABEL(bootup_user_stack)
+        .type   bootup_user_stack,#object
+        .size   bootup_user_stack,0x2000
+C_LABEL(bootup_user_stack):		.skip 0x2000
+
+	.section ".text"
+	.register %g2, #scratch
+	.register %g3, #scratch
+	.register %g6, #scratch
+	.register %g7, #scratch
+
+goprol:
+	! %g1 contains end of memory
+	set	PHYS_JJ_EEPROM + 0x30, %g1
+	lda	[%g1] ASI_M_BYPASS, %g1
+	! map PROLDATA to PROLBASE+PROLSIZE to end of ram
+	set	PROLSIZE+0x1000-PROLDATA+PROLBASE, %g2	! add 0x1000 for temp tables
+	sub	%g1, %g2, %g2			! start of private memory
+	srl	%g2, 0x4, %g7			! ctx table at s+0x0
+	add	%g2, 0x400, %g3			! l1 table at s+0x400
+	srl	%g3, 0x4, %g3
+	or	%g3, 0x1, %g3
+	sta	%g3, [%g2] ASI_M_BYPASS
+	add	%g2, 0x400, %g2			! s+0x400
+	add	%g2, 0x800, %g3			! l2 table for ram (00xxxxxx) at s+0x800
+	srl	%g3, 0x4, %g3
+	or	%g3, 0x1, %g3
+	sta	%g3, [%g2] ASI_M_BYPASS
+	add	%g2, 0x500, %g3			! l2 table for rom (ffxxxxxx) at s+0x900
+	add	%g2, 0x3fc, %g2			! s+0x7fc
+	srl	%g3, 0x4, %g3
+	or	%g3, 0x1, %g3
+	sta	%g3, [%g2] ASI_M_BYPASS
+	add	%g2, 0x4, %g2			! s+0x800
+	set	((7 << 2) | 2), %g3		! 7 = U: --- S: RWX (main memory)
+	sta	%g3, [%g2] ASI_M_BYPASS
+	add	%g2, 0x200, %g3			! l3 table for rom at s+0xa00
+	add	%g2, 0x1d0, %g2			! s+0x9d0
+	srl	%g3, 0x4, %g3
+	or	%g3, 0x1, %g3
+	sta	%g3, [%g2] ASI_M_BYPASS
+	add	%g2, 0x30, %g2			! s+0xa00
+
+	set	PROLBASE, %g3
+	set	0x1000, %g5
+	set	(PROLDATA-PROLBASE)/0x1000, %g6 ! # of .text pages
+1:	srl	%g3, 0x4, %g4
+	or	%g4, ((7 << 2) | 2), %g4	! 4 = U: --X S: --X (rom, execute only)
+	sta	%g4, [%g2] ASI_M_BYPASS
+	add	%g2, 4, %g2
+	add	%g3, %g5, %g3
+	deccc	%g6
+	bne	1b
+	 nop
+#if 0	
+	set	(PROLDATA-PROLRODATA)/0x1000, %g6 ! # of .rodata pages
+1:	srl	%g3, 0x4, %g4
+	or	%g4, ((0 << 2) | 2), %g4	! 0 = U: R-- S: R-- (rom, read only)
+	sta	%g4, [%g2] ASI_M_BYPASS
+	add	%g2, 4, %g2
+	add	%g3, %g5, %g3
+	deccc	%g6
+	bne	1b
+	 nop
+#endif
+	set	(PROLBASE+PROLSIZE-PROLDATA)/0x1000, %g6 ! # of .bss pages
+	set	0x1000, %g4
+	sll	%g7, 0x4, %g3
+	add	%g4, %g3, %g3
+1:	srl	%g3, 0x4, %g4
+	or	%g4, ((7 << 2) | 2), %g4        ! 5 = U: R-- S: RW- (data area, read/write)
+	sta	%g4, [%g2] ASI_M_BYPASS
+	add	%g2, 4, %g2
+	add	%g3, %g5, %g3
+	deccc	%g6
+	bne	1b
+	 nop
+
+	mov	%g1, %g3
+
+	set     AC_M_CTPR, %g2
+	sta     %g7, [%g2] ASI_M_MMUREGS	! set ctx table ptr
+	set	1, %g1
+	sta     %g1, [%g0] ASI_M_MMUREGS	! enable mmu
+
+	/*
+	 * The code which enables traps is a simplified version of
+	 * kernel head.S.
+	 *
+	 * We know number of windows as 8 so we do not calculate them.
+	 * The deadwood is here for any case.
+	 */
+
+	/* Turn on Supervisor, EnableFloating, and all the PIL bits.
+	 * Also puts us in register window zero with traps off.
+	 */
+	set	(PSR_PS | PSR_S | PSR_PIL | PSR_EF), %g2
+	wr	%g2, 0x0, %psr
+	WRITE_PAUSE
+
+	/* I want a kernel stack NOW! */
+	set	C_LABEL(bootup_user_stack), %g1
+	set	(0x2000 - REGWIN_SZ), %g2
+	add	%g1, %g2, %sp
+	mov	0, %fp			/* And for good luck */
+
+	/* Zero out our BSS section. */
+	set	C_LABEL(bss_start) , %o0	! First address of BSS
+	set	C_LABEL(end) , %o1		! Last address of BSS
+	ba	2f
+	 nop
+1:
+	st	%g0, [%o0]
+2:
+	subcc	%o0, %o1, %g0
+	bl	1b
+	 add	%o0, 0x4, %o0
+
+	mov	2, %g1
+	wr	%g1, 0x0, %wim			! make window 1 invalid
+	WRITE_PAUSE
+
+#if 0
+	wr  %g0, 0x0, %wim
+	WRITE_PAUSE
+	save
+	rd  %psr, %g3
+	restore
+	and  %g3, PSR_CWP, %g3
+	add  %g3, 0x1, %g3
+#else
+	or	%g0, 8, %g3
+#endif
+
+#if 0
+	sethi	%hi( C_LABEL(cputyp) ), %o0
+	st	%g7, [%o0 + %lo( C_LABEL(cputyp) )]
+
+	sethi	%hi( C_LABEL(nwindows) ), %g4
+	st	%g3, [%g4 + %lo( C_LABEL(nwindows) )]
+
+	sub	%g3, 0x1, %g3
+	sethi	%hi( C_LABEL(nwindowsm1) ), %g4
+	st	%g3, [%g4 + %lo( C_LABEL(nwindowsm1) )]
+#endif
+
+	/* Here we go, start using Linux's trap table... */
+	set	C_LABEL(trapbase), %g3
+	wr	%g3, 0x0, %tbr
+	WRITE_PAUSE
+
+	/* Finally, turn on traps so that we can call c-code. */
+	rd	%psr, %g3
+	wr	%g3, 0x0, %psr
+	WRITE_PAUSE
+
+	wr	%g3, PSR_ET, %psr
+	WRITE_PAUSE
+
+	.globl prolmain
+	call C_LABEL(prolmain)
+	 nop
+
+3:
+	b       3b
+	 nop
+
+/*
+ * Memory access trap handler
+ *   %l0  program %psr from trap table entry
+ *   %l1  program %pc from hardware
+ *   %l2  program %npc from hardware
+ *   %l3  program %wim from trap table entry
+ *   %l4
+ *   %l5
+ *   %l6
+ *   %l7  text flag from trap table entry
+ */
+
+	.section ".text"
+	.globl srmmu_fault
+C_LABEL(srmmu_fault):
+
+	set AC_M_SFAR, %l6
+	set AC_M_SFSR, %l5
+	lda [%l6] ASI_M_MMUREGS, %l6
+	lda [%l5] ASI_M_MMUREGS, %l5
+
+	set ignore_fault, %l5
+	ld [%l5], %l5
+	subcc %l5, %g0, %g0		/* NULL pointer trap faults always */
+	be 3f
+	 nop
+	subcc %l5, %l6, %g0
+	be 2f
+	 nop
+3:
+
+   set (PHYS_JJ_TCX_FB + 0xbf0), %g5	/* 2 cells from side */
+   set 0x00ffffff, %g4
+   sta %g4, [%g5] ASI_M_BYPASS
+   add %g5, 8, %g5			/* On right side */
+   sta %g4, [%g5] ASI_M_BYPASS
+1:	ba 1b; nop
+
+2:
+	set C_LABEL(fault_ignored), %l5
+	mov 1, %l6
+	st %l6, [%l5]
+
+	/*
+	 * Skip the faulting instruction.
+	 * I think it works when next instruction is a branch even.
+	 */
+	or %l2, 0, %l1
+	add %l2, 4, %l2
+
+	wr %l0, 0, %psr
+	WRITE_PAUSE
+	jmp %l1
+	rett %l2
+
+/*
+ * Slow external versions of st_bypass and ld_bypass.
+ * rconsole.c uses inlines. We call these in places which are not speed
+ * critical, to avoid compiler bugs.
+ */
+	.globl C_LABEL(st_bypass)
+C_LABEL(st_bypass):
+	retl
+	 sta %o1, [%o0] ASI_M_BYPASS
+	.globl C_LABEL(ld_bypass)
+C_LABEL(ld_bypass):
+	retl
+	 lda [%o0] ASI_M_BYPASS, %o0
+	.globl C_LABEL(sth_bypass)
+C_LABEL(sth_bypass):
+	retl
+	 stha %o1, [%o0] ASI_M_BYPASS
+	.globl C_LABEL(ldh_bypass)
+C_LABEL(ldh_bypass):
+	retl
+	 lduha [%o0] ASI_M_BYPASS, %o0
+	.globl C_LABEL(stb_bypass)
+C_LABEL(stb_bypass):
+	retl
+	 stba %o1, [%o0] ASI_M_BYPASS
+	.globl C_LABEL(ldb_bypass)
+C_LABEL(ldb_bypass):
+	retl
+	 lduba [%o0] ASI_M_BYPASS, %o0
diff -ruN proll_18.orig/qemu/main.c proll-patch-15/qemu/main.c
--- proll_18.orig/qemu/main.c	1970-01-01 00:00:00.000000000 +0000
+++ proll-patch-15/qemu/main.c	2005-08-14 10:07:48.000000000 +0000
@@ -0,0 +1,185 @@
+/**
+ ** Proll (PROM replacement)
+ ** Copyright 1999 Pete Zaitcev
+ ** This code is licensed under GNU General Public License.
+ **/
+#include <stdarg.h>
+
+// #include <asm/contregs.h>
+#include <asi.h>
+#include "pgtsrmmu.h"
+#include "iommu.h"		/* Typical SBus IOMMU for sun4m */
+#include "phys_jj.h"
+#include "vconsole.h"
+#include "version.h"
+#include <general.h>		/* __P() */
+#include <net.h>		/* init_net() */
+#include <romlib.h>		/* we are a provider for part of this. */
+#include <netpriv.h>		/* myipaddr */
+#include <arpa.h>
+#include <system.h>		/* our own prototypes */
+
+void *init_openprom_qemu(int bankc, struct bank *bankv, unsigned hiphybas, const char *cmdline, char boot_device, int nographic);
+int vcon_zs_init(struct vconterm *t, unsigned int a0);
+int vcon_zs_write(struct vconterm *t, char *data, int leng);
+int vcon_zs_getch(struct vconterm *t);
+void esp_probe();
+int esp_boot(int unit);
+static void init_idprom(void);
+
+struct vconterm dp0;
+struct mem cmem;		/* Current memory, virtual */
+struct mem cio;			/* Current I/O space */
+struct phym pmem;		/* Current phys. mem. */
+struct iommu ciommu;		/* Our IOMMU on sun4m */
+
+static struct {
+    const char id[16];
+    unsigned int version;
+    char pad1[0x1c]; // Pad to 0x30
+    unsigned int ram_size;
+    char boot_device;
+    unsigned int load_addr, kernel_size;
+    unsigned int cmdline, cmdline_len;
+    char pad2[0x0c]; // Pad to 0x54
+    unsigned short width, height, depth;
+} *hw_idprom;
+
+int ignore_fault, fault_ignored;
+void *printk_fn, *getch_fn;
+unsigned int q_height, q_width;
+
+/*
+ */
+void prolmain()
+{
+	static char fname[14];
+	static struct banks bb;
+	unsigned int hiphybas;
+	const void *romvec;
+	unsigned int ram_size;
+	char nographic, bootdev;
+
+	nographic = ldb_bypass(PHYS_JJ_EEPROM + 0x2F);
+	if (!nographic) {
+	    q_width = ldh_bypass(PHYS_JJ_EEPROM + 0x54);
+	    q_height = ldh_bypass(PHYS_JJ_EEPROM + 0x56);
+	    vcon_init(&dp0, PHYS_JJ_TCX_FB);
+	    printk_fn = vcon_write;
+	    getch_fn = vcon_getch;
+	}
+	else {
+	    vcon_zs_init(&dp0, 0x71100004);
+	    printk_fn = vcon_zs_write;
+	    getch_fn = vcon_zs_getch;
+	}
+
+
+	printk("PROLL %s QEMU\n", PROLL_VERSION_STRING);
+	ram_size = ld_bypass(PHYS_JJ_EEPROM + 0x30);
+	printk("%d MB total\n", ram_size/(1024*1024));
+
+	bb.nbanks = 1;
+	bb.bankv[0].start = 0;
+	bb.bankv[0].length = ram_size;
+
+	hiphybas = ram_size - PROLSIZE;
+
+	mem_init(&cmem, (char *) &_end, (char *)(PROLBASE+PROLSIZE));
+	makepages(&pmem, hiphybas);
+	init_mmu_swift((unsigned int)pmem.pctp - PROLBASE + hiphybas);
+
+	mem_init(&cio, (char *)(PROLBASE+PROLSIZE),
+	    (char *)(PROLBASE+PROLSIZE+IOMAPSIZE));
+
+	iommu_init(&ciommu, hiphybas);
+
+	/*
+	 */
+	init_idprom();
+	printk("NVRAM: id %s version %d\n", hw_idprom->id, hw_idprom->version);
+	if (!nographic)
+	    printk("Prom console: TCX %dx%d\n", q_width, q_height);
+	else
+	    printk("Prom console: serial\n");
+	sched_init();
+	le_probe();
+	init_net();
+	esp_probe();
+
+	bootdev = hw_idprom->boot_device;
+	printk("Boot device: %c\n", bootdev);
+	if (hw_idprom->kernel_size > 0) {
+	    printk("Kernel already loaded\n");
+	} else if (bootdev == 'n') {
+	    if (bootp() != 0) fatal();
+	    /*
+	     * boot_rec.bp_file cannot be used because system PROM
+	     * uses it to locate ourselves. If we load from boot_rec.bp_file,
+	     * we will loop reloading PROLL over and over again.
+	     * Thus we use traditional PROLL scheme HEXIPADDR.PROL (single L).
+	     */
+	    xtoa(myipaddr, fname, 8);
+	    fname[9] = '.';
+	    fname[10] = 'P';
+	    fname[11] = 'R';
+	    fname[12] = 'O';
+	    fname[13] = 'L';
+	    fname[14] = 0;
+	    
+	    if (load(boot_rec.bp_siaddr, fname) != 0) fatal();
+	} else if (bootdev == 'c') {
+	    if (esp_boot(0) != 0) fatal();
+	} else if (bootdev == 'd') {
+	    if (esp_boot(2) != 0) fatal();
+	}
+
+	romvec = init_openprom_qemu(bb.nbanks, bb.bankv, hiphybas,
+				    (void *)hw_idprom->cmdline, hw_idprom->boot_device, nographic);
+
+	printk("Memory used: virt 0x%x:0x%x[%dK] iomap 0x%x:0x%x\n",
+	    PROLBASE, (int)cmem.curp, ((unsigned) cmem.curp - PROLBASE)/1024,
+	    (int)cio.start, (int)cio.curp);
+
+	{
+	    void (*entry)(const void *, int, int, int, int) = (void *) hw_idprom->load_addr;
+		printk("Kernel loaded at 0x%x, size %dK, command line = '%s'\n",
+		       *entry, hw_idprom->kernel_size/1024, hw_idprom->cmdline);
+		entry(romvec, 0, 0, 0, 0);
+	}
+
+	mem_fini(&cmem);
+	vcon_fini(&dp0);
+}
+
+/*
+ * dvma_alloc over iommu_alloc.
+ */
+void *dvma_alloc(int size, unsigned int *pphys)
+{
+	return iommu_alloc(&ciommu, size, pphys);
+}
+
+/*
+ */
+void udelay(__attribute__((unused)) unsigned long usecs)
+{
+    // Qemu hardware is perfect and does not need any delays!
+}
+
+static void init_idprom()
+{
+	void *va_prom;
+
+	if ((va_prom = map_io(PHYS_JJ_EEPROM, PHYS_JJ_EEPROM_SIZE)) == NULL) {
+		printk("init_idprom: cannot map eeprom\n");
+		fatal();
+	}
+	bcopy(va_prom + PHYS_JJ_IDPROM_OFF, idprom, IDPROM_SIZE);
+	/*
+	 * hw_idprom is not used anywhere.
+	 * It's just as we hate to leave hanging pointers (I/O page here).
+	 */
+	hw_idprom = va_prom; 
+}
+
diff -ruN proll_18.orig/qemu/openprom.c proll-patch-15/qemu/openprom.c
--- proll_18.orig/qemu/openprom.c	1970-01-01 00:00:00.000000000 +0000
+++ proll-patch-15/qemu/openprom.c	2005-11-07 20:11:04.000000000 +0000
@@ -0,0 +1,910 @@
+/*
+ * PROM interface support
+ * Copyright 1996 The Australian National University.
+ * Copyright 1996 Fujitsu Laboratories Limited
+ * Copyright 1999 Pete A. Zaitcev
+ * This software may be distributed under the terms of the Gnu
+ * Public License version 2 or later
+ */
+
+#include <openprom.h>
+#include <general.h>
+#include <romlib.h>
+#include <system.h>
+#include <vconsole.h>
+#include "phys_jj.h"
+
+//#define DEBUG_OBP
+
+#define PAGE_SIZE 4096
+
+struct property {
+	const char *name;
+	const char *value;
+	int length;
+};
+
+struct node {
+	const struct property *properties;
+	/* short */ const int sibling;
+	/* short */ const int child;
+};
+
+static int obp_nextnode(int node);
+static int obp_child(int node);
+static int obp_proplen(int node, char *name);
+static int obp_getprop(int node, char *name, char *val);
+static int obp_setprop(int node, char *name, char *val, int len);
+static const char *obp_nextprop(int node, char *name);
+
+static char obp_idprom[IDPROM_SIZE];
+static const struct property null_properties = { NULL, NULL, -1 };
+static const int prop_true = -1;
+
+static struct property propv_root[7];
+
+static const struct property propv_root_templ[] = {
+	{"name",	"SUNW,SparcStation-5", sizeof("SUNW,SparcStation-5") },
+	{"idprom",	obp_idprom, IDPROM_SIZE},
+	{"banner-name", "SparcStation", sizeof("SparcStation")},
+	{"compatible",	"sun4m", 6},
+};
+
+static const int prop_iommu_reg[] = {
+	0x0, 0x10000000, 0x00000300,
+};
+static const struct property propv_iommu[] = {
+	{"name",	"iommu", sizeof("iommu")},
+	{"reg",		(char*)&prop_iommu_reg[0], sizeof(prop_iommu_reg) },
+	{NULL, NULL, -1}
+};
+
+static const int prop_sbus_ranges[] = {
+	0x0, 0x0, 0x0, 0x30000000, 0x10000000,
+	0x1, 0x0, 0x0, 0x40000000, 0x10000000,
+	0x2, 0x0, 0x0, 0x50000000, 0x10000000,
+	0x3, 0x0, 0x0, 0x60000000, 0x10000000,
+	0x4, 0x0, 0x0, 0x70000000, 0x10000000,
+};
+static const struct property propv_sbus[] = {
+	{"name",	"sbus", 5},
+	{"ranges",	(char*)&prop_sbus_ranges[0], sizeof(prop_sbus_ranges)},
+	{"device_type",	"hierarchical", sizeof("hierarchical") },
+	{NULL, NULL, -1}
+};
+
+static const int prop_tcx_regs[] = {
+	0x2, 0x00800000, 0x00100000,
+	0x2, 0x02000000, 0x00000001,
+	0x2, 0x04000000, 0x00800000,
+	0x2, 0x06000000, 0x00800000,
+	0x2, 0x0a000000, 0x00000001,
+	0x2, 0x0c000000, 0x00000001,
+	0x2, 0x0e000000, 0x00000001,
+	0x2, 0x00700000, 0x00001000,
+	0x2, 0x00200000, 0x00000004,
+	0x2, 0x00300000, 0x0000081c,
+	0x2, 0x00000000, 0x00010000,
+	0x2, 0x00240000, 0x00000004,
+	0x2, 0x00280000, 0x00000001,
+};
+
+#if 1	/* Zaitcev */
+static const int pixfreq = 0x03dfd240;
+static const int hbporch = 0xa0;
+static const int vfreq = 0x3c;
+#endif
+#if 0	/* Kevin Boone - 70Hz refresh */
+static const int pixfreq = 0x047868C0;
+static const int hbporch = 0x90;
+static const int vfreq = 0x46;
+#endif
+
+static const int vbporch = 0x1d;
+static const int vsync = 0x6;
+static const int hsync = 0x88;
+static const int vfporch = 0x3;
+static const int hfporch = 0x18;
+static const int height = 0x300;
+static const int width = 0x400;
+static const int linebytes = 0x400;
+static const int depth = 24;
+static const int tcx_intr[] = { 5, 0 };
+static const int tcx_interrupts = 5;
+static const struct property propv_sbus_tcx[] = {
+	{"name",	"SUNW,tcx", sizeof("SUNW,tcx")},
+	{"vbporch",	(char*)&vbporch, sizeof(int)},
+	{"hbporch",	(char*)&hbporch, sizeof(int)},
+	{"vsync",	(char*)&vsync, sizeof(int)},
+	{"hsync",	(char*)&hsync, sizeof(int)},
+	{"vfporch",	(char*)&vfporch, sizeof(int)},
+	{"hfporch",	(char*)&hfporch, sizeof(int)},
+	{"pixfreq",	(char*)&pixfreq, sizeof(int)},
+	{"vfreq",	(char*)&vfreq, sizeof(int)},
+	{"height",	(char*)&height, sizeof(int)},
+	{"width",	(char*)&width, sizeof(int)},
+	{"linebytes",	(char*)&linebytes, sizeof(int)},
+	{"depth",	(char*)&depth, sizeof(int)},
+	{"reg",		(char*)&prop_tcx_regs[0], sizeof(prop_tcx_regs)},
+	{"tcx-8-bit",	0, -1},
+	{"intr",	(char*)&tcx_intr[0], sizeof(tcx_intr)},
+	{"interrupts",	(char*)&tcx_interrupts, sizeof(tcx_interrupts)},
+	{"device_type",	"display", sizeof("display")},
+	{NULL, NULL, -1}
+};
+
+static const int prop_cs4231_reg[] = {
+	0x3, 0x0C000000, 0x00000040
+};
+static const int cs4231_interrupts = 5;
+static const int cs4231_intr[] = { 5, 0 };
+
+static const struct property propv_sbus_cs4231[] = {
+	{"name",	"SUNW,CS4231", sizeof("SUNW,CS4231") },
+	{"intr",	(char*)&cs4231_intr[0], sizeof(cs4231_intr) },
+	{"interrupts",  (char*)&cs4231_interrupts, sizeof(cs4231_interrupts) },	
+	{"reg",		(char*)&prop_cs4231_reg[0], sizeof(prop_cs4231_reg) },
+	{"device_type", "serial", sizeof("serial") },
+	{"alias",	"audio", sizeof("audio") },
+	{NULL, NULL, -1}
+};
+
+static const int cpu_nctx = NCTX_SWIFT;
+static const int cpu_cache_line_size = 0x20;
+static const int cpu_cache_nlines = 0x200;
+static const struct property propv_cpu[] = {
+	{"name",	"STP1012PGA", sizeof("STP1012PGA") },
+	{"device_type",	"cpu", 4 },
+	{"mmu-nctx",	(char*)&cpu_nctx, sizeof(int)},
+	{"cache-line-size",	(char*)&cpu_cache_line_size, sizeof(int)},
+	{"cache-nlines",	(char*)&cpu_cache_nlines, sizeof(int)},
+	{NULL, NULL, -1}
+};
+
+static const int prop_obio_ranges[] = {
+	0x0, 0x0, 0x0, 0x71000000, 0x01000000,
+};
+static const struct property propv_obio[] = {
+	{"name",	"obio", 5 },
+	{"ranges",	(char*)&prop_obio_ranges[0], sizeof(prop_obio_ranges) },
+	{"device_type",	"hierarchical", sizeof("hierarchical") },
+	{NULL, NULL, -1}
+};
+
+static const int prop_auxio_reg[] = {
+	0x0, 0x00900000, 0x00000001,
+};
+static const struct property propv_obio_auxio[] = {
+	{"name",	"auxio", sizeof("auxio") },
+	{"reg",		(char*)&prop_auxio_reg[0], sizeof(prop_auxio_reg) },
+	{NULL, NULL, -1}
+};
+
+static const int prop_int_reg[] = {
+	0x0, 0x00e00000, 0x00000010,
+	0x0, 0x00e10000, 0x00000010,
+};
+static const struct property propv_obio_int[] = {
+	{"name",	"interrupt", sizeof("interrupt")},
+	{"reg",		(char*)&prop_int_reg[0], sizeof(prop_int_reg) },
+	{NULL, NULL, -1}
+};
+
+static const int prop_cnt_reg[] = {
+	0x0, 0x00d00000, 0x00000010,
+	0x0, 0x00d10000, 0x00000010,
+};
+static const struct property propv_obio_cnt[] = {
+	{"name",	"counter", sizeof("counter")},
+	{"reg",		(char*)&prop_cnt_reg[0], sizeof(prop_cnt_reg) },
+	{NULL, NULL, -1}
+};
+
+static const int prop_eeprom_reg[] = {
+	0x0, 0x00200000, 0x00002000,
+};
+static const struct property propv_obio_eep[] = {
+	{"name",	"eeprom", sizeof("eeprom")},
+	{"reg",		(char*)&prop_eeprom_reg[0], sizeof(prop_eeprom_reg) },
+	{"model",	"mk48t08", sizeof("mk48t08")},
+	{NULL, NULL, -1}
+};
+
+static const int prop_su_reg[] = {
+	0x0, 0x003002f8, 0x00000008,
+};
+static const struct property propv_obio_su[] = {
+	{"name",	"su", sizeof("su")},
+	{"reg",		(char*)&prop_su_reg[0], sizeof(prop_su_reg) },
+	{NULL, NULL, -1}
+};
+
+static const int prop_zs_intr[] = { 0x2c, 0x0 };
+static const int prop_zs_reg[] = {
+	0x0, 0x00000000, 0x00000008,
+};
+static void *prop_zs_addr;
+static const int prop_zs_slave = 1;
+static const struct property propv_obio_zs[] = {
+	{"name",	"zs", sizeof("zs")},
+	{"reg",		(char*)&prop_zs_reg[0], sizeof(prop_zs_reg) },
+	{"slave",	(char*)&prop_zs_slave, sizeof(prop_zs_slave) },
+	{"device_type", "serial", sizeof("serial") },
+	{"intr",	(char*)&prop_zs_intr[0], sizeof(prop_zs_intr) },
+	{"address",	(char*)&prop_zs_addr, sizeof(prop_zs_addr) },
+	{"keyboard",	(char*)&prop_true, 0},
+	{"mouse",	(char*)&prop_true, 0},
+	{NULL, NULL, -1}
+};
+
+static const int prop_zs1_intr[] = { 0x2c, 0x0 };
+static const int prop_zs1_reg[] = {
+	0x0, 0x00100000, 0x00000008,
+};
+static void *prop_zs1_addr;
+static const int prop_zs1_slave = 0;
+static const struct property propv_obio_zs1[] = {
+	{"name",	"zs", sizeof("zs")},
+	{"reg",		(char*)&prop_zs1_reg[0], sizeof(prop_zs1_reg) },
+	{"slave",	(char*)&prop_zs1_slave, sizeof(prop_zs1_slave) },
+	{"device_type", "serial", sizeof("serial") },
+	{"intr",	(char*)&prop_zs1_intr[0], sizeof(prop_zs1_intr) },
+	{"address",	(char*)&prop_zs1_addr, sizeof(prop_zs1_addr) },
+	{NULL, NULL, -1}
+};
+
+static const int prop_ledma_reg[] = {
+	0x4, 0x08400010, 0x00000020,
+};
+static const int prop_ledma_burst = 0x3f;
+static const struct property propv_sbus_ledma[] = {
+	{"name",	"ledma", sizeof("ledma")},
+	{"reg",		(char*)&prop_ledma_reg[0], sizeof(prop_ledma_reg) },
+	{"burst-sizes",	(char*)&prop_ledma_burst, sizeof(int) },
+	{NULL, NULL, -1}
+};
+
+static const int prop_le_reg[] = {
+	0x4, 0x08c00000, 0x00000004,
+};
+static const int prop_le_busmaster_regval = 0x7;
+static const int prop_le_intr[] = { 0x26, 0x0 };
+static const struct property propv_sbus_ledma_le[] = {
+	{"name",	"le", sizeof("le")},
+	{"reg",		(char*)&prop_le_reg[0], sizeof(prop_le_reg) },
+	{"busmaster-regval",	(char*)&prop_le_busmaster_regval, sizeof(int)},
+	{"intr",	(char*)&prop_le_intr[0], sizeof(prop_le_intr) },
+	{NULL, NULL, -1}
+};
+
+static const int prop_espdma_reg[] = {
+	0x4, 0x08400000, 0x00000010,
+};
+
+static const struct property propv_sbus_espdma[] = {
+	{"name",	"espdma", sizeof("espdma")}, 
+	{"reg",		(char*)&prop_espdma_reg[0], sizeof(prop_espdma_reg) },
+	{NULL, NULL, -1}
+};
+
+static const int prop_esp_reg[] = {
+	0x4, 0x08800000, 0x00000040,
+};
+static const int prop_esp_intr[] = { 0x24, 0x0 };
+static const struct property propv_sbus_espdma_esp[] = {
+	{"name",	"esp", sizeof("esp")},
+	{"reg",		(char*)&prop_esp_reg[0], sizeof(prop_esp_reg) },
+	{"intr",	(char*)&prop_esp_intr[0], sizeof(prop_esp_intr) },
+	{NULL, NULL, -1}
+};
+
+static const int prop_bpp_reg[] = {
+	0x4, 0x0c800000, 0x0000001c,
+};
+static const int prop_bpp_intr[] = { 0x33, 0x0 };
+static const struct property propv_sbus_bpp[] = {
+	{"name",	"SUNW,bpp", sizeof("SUNW,bpp")},
+	{"reg",		(char*)&prop_bpp_reg[0], sizeof(prop_bpp_reg) },
+	{"intr",	(char*)&prop_bpp_intr[0], sizeof(prop_bpp_intr) },
+	{NULL, NULL, -1}
+};
+
+static const int prop_apc_reg[] = {
+	0x4, 0x0a000000, 0x00000010,
+};
+static const struct property propv_sbus_apc[] = {
+	{"name",	"xxxpower-management", sizeof("xxxpower-management")},
+	{"reg",		(char*)&prop_apc_reg[0], sizeof(prop_apc_reg) },
+	{NULL, NULL, -1}
+};
+
+static const int prop_fd_intr[] = { 0x2b, 0x0 };
+static const int prop_fd_reg[] = {
+	0x0, 0x00400000, 0x0000000f,
+};
+static const struct property propv_obio_fd[] = {
+	{"name",	"SUNW,fdtwo", sizeof("SUNW,fdtwo")},
+	{"reg",		(char*)&prop_fd_reg[0], sizeof(prop_fd_reg) },
+	{"device_type", "block", sizeof("block") },
+	{"intr",	(char*)&prop_fd_intr[0], sizeof(prop_fd_intr) },
+	{NULL, NULL, -1}
+};
+
+static const int prop_pw_intr[] = { 0x22, 0x0 };
+static const int prop_pw_reg[] = {
+	0x0, 0x00910000, 0x00000001,
+};
+static const struct property propv_obio_pw[] = {
+	{"name",	"power", sizeof("power")},
+	{"reg",		(char*)&prop_pw_reg[0], sizeof(prop_pw_reg) },
+	{"intr",	(char*)&prop_pw_intr[0], sizeof(prop_pw_intr) },
+	{NULL, NULL, -1}
+};
+
+static const int prop_cf_reg[] = {
+	0x0, 0x00800000, 0x00000001,
+};
+static const struct property propv_obio_cf[] = {
+	{"name",	"slavioconfig", sizeof("slavioconfig")},
+	{"reg",		(char*)&prop_cf_reg[0], sizeof(prop_cf_reg) },
+	{NULL, NULL, -1}
+};
+
+static const struct property propv_options[] = {
+	{"name",	"options", sizeof("options")},
+	{"screen-#columns",	"80", sizeof("80")},
+	{"screen-#rows",	"25", sizeof("25")},
+	{"tpe-link-test?",	(char *)&prop_true, 0},
+	{"ttya-mode",		"9600,8,n,1,-", sizeof("9600,8,n,1,-")},
+	{"ttya-ignore-cd",	(char *)&prop_true, 0},
+	{"ttya-rts-dtr-off",	0, -1},
+	{"ttyb-mode",		"9600,8,n,1,-", sizeof("9600,8,n,1,-")},
+	{"ttyb-ignore-cd",	(char *)&prop_true, 0},
+	{"ttyb-rts-dtr-off",	0, -1},
+	{NULL, NULL, -1}
+};
+
+static int prop_mem_reg[3];
+static int prop_mem_avail[3];
+
+static const struct property propv_memory[] = {
+	{"name",	"memory", sizeof("memory")},
+	{"reg",		(char*)&prop_mem_reg[0], sizeof(prop_mem_reg) },
+	{"available",	(char*)&prop_mem_avail[0], sizeof(prop_mem_avail) },
+	{NULL, NULL, -1}
+};
+
+static int prop_vmem_avail[6];
+
+static const struct property propv_vmemory[] = {
+	{"name",	"virtual-memory", sizeof("virtual-memory")},
+	{"available",	(char*)&prop_vmem_avail[0], sizeof(prop_vmem_avail) },
+	{NULL, NULL, -1}
+};
+
+static const struct node nodes[] = {
+	{ &null_properties,	 1,  0 }, /* 0 = big brother of root */
+	{ propv_root,		 0,  2 }, /*  1 "/" */
+	{ propv_iommu,		12,  3 }, /*  2 "/iommu" */
+	{ propv_sbus,		 0,  4 }, /*  3 "/iommu/sbus" */
+	{ propv_sbus_tcx,	 5,  0 }, /*  4 "/iommu/sbus/SUNW,tcx" */
+	{ propv_sbus_ledma,	 7,  6 }, /*  5 "/iommu/sbus/ledma" */
+	{ propv_sbus_ledma_le,	 0,  0 }, /*  6 "/iommu/sbus/ledma/le" */
+	{ propv_sbus_cs4231,	 8,  0 }, /*  7 "/iommu/sbus/SUNW,CS4231 */
+	{ propv_sbus_bpp,	 9,  0 }, /*  8 "/iommu/sbus/SUNW,bpp */
+	{ propv_sbus_espdma,	11, 10 }, /*  9 "/iommu/sbus/espdma" */
+	{ propv_sbus_espdma_esp, 0,  0 }, /* 10 "/iommu/sbus/espdma/esp" */
+	{ propv_sbus_apc,	 0,  0 }, /* 11 "/iommu/sbus/power-management */
+	{ propv_cpu,		13,  0 }, /* 12 "/STP1012PGA" */
+	{ propv_obio,		23, 14 }, /* 13 "/obio" */
+	{ propv_obio_int,	15,  0 }, /* 14 "/obio/interrupt" */
+	{ propv_obio_cnt,	16,  0 }, /* 15 "/obio/counter" */
+	{ propv_obio_eep,	17,  0 }, /* 16 "/obio/eeprom" */
+	{ propv_obio_auxio,	18,  0 }, /* 17 "/obio/auxio" */
+	{ propv_obio_zs1,	19,  0 }, /* 18 "/obio/zs@0,100000"
+					     Must be before zs@0,0! */
+	{ propv_obio_zs,	20,  0 }, /* 19 "/obio/zs@0,0" */
+	{ propv_obio_fd,	21,  0 }, /* 20 "/obio/SUNW,fdtwo" */
+	{ propv_obio_pw,	22,  0 }, /* 21 "/obio/power" */
+	{ propv_obio_cf,	 0,  0 }, /* 22 "/obio/slavioconfig@0,800000" */
+	{ propv_options,	24,  0 }, /* 23 "/options" */
+	{ propv_memory,		25,  0 }, /* 24 "/memory" */
+	{ propv_vmemory,	 0,  0 }, /* 25 "/virtual-memory" */
+};
+
+static struct linux_mlist_v0 totphys[MAX_BANKS];
+static struct linux_mlist_v0 totmap[1];
+static struct linux_mlist_v0 totavail[MAX_BANKS];
+
+static struct linux_mlist_v0 *ptphys;
+static struct linux_mlist_v0 *ptmap;
+static struct linux_mlist_v0 *ptavail;
+
+static const struct linux_nodeops nodeops0 = {
+        obp_nextnode,	/* int (*no_nextnode)(int node); */
+        obp_child,	/* int (*no_child)(int node); */
+        obp_proplen,	/* int (*no_proplen)(int node, char *name); */
+        obp_getprop,	/* int (*no_getprop)(int node,char *name,char *val); */
+        obp_setprop,	/* int (*no_setprop)(int node, char *name,
+				 char *val, int len); */
+        obp_nextprop	/* char * (*no_nextprop)(int node, char *name); */
+};
+
+static struct linux_arguments_v0 obp_arg;
+static const struct linux_arguments_v0 * const obp_argp = &obp_arg;
+
+static void (*synch_hook)(void);
+static char obp_stdin, obp_stdout;
+static int obp_fd_stdin, obp_fd_stdout;
+
+static int obp_nbgetchar(void);
+static int obp_nbputchar(int ch);
+static void obp_reboot(char *);
+static void obp_abort(void);
+static void obp_halt(void);
+static int obp_devopen(char *str);
+static int obp_devclose(int dev_desc);
+static int obp_devread(int dev_desc, char *buf, int nbytes);
+static int obp_devwrite(int dev_desc, char *buf, int nbytes);
+static int obp_devseek(int dev_desc, int hi, int lo);
+static int obp_rdblkdev(int dev_desc, int num_blks, int blk_st, char *buf);
+static char *obp_dumb_mmap(char *va, int which_io, unsigned int pa, unsigned int size);
+static void obp_dumb_munmap(char *va, unsigned int size);
+static int obp_inst2pkg(int dev_desc);
+
+static void doublewalk(unsigned ptab1, unsigned va)
+{
+unsigned int proc_tablewalk(int ctx, unsigned int va);
+unsigned int mem_tablewalk(unsigned int pa, unsigned int va);
+
+	proc_tablewalk(0, va);
+	if (ptab1 != 0) mem_tablewalk(ptab1, va);
+}
+
+static struct linux_romvec romvec0;
+
+struct fd {
+    int unit, part;
+    int offset;
+    int (*pread)(int dev_desc, int offset, char *buf, unsigned int nbytes);
+    int (*pwrite)(int dev_desc, int offset, char *buf, unsigned int nbytes);
+} fd_table[16];
+
+static int fd_index;
+static int con_pread(int dev_desc, int offset, char *buf, unsigned int nbytes);
+static int con_pwrite(int dev_desc, int offset, char *buf, unsigned int nbytes);
+
+void *
+init_openprom_qemu(int bankc, struct bank *bankv, unsigned hiphybas,
+		   const char *cmdline, char boot_device, int nographic)
+{
+	int i;
+
+	/*
+	 * Avoid data segment allocations
+	 */
+	ptphys = totphys;
+	ptmap = totmap;
+	ptavail = totavail;
+	/*
+	 * Form memory descriptors.
+	 */
+	for (i = 0; i < bankc; i++) {
+		totphys[i].theres_more = &totphys[i+1];
+		totphys[i].start_adr = (char*) bankv[i].start;
+		totphys[i].num_bytes = bankv[i].length;
+	}
+	totphys[i-1].theres_more = 0;
+
+	/*
+	 * XXX Merged in normal PROM when full banks touch.
+	 */
+	for (i = 0; i < bankc; i++) {
+		unsigned bankbase = bankv[i].start;
+		unsigned banksize = bankv[i].length;
+		if (hiphybas > bankbase &&
+		    hiphybas < bankbase + banksize) {
+			banksize = hiphybas - bankbase;
+		}
+		totavail[i].theres_more = &totavail[i+1];
+		totavail[i].start_adr = (char*) bankbase;
+		totavail[i].num_bytes = banksize;
+	}
+	totavail[i-1].theres_more = 0;
+
+	totmap[0].theres_more = 0;
+	totmap[0].start_adr = (char*) PROLBASE;
+	totmap[0].num_bytes = PROLSIZE;
+	prop_mem_reg[0] = 0;
+	prop_mem_reg[1] = 0;
+	prop_mem_reg[2] = bankv[0].length;
+	prop_mem_avail[0] = 0;
+	prop_mem_avail[1] = 0;
+	prop_mem_avail[2] = hiphybas;
+	prop_vmem_avail[0] = 0;
+	prop_vmem_avail[1] = 0;
+	prop_vmem_avail[2] = PROLBASE-1;
+	prop_vmem_avail[3] = 0;
+	prop_vmem_avail[4] = 0xffe00000;
+	prop_vmem_avail[5] = 0x00200000;
+
+	/*
+	 * idprom
+	 */
+	bcopy(idprom, obp_idprom, IDPROM_SIZE);
+
+	// Linux wants a R/W romvec table
+	romvec0.pv_magic_cookie = LINUX_OPPROM_MAGIC;
+	romvec0.pv_romvers = 3;
+	romvec0.pv_plugin_revision = 77;
+	romvec0.pv_printrev = 0x10203;
+	romvec0.pv_v0mem.v0_totphys = &ptphys;
+	romvec0.pv_v0mem.v0_prommap = &ptmap;
+	romvec0.pv_v0mem.v0_available = &ptavail;
+	romvec0.pv_nodeops = &nodeops0;
+	romvec0.pv_bootstr = (void *)doublewalk;
+	romvec0.pv_v0devops.v0_devopen = &obp_devopen;
+	romvec0.pv_v0devops.v0_devclose = &obp_devclose;
+	romvec0.pv_v0devops.v0_rdblkdev = &obp_rdblkdev;
+	romvec0.pv_stdin = &obp_stdin;
+	romvec0.pv_stdout = &obp_stdout;
+	romvec0.pv_getchar = obp_nbgetchar;
+	romvec0.pv_putchar = (void (*)(int))obp_nbputchar;
+	romvec0.pv_nbgetchar = obp_nbgetchar;
+	romvec0.pv_nbputchar = obp_nbputchar;
+	romvec0.pv_reboot = obp_reboot;
+	romvec0.pv_printf = (void (*)(const char *fmt, ...))printk;
+	romvec0.pv_abort = obp_abort;
+	romvec0.pv_halt = obp_halt;
+	romvec0.pv_synchook = &synch_hook;
+	romvec0.pv_v0bootargs = &obp_argp;
+	romvec0.pv_v2devops.v2_inst2pkg = obp_inst2pkg;
+	romvec0.pv_v2devops.v2_dumb_mmap = obp_dumb_mmap;
+	romvec0.pv_v2devops.v2_dumb_munmap = obp_dumb_munmap;
+	romvec0.pv_v2devops.v2_dev_open = obp_devopen;
+	romvec0.pv_v2devops.v2_dev_close = (void (*)(int))obp_devclose;
+	romvec0.pv_v2devops.v2_dev_read = obp_devread;
+	romvec0.pv_v2devops.v2_dev_write = obp_devwrite;
+	romvec0.pv_v2devops.v2_dev_seek = obp_devseek;
+	obp_arg.boot_dev_ctrl = 0;
+	obp_arg.boot_dev_unit = '0';
+	obp_arg.argv[0] = "sd(0,0,0):d";
+	switch(boot_device) {
+	default:
+	case 'a':
+	    obp_arg.argv[0] = "fd()";
+	    obp_arg.boot_dev[0] = 'f';
+	    obp_arg.boot_dev[1] = 'd';
+	    break;
+	case 'd':
+	    obp_arg.boot_dev_unit = '2';
+	    obp_arg.argv[0] = "sd(0,2,0):d";
+	    // Fall through
+	case 'c':
+	    obp_arg.boot_dev[0] = 's';
+	    obp_arg.boot_dev[1] = 'd';
+	    break;
+	case 'n':
+	    obp_arg.argv[0] = "le()";
+	    obp_arg.boot_dev[0] = 'l';
+	    obp_arg.boot_dev[1] = 'e';
+	    break;
+	}
+	obp_arg.argv[1] = cmdline;
+	romvec0.pv_v2bootargs.bootpath = &obp_arg.argv[0];
+	romvec0.pv_v2bootargs.bootargs = &cmdline;
+	romvec0.pv_v2bootargs.fd_stdin = &obp_fd_stdin;
+	romvec0.pv_v2bootargs.fd_stdout = &obp_fd_stdout;
+
+	bcopy(propv_root_templ, propv_root, sizeof(propv_root_templ));
+	propv_root[4].name = "stdin-path";
+	propv_root[5].name = "stdout-path";
+	obp_fd_stdin = 0;
+	obp_fd_stdout = 1;
+	fd_table[0].pread = con_pread;
+	fd_table[0].pwrite = con_pwrite;
+	fd_table[1].pread = con_pread;
+	fd_table[1].pwrite = con_pwrite;
+	fd_index = 2;
+	if (nographic) {
+	    obp_stdin = PROMDEV_TTYA;
+	    propv_root[4].value = "/obio/zs@0,100000:a";
+	    propv_root[4].length = sizeof("/obio/zs@0,100000:a");
+	    fd_table[0].unit = 18;
+	    obp_stdout = PROMDEV_TTYA;
+	    propv_root[5].value = "/obio/zs@0,100000:a";
+	    propv_root[5].length = sizeof("/obio/zs@0,100000:a");
+	    fd_table[1].unit = 18;
+	} else {
+	    obp_stdin = PROMDEV_KBD;
+	    propv_root[4].value = "/obio/zs@0,0";
+	    propv_root[4].length = sizeof("/obio/zs@0,0");
+	    fd_table[0].unit = 19;
+	    obp_stdout = PROMDEV_SCREEN;
+	    propv_root[5].value = "/iommu/sbus/SUNW,tcx";
+	    propv_root[5].length = sizeof("/iommu/sbus/SUNW,tcx");
+	    fd_table[1].unit = 4;
+	}
+	prop_zs_addr = map_io(0x71000000, 8);
+	prop_zs1_addr = map_io(0x71100000, 8);
+	return &romvec0;
+}
+
+static const struct property *find_property(int node,char *name)
+{
+	const struct property *prop = &nodes[node].properties[0];
+	while (prop && prop->name) {
+		if (bcmp(prop->name, name, 128) == 0) return prop;
+		prop++;
+	}
+	return NULL;
+}
+
+static int obp_nextnode(int node)
+{
+#ifdef DEBUG_OBP
+        printk("obp_nextnode(%d) = %d\n", node, nodes[node].sibling);
+#endif
+	return nodes[node].sibling;
+}
+
+static int obp_child(int node)
+{
+#ifdef DEBUG_OBP
+        printk("obp_child(%d) = %d\n", node, nodes[node].child);
+#endif
+	return nodes[node].child;
+}
+
+static int obp_proplen(int node, char *name)
+{
+	const struct property *prop = find_property(node,name);
+	if (prop) {
+#ifdef DEBUG_OBP
+	    printk("obp_proplen(%d, %s) = %d\n", node, name, prop->length);
+#endif
+	    return prop->length;
+	}
+#ifdef DEBUG_OBP
+	printk("obp_proplen(%d, %s) (no prop)\n", node, name);
+#endif
+	return -1;
+}
+
+static int obp_getprop(int node, char *name, char *value)
+{
+	const struct property *prop;
+
+	if (!name) {
+	    // NULL name means get first property
+#ifdef DEBUG_OBP
+	    printk("obp_getprop(%d, %x (NULL)) = %s\n", node, name,
+		   nodes[node].properties[0].name);
+#endif
+	    return (int)nodes[node].properties[0].name;
+	}
+	prop = find_property(node,name);
+	if (prop) {
+		memcpy(value,prop->value,prop->length);
+#ifdef DEBUG_OBP
+		printk("obp_getprop(%d, %s) = %s\n", node, name, value);
+#endif
+		return prop->length;
+	}
+#ifdef DEBUG_OBP
+        printk("obp_getprop(%d, %s): not found\n", node, name);
+#endif
+	return -1;
+}
+
+static int obp_setprop(__attribute__((unused)) int node,
+		       __attribute__((unused)) char *name,
+		       __attribute__((unused)) char *value,
+		       __attribute__((unused)) int len)
+{
+#ifdef DEBUG_OBP
+        printk("obp_setprop(%d, %s) = %s (%d)\n", node, name, value, len);
+#endif
+	return -1;
+}
+
+static const char *obp_nextprop(int node,char *name)
+{
+	const struct property *prop;
+	
+	if (!name || *name == '\0') {
+	    // NULL name means get first property
+#ifdef DEBUG_OBP
+	    printk("obp_nextprop(%d, NULL) = %s\n", node,
+		   nodes[node].properties[0].name);
+#endif
+	    return nodes[node].properties[0].name;
+	}
+	prop = find_property(node,name);
+	if (prop && prop[1].name) {
+#ifdef DEBUG_OBP
+	    printk("obp_nextprop(%d, %s) = %s\n", node, name, prop[1].name);
+#endif
+	    return prop[1].name;
+	}
+#ifdef DEBUG_OBP
+        printk("obp_nextprop(%d, %s): not found\n", node, name);
+#endif
+	return "";
+}
+
+extern int (*getch_fn)(struct vconterm *v);
+
+static int obp_nbgetchar(void) {
+	extern struct vconterm dp0;
+	return getch_fn(&dp0);
+}
+
+static int obp_nbputchar(int ch) {
+	printk("%c", ch);
+	return 0;
+}
+
+static void obp_reboot(char *str) {
+	printk("rebooting (%s)\n", str);
+	stb_bypass(0x71f00000, 1);
+	for (;;) {}
+}
+
+static void obp_abort() {
+	printk("abort, power off\n");
+	stb_bypass(0x71910000, 1);
+	for (;;) {}
+}
+
+static void obp_halt() {
+	printk("halt, power off\n");
+	stb_bypass(0x71910000, 1);
+	for (;;) {}
+}
+
+extern void *esp_read(int unit, int part, int offset, short len);
+
+static int esp_pread(int dev_desc, int offset, char *buf, unsigned int nbytes)
+{
+    unsigned int i;
+    void *src;
+
+    for(i = 0; i < nbytes; i += 512) {
+	src = esp_read(fd_table[dev_desc].unit, fd_table[dev_desc].part, (offset + i) / 512, 512);
+	memcpy(&buf[i], src, 512);
+    }
+    return nbytes;
+}
+
+static int con_pread(__attribute__((unused)) int dev_desc, __attribute__((unused)) int offset, char *buf, unsigned int nbytes)
+{
+    unsigned int i;
+
+    for(i = 0; i < nbytes; i ++) {
+	buf[i] = obp_nbgetchar();
+    }
+    return nbytes;
+}
+
+static int con_pwrite(__attribute__((unused)) int dev_desc, __attribute__((unused)) int offset, char *buf, unsigned int nbytes)
+{
+    unsigned int i;
+
+    for(i = 0; i < nbytes; i ++) {
+	obp_nbputchar(buf[i]);
+    }
+    return nbytes;
+}
+
+#define isnum(c) ((c >= '0') && (c < '9'))
+#define ctoi(c) (c - '0')
+
+static int obp_devopen(char *str) {
+#ifdef DEBUG_OBP
+        printk("obp_devopen(%s)\n", str);
+#endif
+	if (str[0] == 's' && str[1] == 'd' && str[4] == ',') {
+	    unsigned int target;
+
+	    if (str[5] < 7)
+		target = str[5];
+	    else if (isnum(str[6]) && isnum(str[5])) {
+		target = (ctoi(str[5]) * 10 + ctoi(str[6])) & 7;
+	    }
+	    else {
+		target = ctoi(str[5]) & 7;
+	    }
+	    fd_table[fd_index].unit = target;
+	    fd_table[fd_index].part = str[10] - 'a';
+	    fd_table[fd_index].pread = esp_pread;
+	    return fd_index++; // XXX
+	}
+	return 0;
+}
+
+static int obp_devclose(__attribute__((unused)) int dev_desc) {
+#ifdef DEBUG_OBP
+        printk("obp_devclose %d\n", dev_desc);
+#endif
+	fd_index--; // XXX
+	return 0;
+}
+
+static int obp_rdblkdev(int dev_desc, int num_blks, int offset, char *buf)
+{
+#ifdef DEBUG_OBP
+    printk("obp_rdblkdev: fd %d, num_blks %d, offset %d, buf 0x%x\n", dev_desc, num_blks, offset, buf);
+#endif
+    return fd_table[dev_desc].pread(dev_desc, offset, buf, num_blks * 512);
+}
+
+static char *obp_dumb_mmap(char *va, __attribute__((unused)) int which_io,
+			   unsigned int pa, unsigned int size)
+{
+	unsigned int npages;
+	unsigned int off;
+	unsigned int mva;
+
+#ifdef DEBUG_OBP
+	printk("obp_dumb_mmap: virta %x, which_io %d, paddr %x, sz %d\n", va, which_io, pa, size);
+#endif
+	off = pa & (PAGE_SIZE-1);
+	npages = (off + size + (PAGE_SIZE-1)) / PAGE_SIZE;
+	pa &= ~(PAGE_SIZE-1);
+
+	mva = (unsigned int) va;
+	while (npages-- != 0) {
+		map_page(pmem.pl1, mva, pa, 1, pmem.pbas);
+		mva += PAGE_SIZE;
+		pa += PAGE_SIZE;
+	}
+	return va;
+}
+
+static void obp_dumb_munmap(__attribute__((unused)) char *va,
+			    __attribute__((unused)) unsigned int size)
+{
+#ifdef DEBUG_OBP
+	printk("obp_dumb_munmap: virta %x, sz %d\n", va, size);
+#endif
+}
+
+static int obp_devread(int dev_desc, char *buf, int nbytes)
+{
+	int ret;
+#ifdef DEBUG_OBP
+	printk("obp_devread: fd %d, nbytes %d\n", dev_desc, nbytes);
+#endif
+	ret = fd_table[dev_desc].pread(dev_desc, fd_table[dev_desc].offset, buf, nbytes);
+	fd_table[dev_desc].offset += nbytes;
+	return ret;
+}
+
+static int obp_devwrite(int dev_desc, char *buf, int nbytes)
+{
+	int ret;
+#ifdef DEBUG_OBP
+	printk("obp_devwrite: fd %d, buf %s, nbytes %d\n", dev_desc, buf, nbytes);
+#endif
+	ret = fd_table[dev_desc].pwrite(dev_desc, fd_table[dev_desc].offset, buf, nbytes);
+	fd_table[dev_desc].offset += nbytes;
+	return ret;
+}
+
+static int obp_devseek(int dev_desc, __attribute__((unused)) int hi, int lo)
+{
+#ifdef DEBUG_OBP
+	printk("obp_devseek: fd %d, hi %d, lo %d\n", dev_desc, hi, lo);
+#endif
+	fd_table[dev_desc].offset = lo;
+	return 0;
+}
+
+static int obp_inst2pkg(int dev_desc)
+{
+#ifdef DEBUG_OBP
+	printk("obp_inst2pkg: fd %d\n", dev_desc);
+#endif
+	return fd_table[dev_desc].unit;
+}
diff -ruN proll_18.orig/qemu/system_qemu.c proll-patch-15/qemu/system_qemu.c
--- proll_18.orig/qemu/system_qemu.c	1970-01-01 00:00:00.000000000 +0000
+++ proll-patch-15/qemu/system_qemu.c	2005-04-16 06:16:20.000000000 +0000
@@ -0,0 +1,430 @@
+/**
+ ** Proll (PROM replacement)
+ ** system.c: shared miscallenea.
+ ** Copyright 1999 Pete Zaitcev
+ ** This code is licensed under GNU General Public License.
+ **/
+#include <stdarg.h>
+#include <asi.h>
+#include <crs.h>
+#ifndef NULL
+#define	NULL ((void*)0)
+#endif
+
+#include "pgtsrmmu.h"
+
+#include "vconsole.h"
+#include <timer.h>		/* Local copy of 2.2 style include */
+#include <general.h>		/* __P() */
+#include <net.h>		/* init_net() */
+#include <romlib.h>		/* we are a provider for part of this. */
+#include <netpriv.h>		/* myipaddr */
+#include <arpa.h>
+#include <system.h>		/* our own prototypes */
+
+/*
+ * We export this.
+ */
+char idprom[IDPROM_SIZE];
+
+
+/*
+ * Create an I/O mapping to pa[size].
+ * Returns va of the mapping or 0 if unsuccessful.
+ */
+void *
+map_io(unsigned pa, int size)
+{
+	void *va;
+	unsigned int npages;
+	unsigned int off;
+	unsigned int mva;
+
+	off = pa & (PAGE_SIZE-1);
+	npages = (off + size + (PAGE_SIZE-1)) / PAGE_SIZE;
+	pa &= ~(PAGE_SIZE-1);
+
+	va = mem_alloc(&cio, npages*PAGE_SIZE, PAGE_SIZE);
+	if (va == 0) return va;
+
+	mva = (unsigned int) va;
+    /* printk("map_io: va 0x%x pa 0x%x off 0x%x npages %d\n", va, pa, off, npages); */ /* P3 */
+	while (npages-- != 0) {
+		map_page(pmem.pl1, mva, pa, 1, pmem.pbas);
+		mva += PAGE_SIZE;
+		pa += PAGE_SIZE;
+	}
+
+	return (void *)((unsigned int)va + off);
+}
+
+/*
+ * Tablewalk routine used for testing.
+ * Returns PTP/PTE.
+ */
+unsigned int
+proc_tablewalk(int ctx, unsigned int va)
+{
+	unsigned int pa1;
+
+	__asm__ __volatile__ ("lda [%1] %2, %0" :
+				"=r" (pa1) :
+				"r" (AC_M_CTPR), "i" (ASI_M_MMUREGS));
+	/* printk(" ctpr %x ctx %x\n", pa1, ctx); */ /* P3 */
+	pa1 <<= 4;
+	pa1 = ld_bypass(pa1 + (ctx << 2));
+	if ((pa1 & 0x03) == 0) goto invalid;
+	return mem_tablewalk((pa1 & 0xFFFFFFF0) << 4, va);
+
+invalid:
+	printk(" invalid %x\n", pa1);
+	return 0;
+}
+
+/*
+ * Walk the tables in memory, starting at physical address pa.
+ */
+unsigned int
+mem_tablewalk(unsigned int pa, unsigned int va)
+{
+	unsigned int pa1;
+
+	printk("pa %x va %x", pa, va);
+	pa1 = ld_bypass(pa + (((va&0xFF000000)>>24) << 2));
+	if ((pa1 & 0x03) == 0) goto invalid;
+	printk(" l1 %x", pa1);
+	pa1 <<= 4;    pa1 &= 0xFFFFFF00;
+	pa1 = ld_bypass(pa1 + (((va&0x00FC0000)>>18) << 2));
+	if ((pa1 & 0x03) == 0) goto invalid;
+	printk(" l2 %x", pa1);
+	pa1 <<= 4;    pa1 &= 0xFFFFFF00;
+	pa1 = ld_bypass(pa1 + (((va&0x0003F000)>>12) << 2));
+	if ((pa1 & 0x03) == 0) goto invalid;
+	printk(" l3 %x", pa1);
+	printk(" off %x\n", va&0x00000FFF);
+	return pa1;
+invalid:
+	printk(" invalid %x\n", pa1);
+	return 0;
+}
+
+/*
+ * Make CPU page tables.
+ * Returns pointer to context table.
+ * Here we ignore memory allocation errors which "should not happen"
+ * because we cannot print anything anyways if memory initialization fails.
+ */
+void makepages(struct phym *t, unsigned int highbase)
+{
+	unsigned int *ctp, *l1, pte;
+	int i;
+	unsigned int pa, va;
+
+	ctp = mem_zalloc(&cmem, NCTX_SWIFT*sizeof(int), NCTX_SWIFT*sizeof(int));
+	l1 = mem_zalloc(&cmem, 256*sizeof(int), 256*sizeof(int));
+
+	pte = SRMMU_ET_PTD | (((unsigned int)l1 - PROLBASE + highbase) >> 4);
+	for (i = 0; i < NCTX_SWIFT; i++) {
+		ctp[i] = pte;
+	}
+
+	pa = PROLBASE;
+	for (va = PROLBASE; va < PROLDATA; va += PAGE_SIZE) {
+	        map_page(l1, va, pa, 0, highbase);
+		pa += PAGE_SIZE;
+	}
+	pa = highbase + PROLDATA - PROLBASE;
+	for (va = PROLDATA; va < PROLBASE + PROLSIZE; va += PAGE_SIZE) {
+		map_page(l1, va, pa, 0, highbase);
+		pa += PAGE_SIZE;
+	}
+
+	/* We need to start from LOADBASE, but kernel wants PAGE_SIZE. */
+	pa = 0;
+	for (va = 0; va < LOWMEMSZ; va += PAGE_SIZE) {
+		map_page(l1, va, pa, 0, highbase);
+		pa += PAGE_SIZE;
+	}
+
+	t->pctp = ctp;
+	t->pl1 = l1;
+	t->pbas = highbase;
+}
+
+/*
+ * Create a memory mapping from va to epa in page table pgd.
+ * highbase is used for v2p translation.
+ */
+int
+map_page(unsigned int *pgd, unsigned int va,
+    unsigned int epa, int type, unsigned int highbase)
+{
+	unsigned int pte;
+	unsigned int *p;
+	unsigned int pa;
+
+	pte = pgd[((va)>>SRMMU_PGDIR_SHIFT) & (SRMMU_PTRS_PER_PGD-1)];
+	if ((pte & SRMMU_ET_MASK) == SRMMU_ET_INVALID) {
+		p = mem_zalloc(&cmem, SRMMU_PTRS_PER_PMD*sizeof(int),
+		    SRMMU_PTRS_PER_PMD*sizeof(int));
+		if (p == 0) goto drop;
+		pte = SRMMU_ET_PTD |
+		    (((unsigned int)p - PROLBASE + highbase) >> 4);
+		pgd[((va)>>SRMMU_PGDIR_SHIFT) & (SRMMU_PTRS_PER_PGD-1)] = pte;
+		/* barrier() */
+	}
+
+	pa = ((pte & 0xFFFFFFF0) << 4);
+	pa += (((va)>>SRMMU_PMD_SHIFT & (SRMMU_PTRS_PER_PMD-1)) << 2);
+	pte = ld_bypass(pa);
+	if ((pte & SRMMU_ET_MASK) == SRMMU_ET_INVALID) {
+		p = mem_zalloc(&cmem, SRMMU_PTRS_PER_PTE*sizeof(int),
+		    SRMMU_PTRS_PER_PTE*sizeof(int));
+		if (p == 0) goto drop;
+		pte = SRMMU_ET_PTD |
+		    (((unsigned int)p - PROLBASE + highbase) >> 4);
+		st_bypass(pa, pte);
+	}
+
+	pa = ((pte & 0xFFFFFFF0) << 4);
+	pa += (((va)>>PAGE_SHIFT & (SRMMU_PTRS_PER_PTE-1)) << 2);
+
+	pte = SRMMU_ET_PTE | ((epa & PAGE_MASK) >> 4);
+	if (type) {		/* I/O */
+		pte |= SRMMU_REF;
+		/* SRMMU cannot make Supervisor-only, but not exectutable */
+		pte |= SRMMU_PRIV;
+	} else {		/* memory */
+		pte |= SRMMU_REF|SRMMU_CACHE;
+		pte |= SRMMU_PRIV;		/* Supervisor only access */
+	}
+	st_bypass(pa, pte);
+	return 0;
+
+drop:
+	return -1;
+}
+
+/*
+ * Switch page tables.
+ */
+void
+init_mmu_swift(unsigned int ctp_phy)
+{
+	unsigned int addr;
+
+	/*
+	 * Flush cache
+	 */
+	for (addr = 0; addr < 0x2000; addr += 0x10) {
+		__asm__ __volatile__ ("sta %%g0, [%0] %1\n\t" : :
+		    "r" (addr), "i" (ASI_M_DATAC_TAG));
+		__asm__ __volatile__ ("sta %%g0, [%0] %1\n\t" : :
+		    "r" (addr<<1), "i" (ASI_M_TXTC_TAG));
+	}
+
+	/*
+	 * Switch ctx table
+	 */
+	ctp_phy >>= 4;
+	/* printk("done flushing, switching to %x\n", ctp_phy); */
+	__asm__ __volatile__ ("sta %0, [%1] %2\n\t" : :
+	    "r" (ctp_phy), "r" (AC_M_CTPR), "i" (ASI_M_MMUREGS));
+
+	/*
+	 * Flush old page table references
+	 */
+	__asm__ __volatile__ ("sta %%g0, [%0] %1\n\t" : :
+	    "r" (0x400), "i" (ASI_M_FLUSH_PROBE) : "memory");
+}
+
+/*
+ * add_timer, del_timer
+ * This should go into sched.c, but we have it split for different archs.
+ */
+struct timer_list_head {
+	struct timer_list *head, *tail;
+};
+
+static struct timer_list_head timers;		/* Anonymous heap of timers */
+
+void add_timer(struct timer_list *timer) {
+	struct timer_list *p;
+	if (timer->prev != NULL || timer->next != NULL) {
+		printk("bug: kernel timer added twice at 0x%x.\n",
+		    __builtin_return_address(0));
+		return;
+	}
+	if ((p = timers.tail) != NULL) {
+		timer->prev = p;
+		p->next = timer;
+		timers.tail = timer;
+	} else {
+		timers.head = timer;
+		timers.tail = timer;
+	}
+	return;
+}
+
+int del_timer(struct timer_list *timer) {
+	struct timer_list *p;
+	int ret;
+
+	if (timers.head == timer) timers.head = timer->next;
+	if (timers.tail == timer) timers.tail = timer->prev;
+	if ((p = timer->prev) != NULL) p->next = timer->next;
+	if ((p = timer->next) != NULL) p->prev = timer->prev;
+	ret = timer->next != 0 || timer->prev != 0;
+	timer->next = NULL;
+	timer->prev = NULL;
+	return ret;
+}
+
+void run_timers() {
+	struct timer_list *p;
+
+	p = timers.head;
+	while (p != NULL) {
+		if (p->expires < jiffies) {
+			del_timer(p);		/* XXX make nonstatic member */
+			(*p->function)(p->data);
+			p = timers.head;
+		} else {
+			p = p->next;
+		}
+	}
+}
+
+/*
+ * Allocate memory. This is reusable.
+ */
+void mem_init(struct mem *t, char *begin, char *limit)
+{
+	t->start = begin;
+	t->uplim = limit;
+	t->curp = begin;
+}
+
+void mem_fini(struct mem *t)
+{
+	t->curp = 0;
+}
+
+void *mem_alloc(struct mem *t, int size, int align)
+{
+	char *p;
+
+	p = (char *)((((unsigned int)t->curp) + (align-1)) & ~(align-1));
+	if (p >= t->uplim || p + size > t->uplim) return 0;
+	t->curp = p + size;
+	return p;
+}
+
+void *mem_zalloc(struct mem *t, int size, int align)
+{
+	char *p;
+
+	if ((p = mem_alloc(t, size, align)) != 0) memset(p, 0, size);
+	return p;
+}
+
+/*
+ * Library functions
+ */
+void *memset(void *s, int c, size_t len)
+{
+	void *p = s;
+
+	while (len--) {
+		*(char *)s = c;
+		s++;
+	}
+	return p;
+}
+
+void bcopy(const void *f, void *t, int len) {
+	while (len--) {
+		*(char *)t = *(char *)f;
+		f++;
+		t++;
+	}
+}
+
+/* Comparison is 7-bit */
+int bcmp(const void *s1, const void *s2, int len)
+{
+	int i;
+	char ch;
+
+	while (len--) {
+		ch = *(char *)s1;
+		i = ch - *(char *)s2;
+		s1++;
+		s2++;
+		if (i != 0)
+			return i;
+		if (ch == 0)
+			return 0;
+	}
+	return 0;
+}
+
+int strlen(const char *s) {
+	const char *p;
+	for (p = s; *p != 0; p++) { }
+	return p - s;
+}
+
+extern void *printk_fn;
+
+void printk(char *fmt, ...)
+{
+	struct prf_fp {
+		void *xfp;
+		void (*write)(void *, char *, int);
+	} prfa;
+	extern void prf(struct prf_fp *, char *fmt, va_list adx);
+	va_list x1;
+
+	va_start(x1, fmt);
+	prfa.xfp = &dp0;
+	prfa.write = printk_fn;
+	prf(&prfa, fmt, x1);
+	va_end(x1);
+}
+
+void fatal()
+{
+	printk("fatal.");
+loop: goto loop;
+}
+
+/*
+ * Get the highest bit number from the mask.
+ */
+int highc(int mask, int size)
+{
+	int m1;
+
+	m1 = 1 << size;
+	while (size != 0) {
+		size--;
+		m1 >>= 1;
+		if (m1 & mask) break;
+	}
+	return size;
+}
+
+/*
+ */
+unsigned int ld_bp_swap(unsigned int ptr) {
+	unsigned int n;
+	n = ld_bypass(ptr);
+	n = (n>>24 & 0xFF) | (n>>8 & 0xFF00) | ((n&0xFF00) << 8) | (n<<24);
+	return n;
+}
+
+void st_bp_swap(unsigned int ptr, unsigned int n) {
+	n = (n>>24 & 0xFF) | (n>>8 & 0xFF00) | ((n&0xFF00) << 8) | (n<<24);
+	st_bypass(ptr, n);
+};
diff -ruN proll_18.orig/src/arp.c proll-patch-15/src/arp.c
--- proll_18.orig/src/arp.c	2001-12-24 05:12:31.000000000 +0000
+++ proll-patch-15/src/arp.c	2005-08-14 10:10:11.000000000 +0000
@@ -45,7 +45,7 @@
 #endif
 static struct arp_cache arp_list[ARPNUM];	/* ARP address cache	*/
 static int next_arp;				/* next table entry	*/
-static t_ipaddr def_gw = IP_ANY;		/* default routing	*/
+static t_ipaddr def_gw;				/* default routing	*/
 
 
 
@@ -100,10 +100,7 @@
  * 
  * ARP receiver routine
  */
-static int arp_recv(buf, bufsize, addr)
-unsigned char *buf;
-int            bufsize;
-unsigned char *addr;
+static int arp_recv(unsigned char *buf, unsigned int bufsize, unsigned char *addr)
 {
   register struct arphdr *ahp = (struct arphdr *)buf;
 
@@ -144,7 +141,7 @@
  * 
  * Resolve IP address and return pointer to hardware address.
  */
-unsigned char *ip_resolve(ip)
+const unsigned char *ip_resolve(ip)
 t_ipaddr ip;
 {
   int i;
@@ -230,14 +227,11 @@
  */
 int init_arp()
 {
-  /* Set name of module for error messages */
-  net_module_name = "arp";
-
 #ifndef NOARP
   /* Register ARP packet type and set send buffer pointer */
   if ((arpbuf = (struct arphdr *)reg_type(htons(ETH_P_ARP), arp_recv)) == NULL)
 	return(FALSE);
 #endif
-
+  def_gw = IP_ANY;
   return(TRUE);
 }
diff -ruN proll_18.orig/src/arp.h proll-patch-15/src/arp.h
--- proll_18.orig/src/arp.h	1999-03-18 03:39:43.000000000 +0000
+++ proll-patch-15/src/arp.h	2004-11-13 15:50:49.000000000 +0000
@@ -104,7 +104,7 @@
 extern int init_arp __P((void));
 
 /* Resolve IP address and return pointer to hardware address */
-extern unsigned char *ip_resolve __P((t_ipaddr ip));
+extern const unsigned char *ip_resolve __P((t_ipaddr ip));
 
 /* Add a new antry to the ARP cache */
 extern void addcache __P((unsigned char *ha, t_ipaddr ip));
diff -ruN proll_18.orig/src/bootp.c proll-patch-15/src/bootp.c
--- proll_18.orig/src/bootp.c	1999-12-15 17:20:30.000000000 +0000
+++ proll-patch-15/src/bootp.c	2005-08-14 10:16:09.000000000 +0000
@@ -151,7 +151,7 @@
   while (TRUE) {
 	boot_xid = get_ticks() + random();
 	bootp_send();
-	i = udp_read((char *)(&boot_rec), BOOTP_REC_SIZE, timeout, CHR_ESC);
+	i = udp_read((char *)(&boot_rec), BOOTP_REC_SIZE, timeout);
 	if (i < 0) {				/* user pressed ESC */
 		printf("\nAborted\n");
 		return(1);
diff -ruN proll_18.orig/src/esp.c proll-patch-15/src/esp.c
--- proll_18.orig/src/esp.c	1970-01-01 00:00:00.000000000 +0000
+++ proll-patch-15/src/esp.c	2005-08-15 18:42:46.000000000 +0000
@@ -0,0 +1,305 @@
+#include <system.h>		/* == <asm/system.h> */
+#include <general.h>		/* __P for netpriv.h */
+#include <dma.h>		/* dmaga */
+#include <romlib.h>
+
+#define PHYS_JJ_ESPDMA  0x78400000      /* ESP DMA controller */
+#define PHYS_JJ_ESP     0x78800000      /* ESP SCSI */
+#define PHYS_JJ_ESP_IRQ    4
+#define BUFSIZE         4096
+/*
+ * XXX Crude
+ */
+struct esp_dma {
+	struct sparc_dma_registers *regs;
+	enum dvma_rev revision;
+};
+
+struct esp_regs {
+    unsigned int regs[16];
+};
+
+struct esp_private {
+	int active;			/* initialized */
+	int inst;			/* iface number */
+
+	volatile struct esp_regs *ll;
+	__u32 buffer_dvma;
+	unsigned int irq;		/* device IRQ number    */
+        int interrupt;
+
+	struct esp_dma *espdma;         /* If set this points to espdma    */
+
+        unsigned char *buffer;
+	struct disk_info {
+		unsigned int hw_sector;
+		unsigned int part_offset[8];
+	} disk[8];
+};
+
+static void esp_interrupt(void *dev_id)
+{
+	struct esp_private *lp = (struct esp_private *)dev_id;
+
+	lp->interrupt = 1;
+	/* Acknowledge all the interrupt sources ASAP */
+
+	lp->interrupt = 0;
+}
+
+static int esp_open (void *dev)
+{
+	struct esp_private *lp = (struct esp_private *)dev;
+	int status = 0;
+
+	if (request_irq(lp->irq, &esp_interrupt, (void *)dev)) {
+		printk ("Esp: Can't get irq %d\n", lp->irq);
+		return -1;
+	}
+
+	/* On the 4m, setup the espdma to provide the upper bits for buffers */
+	if (lp->espdma)
+		lp->espdma->regs->dma_test = ((__u32) lp->buffer_dvma) & 0xff000000;
+
+	return status;
+}
+
+static int esp_close (void *dev)
+{
+	struct esp_private *lp = (struct esp_private *)dev;
+
+	free_irq (lp->irq, (void *) dev);
+	return 0;
+}
+
+static int 
+esp_init(struct esp_private *esp, struct esp_dma *espdma, int irq)
+{
+	volatile struct esp_regs *ll;
+
+	/* Get the IO region */
+	ll = map_io(PHYS_JJ_ESP, sizeof (struct esp_regs));
+	if (ll == 0) return -1;
+
+	esp->buffer = dvma_alloc(BUFSIZE, &esp->buffer_dvma);
+	esp->ll = ll;
+	esp->espdma = espdma;
+	esp->irq = irq;
+
+	// Chip reset
+	stb_bypass((int)ll + 3*2, 2);
+	return 0;
+}
+
+static int espdma_init(struct esp_dma *espdma)
+{
+	void *p;
+
+	/* Hardcode everything for MrCoffee. */
+	if ((p = map_io(PHYS_JJ_ESPDMA, 0x10)) == 0) {
+		printk("espdma_init: cannot map registers\n");
+		return -1;
+	}
+	espdma->regs = p;
+
+	printk("dma1: ");
+
+	switch((espdma->regs->cond_reg)&DMA_DEVICE_ID) {
+	case DMA_VERS0:
+		espdma->revision=dvmarev0;
+		printk("Revision 0 ");
+		break;
+	case DMA_ESCV1:
+		espdma->revision=dvmaesc1;
+		printk("ESC Revision 1 ");
+		break;
+	case DMA_VERS1:
+		espdma->revision=dvmarev1;
+		printk("Revision 1 ");
+		break;
+	case DMA_VERS2:
+		espdma->revision=dvmarev2;
+		printk("Revision 2 ");
+		break;
+	case DMA_VERHME:
+		espdma->revision=dvmahme;
+		printk("HME DVMA gate array ");
+		break;
+	case DMA_VERSPLUS:
+		espdma->revision=dvmarevplus;
+		printk("Revision 1 PLUS ");
+		break;
+	default:
+		printk("unknown dma version %x",
+		       (espdma->regs->cond_reg)&DMA_DEVICE_ID);
+		/* espdma->allocated = 1; */
+		break;
+	}
+	printk("\n");
+	return 0;
+}
+
+static struct esp_dma espdma0;
+static struct esp_private esp;
+/*
+ * Find all the esp cards on the system and initialize them
+ */
+void esp_probe ()
+{
+	if (espdma_init(&espdma0) != 0) {
+		return;
+	}
+
+	if (esp_init(&esp, &espdma0, PHYS_JJ_ESP_IRQ) != 0) {
+		printk("esp_probe: esp0 init failed\n");
+		return;
+	}
+	return;
+}
+
+void esp_read_capacity(int unit)
+{
+	// Set SCSI target
+	stb_bypass(PHYS_JJ_ESP + 4*4, unit & 7);
+	// Set DMA address
+	st_bypass(PHYS_JJ_ESPDMA + 4, esp.buffer_dvma);
+	// Set DMA length
+	stb_bypass(PHYS_JJ_ESP + 0*4, 10);
+	stb_bypass(PHYS_JJ_ESP + 1*4, 0);
+	// Set DMA direction
+	st_bypass(PHYS_JJ_ESPDMA + 0, 0x000);
+	// Setup command = Read Capacity
+	esp.buffer[0] = 0x80;
+	esp.buffer[1] = 0x25;
+	esp.buffer[2] = 0x00;
+	esp.buffer[3] = 0x00;
+	esp.buffer[4] = 0x00;
+	esp.buffer[5] = 0x00;
+	esp.buffer[6] = 0x00;
+	esp.buffer[7] = 0x00;
+	esp.buffer[8] = 0x00;
+	esp.buffer[9] = 0x00;
+	esp.buffer[10] = 0x00;
+	// Set ATN, issue command
+	stb_bypass(PHYS_JJ_ESP + 3*4, 0xc2);
+
+	// Set DMA length = 512 * read length
+	stb_bypass(PHYS_JJ_ESP + 0*4, 0);
+	stb_bypass(PHYS_JJ_ESP + 1*4, 8 & 0xff);
+	// Set DMA direction
+	st_bypass(PHYS_JJ_ESPDMA + 0, 0x100);
+	// Transfer
+	stb_bypass(PHYS_JJ_ESP + 3*4, 0x90);
+	esp.disk[unit].hw_sector = (esp.buffer[4] << 24) | (esp.buffer[5] << 16) | (esp.buffer[6] << 8) | esp.buffer[7];
+}
+
+// offset is multiple of 512, len in bytes
+void *esp_read(int unit, int part, int offset, short len)
+{
+	int pos, hw_sect, sect_offset, spb;
+
+	// Set SCSI target
+	stb_bypass(PHYS_JJ_ESP + 4*4, unit & 7);
+	// Set DMA address
+	st_bypass(PHYS_JJ_ESPDMA + 4, esp.buffer_dvma);
+	// Set DMA length
+	stb_bypass(PHYS_JJ_ESP + 0*4, 10);
+	stb_bypass(PHYS_JJ_ESP + 1*4, 0);
+	// Set DMA direction
+	st_bypass(PHYS_JJ_ESPDMA + 0, 0x000);
+	hw_sect = esp.disk[unit].hw_sector;
+	offset += esp.disk[unit].part_offset[part];
+	spb = hw_sect / 512;
+	sect_offset = offset / spb;
+	pos = (offset - sect_offset * spb) * 512;
+	len /= 512;
+	//printk("Read unit %d, offset %d -> offset %d, pos %d, hw_sect %d\n", unit, offset, sect_offset, pos, hw_sect);
+	// Setup command = Read(10)
+	esp.buffer[0] = 0x80;
+	esp.buffer[1] = 0x28;
+	esp.buffer[2] = 0x00;
+	esp.buffer[3] = (sect_offset >> 24) & 0xff;
+	esp.buffer[4] = (sect_offset >> 16) & 0xff;
+	esp.buffer[5] = (sect_offset >> 8) & 0xff;
+	esp.buffer[6] = sect_offset & 0xff;
+	esp.buffer[7] = 0x00;
+	esp.buffer[8] = (len >> 8) & 0xff;
+	esp.buffer[9] = len & 0xff;
+	// Set ATN, issue command
+	stb_bypass(PHYS_JJ_ESP + 3*4, 0xc2);
+
+	// Set DMA length = sector size * read length
+	stb_bypass(PHYS_JJ_ESP + 0*4, (len * hw_sect) & 0xff);
+	stb_bypass(PHYS_JJ_ESP + 1*4, ((len * hw_sect) >> 8) & 0xff);
+	// Set DMA direction
+	st_bypass(PHYS_JJ_ESPDMA + 0, 0x100);
+	// Transfer
+	stb_bypass(PHYS_JJ_ESP + 3*4, 0x90);
+	return esp.buffer + pos;
+}
+
+// Sparc boot sequence can be found in SILO docs,
+// first-isofs/README.SILO_ISOFS
+int esp_boot(int unit)
+{
+        struct sun_disklabel {
+                unsigned char info[128];   /* Informative text string */
+                unsigned char spare0[14];
+                struct sun_info {
+                        unsigned char spare1;
+                        unsigned char id;
+                        unsigned char spare2;
+                        unsigned char flags;
+                } infos[8];
+                unsigned char spare[246];  /* Boot information etc. */
+                short rspeed;     /* Disk rotational speed */
+                short pcylcount;  /* Physical cylinder count */
+                short sparecyl;   /* extra sects per cylinder */
+                unsigned char spare2[4];   /* More magic... */
+                short ilfact;     /* Interleave factor */
+                short ncyl;       /* Data cylinder count */
+                short nacyl;      /* Alt. cylinder count */
+                short ntrks;      /* Tracks per cylinder */
+                short nsect;      /* Sectors per track */
+                unsigned char spare3[4];   /* Even more magic... */
+                struct sun_partition {
+                        int start_cylinder;
+                        int num_sectors;
+                } partitions[8];
+                short magic;      /* Magic number */
+                short csum;       /* Label xor'd checksum */
+        } *label;
+	unsigned int i, offset;
+	void *src, *dst;
+
+	printk("Loading partition table from target %d:\n", unit);
+	// Chip reset
+	stb_bypass(PHYS_JJ_ESP + 3*4, 2);
+
+	esp_open(&esp);
+	esp_read_capacity(unit);
+
+	label = esp_read(unit, 0, 0, 512);
+	printk("hw sector: %d, CHS: %d/%d/%d, partitions:\n", esp.disk[unit].hw_sector, 
+	       label->ncyl, label->ntrks, label->nsect);
+	for (i = 0; i < 8; i++) {
+	    printk("%c: %d + %d, id %x, flags %x\n", 'a' + i, label->partitions[i].start_cylinder,
+		   label->partitions[i].num_sectors, label->infos[i].id, label->infos[i].flags);
+	    esp.disk[unit].part_offset[i] = label->partitions[3].start_cylinder * label->ntrks * label->nsect;
+	}
+	offset = 1;
+	printk("booting sd(0,%d,0):d (offset %d)\n", unit, offset);
+	// Skip a.out header (0x20)
+	dst = (void *)0x4000;
+	src = esp_read(unit, 3, offset, 512);
+	src = (void *)((unsigned int) src + 0x20);
+	memcpy(dst, src, 512 - 0x20);
+	dst = (void *)0x4000 + 512 - 0x20;
+	for (i = 1; i < 7680/512; i++) {
+	    src = esp_read(unit, 3,  offset + i, 512);
+	    memcpy(dst, src, 512);
+	    dst += 512;
+	}
+	esp_close(&esp);
+	return 0;
+}
diff -ruN proll_18.orig/src/hconsole.c proll-patch-15/src/hconsole.c
--- proll_18.orig/src/hconsole.c	2002-07-23 05:52:48.000000000 +0000
+++ proll-patch-15/src/hconsole.c	2005-11-09 18:46:34.000000000 +0000
@@ -29,6 +29,10 @@
        struct raster r_master;	/* For a case of resize, whole fb */
        struct raster r_0;	/* malloc() erzatz */
 
+#ifdef QEMU
+extern unsigned int q_height, q_width;
+#endif
+
 int hcon_init(struct hconsole *t, unsigned int a0)
 {
 	struct raster *q, *r;
@@ -42,7 +46,11 @@
  	 * No probing sequence or argument passing, hardcode everything. XXX
 	 */
 	raster8_cons_a(q, 768, 1024, (char *)a0);
+#ifndef QEMU
 	raster_cons_2(r, q, 768-(24*11)-1, 1024-(8*80)-1, (24*11), (8*80));
+#else
+	raster_cons_2(r, q, 0, 0, q_height, q_width);
+#endif
 	t->r_ = r;
 	t->r0_ = q;
 	t->f_ = &f_master;
@@ -67,7 +75,7 @@
 	return 0;
 }
 
-void hcon_fini (struct hconsole *t)
+void hcon_fini (__attribute((unused)) struct hconsole *t)
 {
 	return;
 }
@@ -77,12 +85,12 @@
 {
 	struct rfont *f = t->f_;
 
-	if (sy < 0 || sy >= t->ydim_) return -1;
-	if (sx < 0 || sx >= t->xdim_) return -1;
+	if (sy < 0 || (unsigned)sy >= t->ydim_) return -1;
+	if (sx < 0 || (unsigned)sx >= t->xdim_) return -1;
 	if (height < 0) return -1;
-	if (sy + height > t->ydim_) height = t->ydim_ - sy;
+	if ((unsigned)sy + (unsigned)height > t->ydim_) height = t->ydim_ - sy;
 	if (width < 0) return -1;
-	if (sx + width > t->xdim_) width = t->xdim_ - sx;
+	if ((unsigned)sx + (unsigned)width > t->xdim_) width = t->xdim_ - sx;
 
 	/* XXX Clear with correct background color */
 	(*t->r_->clear_)(t->r_,
@@ -107,10 +115,10 @@
 	char c0 = c;
 	RC_color rfg, rbg;
 
-	if (y < 0 || y >= t->ydim_) return -1;
-	if (x < 0 || x >= t->xdim_) return -1;
+	if (y < 0 || (unsigned)y >= t->ydim_) return -1;
+	if (x < 0 || (unsigned)x >= t->xdim_) return -1;
 
-	if (t->curson_ && t->ypos_ == y && t->xpos_ == x) {
+	if (t->curson_ && t->ypos_ == (unsigned)y && t->xpos_ == (unsigned)x) {
 		rfg = t->bg_;    rbg = t->fg_;
 	} else {
 		rfg = t->fg_;    rbg = t->bg_;
@@ -126,9 +134,9 @@
 {	
 	struct rfont *f = t->f_;
 
-	if (y < 0 || y >= t->ydim_) return -1;
-	if (x < 0 || x >= t->xdim_) return -1;
-	if (x + count >= t->xdim_) count = t->xdim_ - x;
+	if (y < 0 || (unsigned)y >= t->ydim_) return -1;
+	if (x < 0 || (unsigned)x >= t->xdim_) return -1;
+	if ((unsigned)x + (unsigned)count >= t->xdim_) count = t->xdim_ - x;
 
 	(*t->r_->render_)(t->r_, y*f->height_, x*f->width_,
 			    s, count, t->bg_, t->fg_, f);
@@ -200,8 +208,8 @@
 
 	rc = 0;
 	if (dir == SM_UP) {
-		if (d < 0 || d >= t->ydim_) return -1;
-		if (b <= d || b > t->ydim_) return -1;
+		if (d < 0 || (unsigned)d >= t->ydim_) return -1;
+		if (b <= d || (unsigned)b > t->ydim_) return -1;
 		if (d + count >= b) count = b - d;
 		if (d + count >= b) count = b - d;
 		(*t->r_->yscroll_)(t->r_,
@@ -213,8 +221,8 @@
 				   count*f->height_, raster_qwidth(t->r_),
 				   t->bg_);
 	} else if (dir == SM_DOWN) {
-		if (d < 0 || d >= t->ydim_) return -1;
-		if (b <= d || b > t->ydim_) return -1;
+		if (d < 0 || (unsigned)d >= t->ydim_) return -1;
+		if (b <= d || (unsigned)b > t->ydim_) return -1;
 		if (d + count >= b) count = b - d;
 		(*t->r_->yscroll_)(t->r_,
 				     d*f->height_, 0,
diff -ruN proll_18.orig/src/hme.c proll-patch-15/src/hme.c
--- proll_18.orig/src/hme.c	2002-07-23 05:52:52.000000000 +0000
+++ proll-patch-15/src/hme.c	2005-04-16 06:16:20.000000000 +0000
@@ -655,10 +655,10 @@
 				    unsigned int flags,
 				    unsigned int addr)
 {
-	__asm__ __volatile__("
-	stwa	%3, [%0] %2
-	stwa	%4, [%1] %2
-"	: /* no outputs */
+	__asm__ __volatile__(
+	"stwa	%3, [%0] %2\n\t"
+	"stwa	%4, [%1] %2\n\t"
+	: /* no outputs */
 	: "r" (&rp->rx_addr), "r" (&rp->rx_flags),
 	  "i" (ASI_PL), "r" (addr), "r" (flags));
 }
@@ -667,10 +667,10 @@
 				    unsigned int flags,
 				    unsigned int addr)
 {
-	__asm__ __volatile__("
-	stwa	%3, [%0] %2
-	stwa	%4, [%1] %2
-"	: /* no outputs */
+	__asm__ __volatile__(
+	"stwa	%3, [%0] %2\n\t"
+	"stwa	%4, [%1] %2\n\t"
+	: /* no outputs */
 	: "r" (&tp->tx_addr), "r" (&tp->tx_flags),
 	  "i" (ASI_PL), "r" (addr), "r" (flags));
 }
@@ -2404,7 +2404,7 @@
 		TXD(("[%d]", elem));
 		this = &txbase[elem];
 #ifdef  __sparc_v9__
-		__asm__ __volatile__("lduwa [%1] %2, %0"
+		__asm__ __volatile__("lduwa [%1] %2, %0\n\t"
 				     : "=r" (flags)
 				     : "r" (&this->tx_flags), "i" (ASI_PL));
 #else
@@ -2447,7 +2447,7 @@
 	RXD(("RX<"));
 	this = &rxbase[elem];
 #ifdef  __sparc_v9__
-	__asm__ __volatile__("lduwa [%1] %2, %0"
+	__asm__ __volatile__("lduwa [%1] %2, %0\n\t"
 			     : "=r" (flags)
 			     : "r" (&this->rx_flags), "i" (ASI_PL));
 #else
@@ -2530,7 +2530,7 @@
 		elem = NEXT_RX(elem);
 		this = &rxbase[elem];
 #ifdef __sparc_v9__ 
-		__asm__ __volatile__("lduwa [%1] %2, %0"
+		__asm__ __volatile__("lduwa [%1] %2, %0\n\t"
 				     : "=r" (flags)
 				     : "r" (&this->rx_flags), "i" (ASI_PL));
 #else
diff -ruN proll_18.orig/src/iommu.c proll-patch-15/src/iommu.c
--- proll_18.orig/src/iommu.c	2002-07-23 05:52:49.000000000 +0000
+++ proll-patch-15/src/iommu.c	2005-08-14 10:08:17.000000000 +0000
@@ -36,7 +36,7 @@
 	unsigned int pa, ba;
 	unsigned int npages;
 	unsigned int mva, mpa;
-	int i;
+	unsigned int i;
 	unsigned int *iopte;
 
 	npages = (size + (PAGE_SIZE-1)) / PAGE_SIZE;
diff -ruN proll_18.orig/src/lat7_2.bm proll-patch-15/src/lat7_2.bm
--- proll_18.orig/src/lat7_2.bm	1999-02-27 05:48:54.000000000 +0000
+++ proll-patch-15/src/lat7_2.bm	2004-11-13 15:50:49.000000000 +0000
@@ -1,6 +1,6 @@
 #define lat7_2_width 128
 #define lat7_2_height 88
-static unsigned char lat7_2_bits[] = {
+static unsigned const char lat7_2_bits[] = {
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0xaa, 0x12, 0x1e, 0x0c, 0x02, 0x70, 0x18,
    0x22, 0x22, 0x18, 0x00, 0x00, 0x18, 0x18, 0xff, 0x18, 0x00, 0x12, 0x02,
diff -ruN proll_18.orig/src/lat7_2_swapped.bm proll-patch-15/src/lat7_2_swapped.bm
--- proll_18.orig/src/lat7_2_swapped.bm	1970-01-01 00:00:00.000000000 +0000
+++ proll-patch-15/src/lat7_2_swapped.bm	2004-11-13 15:50:49.000000000 +0000
@@ -0,0 +1,121 @@
+#define lat7_2_width 128
+#define lat7_2_height 88
+static unsigned const char lat7_2_bits[] = {
+   0x00, 0x00, 0x18, 0x3c, 0x7e, 0x3c, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 
+   0x55, 0x00, 0x2a, 0x00, 0x55, 0x00, 0x2a, 0x00, 0x55, 0x00, 0x00, 0x48, 
+   0x48, 0x78, 0x48, 0x5f, 0x04, 0x04, 0x04, 0x04, 0x00, 0x00, 0x78, 0x40, 
+   0x70, 0x40, 0x4f, 0x08, 0x0e, 0x08, 0x08, 0x00, 0x00, 0x30, 0x40, 0x40, 
+   0x40, 0x3e, 0x09, 0x0e, 0x0a, 0x09, 0x00, 0x00, 0x40, 0x40, 0x40, 0x40, 
+   0x7f, 0x08, 0x0e, 0x08, 0x08, 0x00, 0x00, 0x0e, 0x0a, 0x0e, 0x00, 0x00, 
+   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x7e, 0x18, 0x18, 0x00, 
+   0x7e, 0x00, 0x00, 0x00, 0x00, 0x44, 0x64, 0x54, 0x4c, 0x54, 0x10, 0x10, 
+   0x10, 0x1f, 0x00, 0x00, 0x44, 0x44, 0x44, 0x28, 0x1f, 0x04, 0x04, 0x04, 
+   0x04, 0x00, 0x00, 0x18, 0x18, 0x18, 0x18, 0xf8, 0x00, 0x00, 0x00, 0x00, 
+   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf8, 0x18, 0x18, 0x18, 0x18, 0x00, 
+   0x00, 0x00, 0x00, 0x00, 0x00, 0x1f, 0x18, 0x18, 0x18, 0x18, 0x00, 0x00, 
+   0x18, 0x18, 0x18, 0x18, 0x1f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 
+   0x18, 0x18, 0x18, 0xff, 0x18, 0x18, 0x18, 0x18, 0x00, 0x00, 0xff, 0x00, 
+   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 
+   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+   0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+   0x00, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+   0x00, 0x00, 0xff, 0x00, 0x00, 0x18, 0x18, 0x18, 0x18, 0x1f, 0x18, 0x18, 
+   0x18, 0x18, 0x00, 0x00, 0x18, 0x18, 0x18, 0x18, 0xf8, 0x18, 0x18, 0x18, 
+   0x18, 0x00, 0x00, 0x18, 0x18, 0x18, 0x18, 0xff, 0x00, 0x00, 0x00, 0x00, 
+   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0x18, 0x18, 0x18, 0x18, 0x00, 
+   0x00, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x00, 0x00, 
+   0x06, 0x0c, 0x18, 0x30, 0x18, 0x6c, 0x36, 0x18, 0x0c, 0x00, 0x00, 0x60, 
+   0x30, 0x18, 0x0c, 0x18, 0x36, 0x6c, 0x18, 0x30, 0x00, 0x00, 0x7f, 0x36, 
+   0x36, 0x36, 0x36, 0x36, 0x36, 0x00, 0x00, 0x00, 0x00, 0x02, 0x04, 0x7e, 
+   0x18, 0x7e, 0x20, 0x40, 0x00, 0x00, 0x00, 0x00, 0x1c, 0x36, 0x30, 0x78, 
+   0x30, 0x72, 0x7e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 
+   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x42, 
+   0x7e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+   0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x18, 0x18, 0x18, 0x00, 0x18, 0x00, 
+   0x00, 0x00, 0x00, 0x66, 0x66, 0x22, 0x44, 0x00, 0x00, 0x00, 0x00, 0x00, 
+   0x00, 0x00, 0x36, 0x7f, 0x36, 0x36, 0x36, 0x7f, 0x36, 0x00, 0x00, 0x00, 
+   0x00, 0x66, 0x3c, 0x66, 0x66, 0x66, 0x3c, 0x66, 0x00, 0x00, 0x00, 0x00, 
+   0x72, 0x56, 0x6c, 0x18, 0x36, 0x6a, 0x4e, 0x00, 0x00, 0x00, 0x00, 0x18, 
+   0x24, 0x28, 0x30, 0x4a, 0x44, 0x3a, 0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 
+   0x08, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0c, 0x18, 0x18, 
+   0x18, 0x18, 0x18, 0x0c, 0x00, 0x00, 0x00, 0x00, 0x30, 0x18, 0x18, 0x18, 
+   0x18, 0x18, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x66, 0x3c, 0x7e, 0x3c, 
+   0x66, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x7e, 0x18, 0x18, 
+   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 
+   0x08, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7e, 0x00, 0x00, 0x00, 0x00, 
+   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x00, 0x00, 
+   0x00, 0x00, 0x02, 0x06, 0x0c, 0x18, 0x30, 0x60, 0x40, 0x00, 0x00, 0x00, 
+   0x00, 0x3c, 0x46, 0x4e, 0x5a, 0x72, 0x62, 0x3c, 0x00, 0x00, 0x00, 0x00, 
+   0x18, 0x38, 0x58, 0x18, 0x18, 0x18, 0x3c, 0x00, 0x00, 0x00, 0x00, 0x3c, 
+   0x66, 0x06, 0x0c, 0x18, 0x32, 0x7e, 0x00, 0x00, 0x00, 0x00, 0x3c, 0x66, 
+   0x06, 0x1c, 0x06, 0x66, 0x3c, 0x00, 0x00, 0x00, 0x00, 0x0c, 0x18, 0x30, 
+   0x66, 0x7e, 0x06, 0x06, 0x00, 0x00, 0x00, 0x00, 0x7e, 0x60, 0x7c, 0x66, 
+   0x06, 0x66, 0x3c, 0x00, 0x00, 0x00, 0x00, 0x3c, 0x60, 0x7c, 0x66, 0x66, 
+   0x66, 0x3c, 0x00, 0x00, 0x00, 0x00, 0x7e, 0x46, 0x06, 0x0c, 0x18, 0x30, 
+   0x30, 0x00, 0x00, 0x00, 0x00, 0x3c, 0x66, 0x66, 0x3c, 0x66, 0x66, 0x3c, 
+   0x00, 0x00, 0x00, 0x00, 0x3c, 0x66, 0x66, 0x66, 0x3e, 0x06, 0x3c, 0x00, 
+   0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x00, 0x18, 0x18, 0x00, 0x00, 
+   0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x00, 0x18, 0x18, 0x08, 0x10, 0x00, 
+   0x00, 0x0c, 0x18, 0x30, 0x60, 0x30, 0x18, 0x0c, 0x00, 0x00, 0x00, 0x00, 
+   0x00, 0x00, 0x7e, 0x00, 0x7e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 
+   0x18, 0x0c, 0x06, 0x0c, 0x18, 0x30, 0x00, 0x00, 0x00, 0x00, 0x3c, 0x66, 
+   0x06, 0x0c, 0x18, 0x00, 0x18, 0x00, 0x00, 0x00, 0x00, 0x3c, 0x42, 0x5e, 
+   0x56, 0x5e, 0x40, 0x3c, 0x00, 0x00, 0x00, 0x00, 0x18, 0x3c, 0x66, 0x66, 
+   0x7e, 0x66, 0x66, 0x00, 0x00, 0x00, 0x00, 0x7c, 0x66, 0x66, 0x7c, 0x66, 
+   0x66, 0x7c, 0x00, 0x00, 0x00, 0x00, 0x3c, 0x66, 0x60, 0x60, 0x60, 0x66, 
+   0x3c, 0x00, 0x00, 0x00, 0x00, 0x7c, 0x66, 0x66, 0x66, 0x66, 0x66, 0x7c, 
+   0x00, 0x00, 0x00, 0x00, 0x7e, 0x62, 0x60, 0x78, 0x60, 0x62, 0x7e, 0x00, 
+   0x00, 0x00, 0x00, 0x7e, 0x62, 0x60, 0x78, 0x60, 0x60, 0x60, 0x00, 0x00, 
+   0x00, 0x00, 0x3c, 0x66, 0x60, 0x6e, 0x66, 0x66, 0x3e, 0x00, 0x00, 0x00, 
+   0x00, 0x66, 0x66, 0x66, 0x7e, 0x66, 0x66, 0x66, 0x00, 0x00, 0x00, 0x00, 
+   0x3c, 0x18, 0x18, 0x18, 0x18, 0x18, 0x3c, 0x00, 0x00, 0x00, 0x00, 0x7e, 
+   0x46, 0x06, 0x06, 0x06, 0x66, 0x3c, 0x00, 0x00, 0x00, 0x00, 0x66, 0x6c, 
+   0x78, 0x70, 0x78, 0x6c, 0x66, 0x00, 0x00, 0x00, 0x00, 0x60, 0x60, 0x60, 
+   0x60, 0x60, 0x62, 0x7e, 0x00, 0x00, 0x00, 0x00, 0x41, 0x63, 0x77, 0x7f, 
+   0x6b, 0x63, 0x63, 0x00, 0x00, 0x00, 0x00, 0x66, 0x66, 0x76, 0x7e, 0x6e, 
+   0x66, 0x66, 0x00, 0x00, 0x00, 0x00, 0x3c, 0x66, 0x66, 0x66, 0x66, 0x66, 
+   0x3c, 0x00, 0x00, 0x00, 0x00, 0x7c, 0x66, 0x66, 0x66, 0x7c, 0x60, 0x60, 
+   0x00, 0x00, 0x00, 0x00, 0x3c, 0x66, 0x66, 0x66, 0x66, 0x6e, 0x3c, 0x02, 
+   0x00, 0x00, 0x00, 0x7c, 0x66, 0x66, 0x66, 0x7c, 0x6c, 0x66, 0x00, 0x00, 
+   0x00, 0x00, 0x3c, 0x66, 0x60, 0x3c, 0x06, 0x66, 0x3c, 0x00, 0x00, 0x00, 
+   0x00, 0x7e, 0x5a, 0x18, 0x18, 0x18, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00, 
+   0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x3c, 0x00, 0x00, 0x00, 0x00, 0x66, 
+   0x66, 0x66, 0x66, 0x66, 0x3c, 0x18, 0x00, 0x00, 0x00, 0x00, 0x63, 0x63, 
+   0x63, 0x6b, 0x6b, 0x7f, 0x36, 0x00, 0x00, 0x00, 0x00, 0x66, 0x66, 0x3c, 
+   0x18, 0x3c, 0x66, 0x66, 0x00, 0x00, 0x00, 0x00, 0x66, 0x66, 0x66, 0x3c, 
+   0x18, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00, 0x7e, 0x46, 0x0c, 0x18, 0x30, 
+   0x62, 0x7e, 0x00, 0x00, 0x00, 0x00, 0x3c, 0x30, 0x30, 0x30, 0x30, 0x30, 
+   0x3c, 0x00, 0x00, 0x00, 0x00, 0x40, 0x60, 0x30, 0x18, 0x0c, 0x06, 0x02, 
+   0x00, 0x00, 0x00, 0x00, 0x3c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x3c, 0x00, 
+   0x00, 0x00, 0x00, 0x18, 0x3c, 0x66, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7e, 0x00, 0x00, 0x00, 
+   0x00, 0x08, 0x10, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+   0x00, 0x3c, 0x06, 0x3e, 0x66, 0x66, 0x3e, 0x00, 0x00, 0x00, 0x00, 0x60, 
+   0x60, 0x60, 0x7c, 0x66, 0x66, 0x7c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+   0x3c, 0x66, 0x60, 0x66, 0x3c, 0x00, 0x00, 0x00, 0x00, 0x06, 0x06, 0x06, 
+   0x3e, 0x66, 0x66, 0x3e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3c, 0x66, 
+   0x7e, 0x60, 0x3c, 0x00, 0x00, 0x00, 0x00, 0x1c, 0x36, 0x30, 0x30, 0x78, 
+   0x30, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3e, 0x66, 0x66, 0x66, 
+   0x3e, 0x06, 0x3c, 0x00, 0x00, 0x60, 0x60, 0x60, 0x7c, 0x66, 0x66, 0x66, 
+   0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x00, 0x18, 0x18, 0x18, 0x1c, 0x00, 
+   0x00, 0x00, 0x00, 0x0c, 0x0c, 0x00, 0x0c, 0x0c, 0x0c, 0x0c, 0x6c, 0x38, 
+   0x00, 0x00, 0x60, 0x60, 0x66, 0x6c, 0x78, 0x7c, 0x66, 0x00, 0x00, 0x00, 
+   0x00, 0x60, 0x30, 0x30, 0x30, 0x30, 0x36, 0x1c, 0x00, 0x00, 0x00, 0x00, 
+   0x00, 0x00, 0x76, 0x7f, 0x6b, 0x6b, 0x6b, 0x00, 0x00, 0x00, 0x00, 0x00, 
+   0x00, 0x6c, 0x76, 0x66, 0x66, 0x66, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+   0x3c, 0x66, 0x66, 0x66, 0x3c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7c, 
+   0x66, 0x66, 0x66, 0x7c, 0x60, 0x60, 0x00, 0x00, 0x00, 0x00, 0x3e, 0x66, 
+   0x66, 0x66, 0x3e, 0x06, 0x06, 0x00, 0x00, 0x00, 0x00, 0x6e, 0x72, 0x60, 
+   0x60, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3c, 0x60, 0x3c, 0x06, 
+   0x3c, 0x00, 0x00, 0x00, 0x00, 0x30, 0x30, 0x78, 0x30, 0x30, 0x36, 0x1c, 
+   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x66, 0x66, 0x66, 0x66, 0x3a, 0x00, 
+   0x00, 0x00, 0x00, 0x00, 0x00, 0x66, 0x66, 0x66, 0x3c, 0x18, 0x00, 0x00, 
+   0x00, 0x00, 0x00, 0x00, 0x63, 0x6b, 0x6b, 0x6b, 0x36, 0x00, 0x00, 0x00, 
+   0x00, 0x00, 0x00, 0x66, 0x3c, 0x18, 0x3c, 0x66, 0x00, 0x00, 0x00, 0x00, 
+   0x00, 0x00, 0x66, 0x66, 0x66, 0x66, 0x3e, 0x06, 0x3c, 0x00, 0x00, 0x00, 
+   0x00, 0x7e, 0x0c, 0x18, 0x30, 0x7e, 0x00, 0x00, 0x00, 0x00, 0x0c, 0x18, 
+   0x18, 0x30, 0x18, 0x18, 0x0c, 0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x18, 
+   0x18, 0x18, 0x18, 0x18, 0x18, 0x00, 0x00, 0x00, 0x30, 0x18, 0x18, 0x0c, 
+   0x18, 0x18, 0x30, 0x00, 0x00, 0x00, 0x00, 0x36, 0x6c, 0x00, 0x00, 0x00, 
+   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7e, 0x42, 0x00, 0x00, 0x00, 0x00, 
+   0x00, 0x00, 0x00, 0x00};
diff -ruN proll_18.orig/src/le.c proll-patch-15/src/le.c
--- proll_18.orig/src/le.c	2002-07-23 05:52:49.000000000 +0000
+++ proll-patch-15/src/le.c	2005-04-16 06:16:20.000000000 +0000
@@ -185,8 +185,6 @@
 	unsigned short rap;			/* register address port */
 };
 
-int sparc_lance_debug = 2;
-
 /* The Lance uses 24 bit addresses */
 /* On the Sun4c the DVMA will provide the remaining bytes for us */
 /* On the Sun4m we have to instruct the ledma to provide them    */
@@ -771,7 +769,7 @@
 	/* Clear the slack of the packet, do I need this? */
 	/* For a firewall its a good idea - AC */
 	if (len != skblen)
-		bzero((char *) &ib->tx_buf [entry][skblen], len - skblen);
+		memset((char *) &ib->tx_buf [entry][skblen], 0, len - skblen);
     
 	/* Now, give the packet to the lance */
 	ib->btx_ring [entry].tmd1_bits = (LE_T1_POK|LE_T1_OWN);
diff -ruN proll_18.orig/src/net.h proll-patch-15/src/net.h
--- proll_18.orig/src/net.h	1999-12-15 17:20:17.000000000 +0000
+++ proll-patch-15/src/net.h	2005-08-14 10:17:02.000000000 +0000
@@ -124,7 +124,7 @@
 extern int udp_open __P((t_ipaddr daddr, int source, int dest));
 
 /* Read from a UDP socket */
-extern int udp_read __P((char *buf, int bufsize, int timeout, char abortch));
+extern int udp_read(char *buf, unsigned int bufsize, int timeout);
 
 /* Write to a UDP socket */
 extern int udp_write __P((char *buf, int writelen));
diff -ruN proll_18.orig/src/netinit.c proll-patch-15/src/netinit.c
--- proll_18.orig/src/netinit.c	2002-09-13 21:53:33.000000000 +0000
+++ proll-patch-15/src/netinit.c	2004-11-13 15:50:49.000000000 +0000
@@ -49,13 +49,20 @@
 unsigned char     myhwaddr[ETH_ALEN];		/* my own hardware addr	*/
          t_ipaddr myipaddr;			/* my own IP address	*/
          t_ipaddr mynetmask;			/* my own netmask	*/
-         char    *net_module_name;		/* name of init module	*/
          t_ipaddr servaddr;			/* IP of RARP&TFTP server */
 
 /* Broadcast hardware address */
-unsigned char bcasthw[ETH_ALEN] = { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff };
+const unsigned char bcasthw[ETH_ALEN] = { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff };
 
 
+unsigned int seed;
+
+/* This is taken from x86 to be used in network kernel. Returns 15 bits. */
+short int random()
+{
+	seed = (seed + 23968)*0x015A4E35 >> 1;
+	return seed & 0x7FFF;
+}
 
 /*
  **************************************************************************
@@ -104,10 +111,17 @@
  */
 void init_net()
 {
+  /* Avoid data segment allocations */
+  seed = 151;
+
   /* Initialize the different network layer modules */
   init_packet();
-  if (!init_arp() || !init_udp()) {
-	printf("\nERROR: init_%s\n", net_module_name);
+  if (!init_arp()) {
+	printf("\nERROR: init_arp\n");
+	fatal();
+  }
+  if (!init_udp()) {
+	printf("\nERROR: init_udp\n");
 	fatal();
   }
 }
diff -ruN proll_18.orig/src/netpriv.h proll-patch-15/src/netpriv.h
--- proll_18.orig/src/netpriv.h	1999-04-27 05:39:37.000000000 +0000
+++ proll-patch-15/src/netpriv.h	2005-08-14 10:12:20.000000000 +0000
@@ -83,7 +83,7 @@
 	 */
 	struct device *dev;
 	char *data;
-	int len;
+	unsigned int len;
 	int protocol;
 	unsigned char ip_summed;
 };
@@ -130,10 +130,9 @@
  *
  */
 extern unsigned char myhwaddr[ETH_ALEN]; /* my own hardware address	*/
-extern unsigned char bcasthw[ETH_ALEN];  /* broadcast hardware addr	*/
+extern const unsigned char bcasthw[ETH_ALEN];  /* broadcast hardware addr	*/
 extern t_ipaddr      myipaddr;           /* my own IP address		*/
 extern t_ipaddr      mynetmask;		 /* netmask for my network	*/
-extern char         *net_module_name;	 /* initialized module's name	*/
 extern t_ipaddr      servaddr;           /* server IP address		*/
 
 
@@ -150,7 +149,7 @@
 extern unsigned char *reg_type __P((int typeval, int (* receive)()));
 
 /* Write a packet to the network */
-extern int write_packet __P((int bufsize, int typeval, unsigned char *addr));
+extern int write_packet __P((int bufsize, int typeval, const unsigned char *addr));
 
 /* Empty read buffer */
 extern void empty_buf __P((void));
diff -ruN proll_18.orig/src/openprom.h proll-patch-15/src/openprom.h
--- proll_18.orig/src/openprom.h	2002-07-14 02:26:30.000000000 +0000
+++ proll-patch-15/src/openprom.h	2005-05-13 16:23:14.000000000 +0000
@@ -54,29 +54,29 @@
 };
 
 struct linux_mem_v0 {
-	struct linux_mlist_v0 **v0_totphys;
-	struct linux_mlist_v0 **v0_prommap;
-	struct linux_mlist_v0 **v0_available; /* What we can use */
+	struct linux_mlist_v0 * const *v0_totphys;
+	struct linux_mlist_v0 * const *v0_prommap;
+	struct linux_mlist_v0 * const *v0_available; /* What we can use */
 };
 
 /* Arguments sent to the kernel from the boot prompt. */
 struct linux_arguments_v0 {
-	char *argv[8];
+	const char *argv[8];
 	char args[100];
 	char boot_dev[2];
 	int boot_dev_ctrl;
 	int boot_dev_unit;
 	int dev_partition;
-	char *kernel_file_name;
+	const char *kernel_file_name;
 	void *aieee1;           /* XXX */
 };
 
 /* V2 and up boot things. */
 struct linux_bootargs_v2 {
-	char **bootpath;
-	char **bootargs;
-	int *fd_stdin;
-	int *fd_stdout;
+	const char **bootpath;
+	const char **bootargs;
+	const int *fd_stdin;
+	const int *fd_stdout;
 };
 
 /* The top level PROM vector. */
@@ -91,13 +91,13 @@
 	struct linux_mem_v0 pv_v0mem;
 
 	/* Node operations. */
-	struct linux_nodeops *pv_nodeops;
+	const struct linux_nodeops *pv_nodeops;
 
 	char **pv_bootstr;
 	struct linux_dev_v0_funcs pv_v0devops;
 
-	char *pv_stdin;
-	char *pv_stdout;
+	const char *pv_stdin;
+	const char *pv_stdout;
 #define	PROMDEV_KBD	0		/* input from keyboard */
 #define	PROMDEV_SCREEN	0		/* output to screen */
 #define	PROMDEV_TTYA	1		/* in/out to ttya */
@@ -127,7 +127,7 @@
 		void (*v2_eval)(char *str);
 	} pv_fortheval;
 
-	struct linux_arguments_v0 **pv_v0bootargs;
+	const struct linux_arguments_v0 * const *pv_v0bootargs;
 
 	/* Get ether address. */
 	unsigned int (*pv_enaddr)(int d, char *enaddr);
@@ -175,7 +175,7 @@
 	int (*no_proplen)(int node, char *name);
 	int (*no_getprop)(int node, char *name, char *val);
 	int (*no_setprop)(int node, char *name, char *val, int len);
-	char * (*no_nextprop)(int node, char *name);
+	const char * (*no_nextprop)(int node, char *name);
 };
 
 /* More fun PROM structures for device probing. */
diff -ruN proll_18.orig/src/packet.c proll-patch-15/src/packet.c
--- proll_18.orig/src/packet.c	2000-02-11 04:56:45.000000000 +0000
+++ proll-patch-15/src/packet.c	2005-08-14 10:12:49.000000000 +0000
@@ -41,7 +41,7 @@
 	int aligner;
 } wbuf;
 static struct sk_buff *rskb;
-static int nqskb = 0;
+static int nqskb;
 
 
 void init_packet()
@@ -62,6 +62,8 @@
 	for (i = 0; i < MAXSKBS; i++) {
 		skev[i].skb.allocn = i;
 	}
+
+	nqskb = 0;
 }
 
 unsigned char *reg_type(int ptype, int (*func)())
@@ -81,7 +83,7 @@
 	return wbuf.s;
 }
 
-int write_packet(int leng, int type, unsigned char *dst)
+int write_packet(int leng, int type, const unsigned char *dst)
 {
 	struct sk_buff *skb;
 	unsigned char *s;
@@ -209,12 +211,12 @@
 /*
  */
 void
-eth_copy_and_sum(struct sk_buff *dest, unsigned char *src, int len, int base)
+eth_copy_and_sum(struct sk_buff *dest, unsigned char *src, int len, __attribute__((unused)) int base)
 {
 	bcopy(src, dest->data, len);
 }
 
-unsigned short eth_type_trans(struct sk_buff *skb, struct device *dev)
+unsigned short eth_type_trans(struct sk_buff *skb, __attribute__((unused)) struct device *dev)
 {
 	unsigned char *s = skb->data + 12;
 	return s[0] << 8 | s[1];		/* Network order word */
diff -ruN proll_18.orig/src/printf.c proll-patch-15/src/printf.c
--- proll_18.orig/src/printf.c	1999-03-19 07:03:59.000000000 +0000
+++ proll-patch-15/src/printf.c	2005-08-14 10:07:26.000000000 +0000
@@ -19,7 +19,7 @@
 static void printn(struct prf_fp *, unsigned long, unsigned int);
 static void putchar(char, struct prf_fp *);
 
-static char hextab[] = "0123456789ABCDEF";
+static const char hextab[] = "0123456789ABCDEF";
 
 /*
  * Scaled down version of C Library printf.
@@ -41,7 +41,7 @@
 void
 prf(struct prf_fp *filog, char *fmt, va_list adx)
 {
-        register c;
+        register int c;
         char *s;
 
 	for(;;) {
@@ -60,7 +60,7 @@
                 	putchar(va_arg(adx,unsigned), filog);
         	} else if(c == 's') {
                 	s = va_arg(adx,char*);
-               		while(c = *s++)
+               		while((c = *s++))
                         	putchar(c,filog);
        		} else if (c == 'l' || c == 'O') {
         	        printn(filog, (long)va_arg(adx,long), c=='l'?10:8);
@@ -77,10 +77,6 @@
         char prbuf[24];
         register char *cp;
 
-        if (b == 10 && n < 0) {
-                putchar('-',filog);
-                n = (~n) + 1;		/* n = -n */
-        }
         cp = prbuf;
         do
 		*cp++ = hextab[(unsigned int)(n%b)];
diff -ruN proll_18.orig/src/rconsole.c proll-patch-15/src/rconsole.c
--- proll_18.orig/src/rconsole.c	1999-01-16 07:16:55.000000000 +0000
+++ proll-patch-15/src/rconsole.c	2005-08-14 10:25:53.000000000 +0000
@@ -28,12 +28,18 @@
  * move to California. Only plain lat7 survived. 
  * I recreated lat7-1 changes in lat7-2.  --zaitcev
  */
+#ifdef ORIG
 #include "lat7_2.bm"	/* lat7_1.bm */
+#else
+#include "lat7_2_swapped.bm"	/* lat7_1.bm */
+#endif
 #define LAT7_NCHARS  128
 #define LAT7_HEIGHT   11
 #define LAT7_WIDTH     8
 
+#ifdef ORIG
 static Rf_scan lat7_body[ LAT7_NCHARS*LAT7_HEIGHT ];
+#endif
 
 #if 1
 /*
@@ -46,18 +52,18 @@
 #endif
 
 static __inline__ void stfb_w(void *ptr, unsigned int data) {
-	__asm__ __volatile__ ("sta %0, [%1] %2" : :
+	__asm__ __volatile__ ("sta %0, [%1] %2\n\t" : :
 				"r" (data), "r" (ptr), "i" (ASI_M_BYPASS));
 }
 
 static __inline__ void stfb_b(void *ptr, unsigned int data) {
-	__asm__ __volatile__ ("stba %0, [%1] %2" : :
+	__asm__ __volatile__ ("stba %0, [%1] %2\n\t" : :
 				"r" (data), "r" (ptr), "i" (ASI_M_BYPASS));
 }
 
 static __inline__ unsigned int ldfb_w(void *ptr) {
 	unsigned int data;
-	__asm__ __volatile__ ("lda [%1] %2, %0" :
+	__asm__ __volatile__ ("lda [%1] %2, %0\n\t" :
 				"=r" (data) :
 				"r" (ptr), "i" (ASI_M_BYPASS));
 	return data;
@@ -65,7 +71,7 @@
 
 static __inline__ unsigned int ldfb_b(void *ptr) {
 	unsigned int data;
-	__asm__ __volatile__ ("lduba [%1] %2, %0" :
+	__asm__ __volatile__ ("lduba [%1] %2, %0\n\t" :
 				"=r" (data) :
 				"r" (ptr), "i" (ASI_M_BYPASS));
 	return data;
@@ -94,6 +100,7 @@
 
 #endif
 
+#ifdef ORIG
 static inline int swapbits(int w0)
 {
   int w1 = 0;
@@ -105,13 +112,16 @@
   }
   return w1;
 }
+#endif
 
 void font_cons_7(struct rfont *p)
 {
+#ifdef ORIG
   int x;
   int col = 0;
   int row = 0;
   int erow = 0;
+
   for (x = 0; x < LAT7_NCHARS*LAT7_HEIGHT; x++ ) {
     lat7_body[ (erow * lat7_2_width/8 + col) * LAT7_HEIGHT + row ] =
                                             swapbits(lat7_2_bits[x]) & 0xFF;
@@ -124,6 +134,9 @@
     }
   }
   p->body_ = lat7_body;
+#else
+  p->body_ = lat7_2_bits;
+#endif
   p->nchars_ = LAT7_NCHARS;
   p->width_ = LAT7_WIDTH;
   p->height_ = LAT7_HEIGHT;
@@ -175,7 +188,7 @@
   r->render_ = p->render_;
 }
 
-void raster_dest(struct raster *r)
+void raster_dest(__attribute((unused)) struct raster *r)
 {
 }
 
diff -ruN proll_18.orig/src/rconsole.h proll-patch-15/src/rconsole.h
--- proll_18.orig/src/rconsole.h	1999-01-16 05:00:59.000000000 +0000
+++ proll-patch-15/src/rconsole.h	2004-11-13 15:50:49.000000000 +0000
@@ -13,10 +13,10 @@
  */
 
 #define RF_MAXWIDTH  16
-typedef unsigned short Rf_scan;        /*  __w16 to be used */
+typedef unsigned char Rf_scan;        /*  __w16 to be used */
 
 struct rfont {
-  Rf_scan *body_;
+  const Rf_scan *body_;
   int nchars_;                 /* 128 for ASCII ...  65536 for Unicode   */
   int width_;                  /* [Pixels]. Maximum size is 16.          */
   int height_;                 /* [Pixels == scan lines].                */
diff -ruN proll_18.orig/src/romlib.h proll-patch-15/src/romlib.h
--- proll_18.orig/src/romlib.h	1999-04-20 04:26:45.000000000 +0000
+++ proll-patch-15/src/romlib.h	2005-04-16 20:32:49.000000000 +0000
@@ -72,13 +72,13 @@
  */
 #define memcpy(dst, src, len)	bcopy(src, dst, len)
 #define memcmp(x1, x2, len)	bcmp(x1, x2, len)
-#define memset(p, len, zero)	bzero(p, len)
-extern void bcopy(void *b1, void *b2, int length);
-extern int  bcmp(void *b1, void *b2, int length);
-extern void bzero(void *b, int c);
+extern void bcopy(const void *b1, void *b2, int length);
+extern int  bcmp(const void *b1, const void *b2, int length);
+typedef unsigned int size_t;
+extern void *memset(void *p, int c, size_t len);
 /* gcc complains about "conflicting types for builtin function strlen". */
 #define strlen(s)		ssize(s)
-extern int ssize(char *s);
+extern int ssize(const char *s);
 
 
 /*
diff -ruN proll_18.orig/src/sched_4m.c proll-patch-15/src/sched_4m.c
--- proll_18.orig/src/sched_4m.c	1999-04-27 05:48:51.000000000 +0000
+++ proll-patch-15/src/sched_4m.c	2005-08-14 10:18:14.000000000 +0000
@@ -108,7 +108,7 @@
 static int set_bolt;			/* Tick counter limit */
 static struct handsc hndv[16];
 
-static unsigned int intr_to_mask[16] = {
+static unsigned const int intr_to_mask[16] = {
 	0,	0,	0,	0,	0,	0, SUN4M_INT_ETHERNET,	0,
 	0,	0,	0,	0,	0,	0,	0,	0,
 };
@@ -130,7 +130,7 @@
 int	/* 0 - not expired yet; <>0 - timer expired */
 chk_timeout()
 {
-	int lim = (((1000000/HZ) + 1) << 10);
+	unsigned int lim = (((1000000/HZ) + 1) << 10);
 	unsigned int clear;
 	unsigned int intc;
 	int n;
@@ -182,7 +182,7 @@
 	struct handsc *hndp;
 	unsigned int mask;
 
-	if (irq < 0 || irq >= 16) {
+	if (irq == 0 || irq >= 16) {
 		printk("request_irq: bad irq %d\n", irq);
 		return -1;
 	}
@@ -207,7 +207,7 @@
 {
 	struct handsc *hndp;
 
-	if (irq < 0 || irq >= 16) {
+	if (irq == 0 || irq >= 16) {
 		printk("free_irq: bad irq %d\n", irq);
 		return;
 	}
diff -ruN proll_18.orig/src/swap.c proll-patch-15/src/swap.c
--- proll_18.orig/src/swap.c	1970-01-01 00:00:00.000000000 +0000
+++ proll-patch-15/src/swap.c	2004-11-13 15:50:49.000000000 +0000
@@ -0,0 +1,21 @@
+// Convert the lat7 font so that no conversion is needed at runtime.
+#define ORIG
+#include "rconsole.c"
+
+#include <stdio.h>
+
+int main()
+{
+    struct rfont p;
+    int i;
+
+    font_cons_7(&p);
+
+    printf("   ");
+    for (i = 0; i < LAT7_NCHARS*LAT7_HEIGHT; i++) {
+	printf("0x%02x, ", p.body_[i]);
+	if ((i % 12) == 11)
+	    printf("\n   ");
+    }
+    printf("\n");
+}
diff -ruN proll_18.orig/src/system.c proll-patch-15/src/system.c
--- proll_18.orig/src/system.c	2002-07-23 05:52:49.000000000 +0000
+++ proll-patch-15/src/system.c	2005-04-16 06:16:20.000000000 +0000
@@ -298,8 +298,8 @@
 	}
 
 	/* We need to start from LOADBASE, but kernel wants PAGE_SIZE. */
-	pa = PAGE_SIZE;
-	for (va = PAGE_SIZE; va < LOWMEMSZ; va += PAGE_SIZE) {
+	pa = 0;
+	for (va = 0; va < LOWMEMSZ; va += PAGE_SIZE) {
 		map_page(l1, va, pa, 0, highbase);
 		pa += PAGE_SIZE;
 	}
@@ -507,30 +507,44 @@
 {
 	char *p;
 
-	if ((p = mem_alloc(t, size, align)) != 0) bzero(p, size);
+	if ((p = mem_alloc(t, size, align)) != 0) memset(p, 0, size);
 	return p;
 }
 
 /*
  * Library functions
  */
-void bzero(void *s, int len) {
-	while (len--) *((char *)s)++ = 0;
+void *memset(void *s, int c, size_t len)
+{
+	void *p = s;
+
+	while (len--) {
+		*(char *)s = c;
+		s++;
+	}
+	return p;
 }
 
-void bcopy(void *f, void *t, int len) {
-	while (len--) *((char *)t)++ = *((char *)f)++;
+void bcopy(const void *f, void *t, int len) {
+	while (len--) {
+		*(char *)t = *(char *)f;
+		f++;
+		t++;
+	}
 }
 
 /* Comparison is 7-bit */
-int bcmp(void *s1, void *s2, int len)
+int bcmp(const void *s1, const void *s2, int len)
 {
 	int i;
 	char ch;
 
 	while (len--) {
-		ch = *((char *)s1)++;
-		if ((i = ch - *((char *)s2)++) != 0)
+		ch = *(char *)s1;
+		i = ch - *(char *)s2;
+		s1++;
+		s2++;
+		if (i != 0)
 			return i;
 		if (ch == 0)
 			return 0;
@@ -538,8 +552,8 @@
 	return 0;
 }
 
-int strlen(char *s) {
-	char *p;
+int strlen(const char *s) {
+	const char *p;
 	for (p = s; *p != 0; p++) { }
 	return p - s;
 }
@@ -560,14 +574,6 @@
 	va_end(x1);
 }
 
-/* This is taken from x86 to be used in network kernel. Returns 15 bits. */
-short int random()
-{
-	static unsigned int seed = 151;
-	seed = (seed + 23968)*0x015A4E35 >> 1;
-	return seed & 0x7FFF;
-}
-
 void fatal()
 {
 	printk("fatal.");
diff -ruN proll_18.orig/src/system.h proll-patch-15/src/system.h
--- proll_18.orig/src/system.h	2002-09-13 21:53:32.000000000 +0000
+++ proll-patch-15/src/system.h	2005-04-16 06:16:20.000000000 +0000
@@ -16,7 +16,7 @@
 #define IOMAPSIZE (1*1024*1024) /* 1 Meg maximum: we do not map framebuffer. */
 #define NCTX_SWIFT  0x100
 
-#define MAX_BANKS      3		/* Allocation for all machines */
+#define MAX_BANKS      8		/* Allocation for all machines */
 
 #ifndef __ASSEMBLY__
 struct bank {
@@ -164,10 +164,10 @@
 
 extern __inline__ void setipl(unsigned long __orig_psr)
 {
-	__asm__ __volatile__("
-		wr	%0, 0x0, %%psr
-		nop; nop; nop
-"		: /* no outputs */
+	__asm__ __volatile__(
+		"wr	%0, 0x0, %%psr\n\t"
+		"nop; nop; nop\n\t"
+		: /* no outputs */
 		: "r" (__orig_psr)
 		: "memory", "cc");
 }
@@ -176,13 +176,13 @@
 {
 	unsigned long tmp;
 
-	__asm__ __volatile__("
-		rd	%%psr, %0
-		nop; nop; nop;		/* Sun4m + Cypress + SMP bug */
-		or	%0, %1, %0
-		wr	%0, 0x0, %%psr
-		nop; nop; nop
-"		: "=r" (tmp)
+	__asm__ __volatile__(
+		"rd	%%psr, %0\n\t"
+		"nop; nop; nop;\n\t"	/* Sun4m + Cypress + SMP bug */
+		"or	%0, %1, %0\n\t"
+		"wr	%0, 0x0, %%psr\n\t"
+		"nop; nop; nop\n\t"
+		: "=r" (tmp)
 		: "i" (PSR_PIL)
 		: "memory");
 }
@@ -191,13 +191,13 @@
 {
 	unsigned long tmp;
 
-	__asm__ __volatile__("
-		rd	%%psr, %0	
-		nop; nop; nop;		/* Sun4m + Cypress + SMP bug */
-		andn	%0, %1, %0
-		wr	%0, 0x0, %%psr
-		nop; nop; nop
-"		: "=r" (tmp)
+	__asm__ __volatile__(
+		"rd	%%psr, %0\n\t"
+		"nop; nop; nop;\n\t"	/* Sun4m + Cypress + SMP bug */
+		"andn	%0, %1, %0\n\t"
+		"wr	%0, 0x0, %%psr\n\t"
+		"nop; nop; nop\n\t"
+		: "=r" (tmp)
 		: "i" (PSR_PIL)
 		: "memory");
 }
@@ -214,18 +214,18 @@
 {
 	unsigned long retval;
 
-	__asm__ __volatile__("
-		rd	%%psr, %0
-		nop; nop; nop;		/* Sun4m + Cypress + SMP bug */
-		and	%0, %2, %%g1
-		and	%1, %2, %%g2
-		xorcc	%%g1, %%g2, %%g0
-		be	1f
-		 nop
-		wr	%0, %2, %%psr
-		nop; nop; nop;
-1:
-"		: "=r" (retval)
+	__asm__ __volatile__(
+		"rd	%%psr, %0\n\t"
+		"nop; nop; nop;\n\t"	/* Sun4m + Cypress + SMP bug */
+		"and	%0, %2, %%g1\n\t"
+		"and	%1, %2, %%g2\n\t"
+		"xorcc	%%g1, %%g2, %%g0\n\t"
+		"be	1f\n\t"
+		"nop\n\t"
+		"wr	%0, %2, %%psr\n\t"
+		"nop; nop; nop;\n\t"
+		"1:\n\t"
+		: "=r" (retval)
 		: "r" (__new_psr), "i" (PSR_PIL)
 		: "g1", "g2", "memory", "cc");
 
@@ -236,13 +236,13 @@
 {
 	unsigned long retval;
 
-	__asm__ __volatile__("
-		rd	%%psr, %0
-		nop; nop; nop;		/* Sun4m + Cypress + SMP bug */
-		or	%0, %1, %%g1
-		wr	%%g1, 0x0, %%psr
-		nop; nop; nop
-"		: "=r" (retval)
+	__asm__ __volatile__(
+		"rd	%%psr, %0\n\t"
+		"nop; nop; nop;\n\t"	/* Sun4m + Cypress + SMP bug */
+		"or	%0, %1, %%g1\n\t"
+		"wr	%%g1, 0x0, %%psr\n\t"
+		"nop; nop; nop\n\t"
+		: "=r" (retval)
 		: "i" (PSR_PIL)
 		: "g1", "memory");
 
diff -ruN proll_18.orig/src/tftp.c proll-patch-15/src/tftp.c
--- proll_18.orig/src/tftp.c	2002-09-13 21:53:34.000000000 +0000
+++ proll-patch-15/src/tftp.c	2005-08-14 10:16:15.000000000 +0000
@@ -127,7 +127,7 @@
   int len;
 
   /* Read packet with timeout */
-  len = udp_read((char *)(&inpbuf), sizeof(inpbuf), TFTP_TIMEOUT, CHR_ESC);
+  len = udp_read((char *)(&inpbuf), sizeof(inpbuf), TFTP_TIMEOUT);
   if (len == 0) {
 	printf("TFTP: Timeout\n");
 	return(ERR_TIMEOUT);
diff -ruN proll_18.orig/src/udp.c proll-patch-15/src/udp.c
--- proll_18.orig/src/udp.c	2001-12-24 05:12:53.000000000 +0000
+++ proll-patch-15/src/udp.c	2005-08-14 10:17:19.000000000 +0000
@@ -76,12 +76,9 @@
  * 
  * Open a new UDP socket.
  */
-int udp_open(daddr, source, dest)
-t_ipaddr daddr;
-int      source;
-int      dest;
+int udp_open(t_ipaddr daddr, int source, int dest)
 {
-  register unsigned char *addr;
+  const unsigned char *addr;
 
   /* Set global variables */
   usource = source;
@@ -101,16 +98,13 @@
  * 
  * IP receiver routine
  */
-static int ip_recv(buf, bufsize, addr)
-unsigned char *buf;
-int            bufsize;
-unsigned char *addr;
+static int ip_recv(unsigned char *buf, unsigned int bufsize, unsigned char *addr)
 {
   struct iphdr *ipp = ((struct iphdr *)buf);
   struct udphdr *udpp = ((struct udphdr *)(buf + IP_MIN_HSIZE));
   struct udp_pseudo psehdr;
 
-  int size;
+  unsigned int size;
   t_ipaddr dadr;
 
 #ifdef DEBUG
@@ -194,13 +188,9 @@
  * 
  * Read one packet from a UDP socket
  */
-int udp_read(buf, bufsize, timeout, abortch)
-char *buf;
-int   bufsize;
-int   timeout;
-char  abortch;
+int udp_read(char *buf, unsigned int bufsize, int timeout)
 {
-  int len;
+  unsigned int len;
 
   /* Wait until we get something */
   set_timeout(timeout);
@@ -299,9 +289,6 @@
  */
 int init_udp()
 {
-  /* Set module name for error handling */
-  net_module_name = "udp";
-
   /* Register IP packet type and set write buffer pointer */
   if ((writebuf = reg_type(htons(ETH_P_IP), ip_recv)) == NULL)
 	return(FALSE);
diff -ruN proll_18.orig/src/udp.h proll-patch-15/src/udp.h
--- proll_18.orig/src/udp.h	2001-12-24 05:12:34.000000000 +0000
+++ proll-patch-15/src/udp.h	2005-08-14 10:16:40.000000000 +0000
@@ -53,7 +53,7 @@
 extern int udp_open __P((t_ipaddr daddr, int source, int dest));
 
 /* Read from a UDP socket */
-extern int udp_read __P((char *buf, int bufsize, int timeout, char abortch));
+extern int udp_read(char *buf, unsigned int bufsize, int timeout);
 
 /* Write to a UDP socket */
 extern int udp_write __P((char *buf, int writelen));
diff -ruN proll_18.orig/src/vcons_zs.c proll-patch-15/src/vcons_zs.c
--- proll_18.orig/src/vcons_zs.c	1970-01-01 00:00:00.000000000 +0000
+++ proll-patch-15/src/vcons_zs.c	2005-08-14 10:25:51.000000000 +0000
@@ -0,0 +1,68 @@
+/**
+ ** Console over 'zs' (Zilog serial port)
+ ** Copyright 1999 Pete Zaitcev
+ ** This code is licensed under GNU General Public License.
+ **/
+
+#include "vconsole.h"
+#include <system.h>
+
+#define ZS_DATA 0x02
+
+int vcon_zs_init(struct vconterm *t, unsigned int a0)
+{
+
+	t->impl = (void *) a0;
+
+	t->vc_x = 0;    t->vc_y = 0;
+	t->backp = 0;    t->backc = 0;
+
+	stb_bypass(a0, 3); // reg 3
+	stb_bypass(a0, 1); // enable rx
+
+	stb_bypass(a0, 5); // reg 5
+	stb_bypass(a0, 8); // enable tx
+
+	return 0;
+}
+
+int vcon_zs_putch(struct vconterm *t, char c)
+{
+	unsigned zs_ptr = (unsigned) t->impl;
+
+	//while ((ldb_bypass(zs_ptr + ZS_LSR) & 0x60) != 0x60) { }
+	stb_bypass(zs_ptr + ZS_DATA, c);
+	return 0;
+}
+
+int vcon_zs_write(struct vconterm *t, char *data, int leng)
+{
+	while (leng != 0) {
+		leng--;
+		vcon_zs_putch(t, *data++);
+	}
+	return leng;
+}
+
+int vcon_zs_read(struct vconterm *t, char *data, __attribute((unused)) int leng)
+{
+	unsigned zs_ptr = (unsigned) t->impl;
+
+	while ((ldb_bypass(zs_ptr) & 1) != 1) { }
+	*data = ldb_bypass(zs_ptr + ZS_DATA);
+	return 0;
+}
+
+int vcon_zs_getch(struct vconterm *t)
+{
+	unsigned zs_ptr = (unsigned) t->impl;
+
+	while ((ldb_bypass(zs_ptr) & 1) != 1) { }
+	return ldb_bypass(zs_ptr + ZS_DATA) & 0xff;
+}
+
+void vcon_zs_fini(__attribute((unused)) struct vconterm *t)
+{
+	/* violent crash in the end */
+	;
+}
diff -ruN proll_18.orig/src/vconsole.c proll-patch-15/src/vconsole.c
--- proll_18.orig/src/vconsole.c	1999-11-08 03:10:28.000000000 +0000
+++ proll-patch-15/src/vconsole.c	2005-08-14 10:24:49.000000000 +0000
@@ -7,12 +7,17 @@
 #include "vconsole.h"
 
 #include "hconsole.h"
+#include <system.h>
 
 static void vcon_i_cursfeed(struct vconterm *t);
 static void vcon_i_backflush(struct vconterm *t);
 
 struct hconsole hcons0;
 
+enum { ESnormal, ESesc, ESsquare, ESgetpars, ESgotpars, ESfunckey,
+	EShash, ESsetG0, ESsetG1, ESpercent, ESignore, ESnonstd,
+	ESpalette };
+
 int vcon_init(struct vconterm *t, unsigned int a0)
 {
 	struct hconsole *hconp;
@@ -25,11 +30,49 @@
 
 	t->vc_x = 0;    t->vc_y = 0;
 	t->backp = 0;    t->backc = 0;
+	t->vc_state = ESnormal;
 
 	hcon_clear(hconp, 0, 0, hconp->ydim_, hconp->xdim_);
 	return 0;
 }
 
+/*
+ * gotoxy() must verify all boundaries, because the arguments
+ * might also be negative. If the given position is out of
+ * bounds, the cursor is placed at the nearest margin.
+ */
+static void gotoxy(struct vconterm *vc, int new_x, int new_y)
+{
+	int max_x, max_y;
+	struct hconsole *hconp = vc->impl;
+
+	max_x = hcon_qxdim(hconp);
+	max_y = hcon_qydim(hconp);
+
+	if (new_x < 0)
+		vc->vc_x = 0;
+	else {
+		if (new_x >= max_x)
+			vc->vc_x = max_x - 1;
+		else
+			vc->vc_x = new_x;
+	}
+
+	if (new_y < 0)
+		vc->vc_y = 0;
+	else if (new_y >= max_y)
+		vc->vc_y = max_y - 1;
+	else
+		vc->vc_y = new_y;
+
+}
+
+/* for absolute user moves, when decom is set */
+static void gotoxay(struct vconterm *t, int new_x, int new_y)
+{
+	gotoxy(t, new_x, new_y);
+}
+
 int vcon_write(struct vconterm *t, char *data, int leng)
 {
 	int l = leng;
@@ -40,29 +83,101 @@
 		if (l <= 0) break;
 		c = *data++;    --l;
 
-		switch (c) {
-		case 0x07:		/* Bell */
-			vcon_i_backflush(t);
-			break;
-		case 0x0A:		/* Linefeed */
-			vcon_i_backflush(t);
-			vcon_i_cursfeed(t);
+		switch(t->vc_state) {
+		case ESesc:
+			t->vc_state = ESnormal;
+			switch (c) {
+			case '[':
+				t->vc_state = ESsquare;
+				break;
+			case 'M':
+				hcon_scroll(hconp, 0, hcon_qydim(hconp), SM_UP, 1);
+				break;
+			default:
+			        //printk("Unhandled escape code '%c'\n", c);
+				break;
+			}
 			break;
-		case 0x0D:		/* Return */
-			vcon_i_backflush(t);
-			t->vc_x = 0;
+		case ESsquare:
+			for(t->vc_npar = 0 ; t->vc_npar < NPAR ; t->vc_npar++)
+				t->vc_par[t->vc_npar] = 0;
+			t->vc_npar = 0;
+			t->vc_state = ESgetpars;
+		case ESgetpars:
+			if (c==';' && t->vc_npar<NPAR-1) {
+				t->vc_npar++;
+				break;
+			} else if (c>='0' && c<='9') {
+				t->vc_par[t->vc_npar] *= 10;
+				t->vc_par[t->vc_npar] += c-'0';
+				break;
+			} else t->vc_state=ESgotpars;
+		case ESgotpars:
+			t->vc_state = ESnormal;
+			switch(c) {
+			case 'H': case 'f':
+				if (t->vc_par[0]) t->vc_par[0]--;
+				if (t->vc_par[1]) t->vc_par[1]--;
+				gotoxay(t, t->vc_par[1], t->vc_par[0]);
+				break;
+			case 'J':
+				if (t->vc_par[0] == 0) {
+					//erase from cursor to end of display
+					hcon_clear(hconp, t->vc_y, t->vc_x, hconp->ydim_, hconp->xdim_);
+				}
+				break;
+			case 'M':
+				hcon_scroll(hconp, 0, hcon_qydim(hconp), SM_UP, 1);
+				break;
+			case 'm':
+				break;
+			default:
+#if 0
+			        printk("Unhandled escape code '%c', par[%d, %d, %d, %d, %d]\n",
+				   c, t->vc_par[0], t->vc_par[1], t->vc_par[2], t->vc_par[3], t->vc_par[4]);
+#endif
+				break;
+			}
 			break;
 		default:
-			if (t->backp == 0) {
-				t->backc = 1;
-				t->backp = data-1;
-			} else {
-				t->backc++;
-			}
-			if (t->vc_x + t->backc >= hcon_qxdim(hconp)) {
+			t->vc_state = ESnormal;
+			switch (c) {
+			case 0x07:		/* Bell */
+				vcon_i_backflush(t);
+				break;
+			case 0x08:		/* BS */
+				vcon_i_backflush(t);
+				if (t->vc_x > 0)
+					t->vc_x--;
+				break;
+			case 0x0A:		/* Linefeed */
 				vcon_i_backflush(t);
-				t->vc_x = 0;
 				vcon_i_cursfeed(t);
+				break;
+			case 0x0D:		/* Return */
+				vcon_i_backflush(t);
+				t->vc_x = 0;
+				break;
+			case 24: case 26:
+				vcon_i_backflush(t);
+				t->vc_state = ESnormal;
+				break;
+			case 27:
+				vcon_i_backflush(t);
+				t->vc_state = ESesc;
+				break;
+			default:
+				if (t->backp == 0) {
+					t->backc = 1;
+					t->backp = data-1;
+				} else {
+					t->backc++;
+				}
+				if ((unsigned int)t->vc_x + t->backc >= hcon_qxdim(hconp)) {
+					vcon_i_backflush(t);
+					t->vc_x = 0;
+					vcon_i_cursfeed(t);
+				}
 			}
 		}
 	}
@@ -73,7 +188,7 @@
 static void vcon_i_cursfeed(struct vconterm *t) {
 	struct hconsole *hconp = t->impl;
 
-	if (++t->vc_y >= hcon_qydim(hconp)) {
+	if ((unsigned int)++t->vc_y >= hcon_qydim(hconp)) {
 		t->vc_y = hcon_qydim(hconp)-1;
 		hcon_scroll(hconp, 0, hcon_qydim(hconp), SM_UP, 1);
 	}
@@ -90,22 +205,75 @@
 	t->backp = 0;    t->backc = 0;
 }
 
-int vcon_putch(struct vconterm *t, char c)
+int vcon_putch(__attribute__((unused)) struct vconterm *t, __attribute__((unused)) char c)
 {
 	return -1;
 }
 
-int vcon_read(struct vconterm *t, char *data, int leng)
+int vcon_read(__attribute__((unused)) struct vconterm *t, __attribute__((unused)) char *data, __attribute__((unused)) int leng)
 {
 	return 0;
 }
 
-int vcon_getch(struct vconterm *t)
+static const unsigned char sunkbd_keycode[128] = {
+    0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0,
+    0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0,
+    '1', '2', '3', '4', '5', '6', '7', '8', '9', '0', '-', '=', 0, 8,
+    0, 0, 0, 0, 0, 0, 0, 0, 0, 9,
+    'q', 'w', 'e', 'r', 't', 'y', 'u', 'i', 'o', 'p', '[', ']',
+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+    'a', 's', 'd', 'f', 'g', 'h', 'j', 'k', 'l', ';', '\'', '\\', 13,
+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+    'z', 'x', 'c', 'v', 'b', 'n', 'm', ',', '.', '/',
+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+    ' ',
+};
+
+static const unsigned char sunkbd_keycode_shifted[128] = {
+    0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0,
+    0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0,
+    '!', '@', '#', '$', '%', '^', '&', '*', '(', ')', '_', '+', 0, 8,
+    0, 0, 0, 0, 0, 0, 0, 0, 0, 9,
+    'Q', 'W', 'E', 'R', 'T', 'Y', 'U', 'I', 'O', 'P', '{', '}',
+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+    'A', 'S', 'D', 'F', 'G', 'H', 'J', 'K', 'L', ':', '"', '|', 13,
+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+    'Z', 'X', 'C', 'V', 'B', 'N', 'M', '<', '>', '?',
+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+    ' ',
+};
+
+static int shiftstate;
+
+int vcon_getch(__attribute__((unused)) struct vconterm *t)
 {
-	return -1;
+        int ch;
+
+	while ((ldb_bypass(0x71000004) & 1) != 1) { }
+	do {
+	    ch = ldb_bypass(0x71000006) & 0xff;
+	    if (ch == 99)
+		shiftstate |= 1;
+	    else if (ch == 110)
+		shiftstate |= 2;
+	    else if (ch == 227)
+		shiftstate &= ~1;
+	    else if (ch == 238)
+		shiftstate &= ~2;
+	    //printk("getch: %d\n", ch);
+	}
+	while ((ch & 0x80) == 0 || ch == 238 || ch == 227); // Wait for key release
+	//printk("getch rel: %d\n", ch);
+	ch &= 0x7f;
+	if (shiftstate)
+	    ch = sunkbd_keycode_shifted[ch];
+	else
+	    ch = sunkbd_keycode[ch];
+	//printk("getch xlate: %d\n", ch);
+	return ch;
 }
 
-void vcon_fini(struct vconterm *t)
+void vcon_fini(__attribute__((unused)) struct vconterm *t)
 {
 	/* violent crash in the end */
 	;
diff -ruN proll_18.orig/src/vconsole.h proll-patch-15/src/vconsole.h
--- proll_18.orig/src/vconsole.h	1999-11-08 00:58:13.000000000 +0000
+++ proll-patch-15/src/vconsole.h	2005-03-02 12:40:12.000000000 +0000
@@ -6,6 +6,8 @@
 #ifndef VCONSOLE_H
 #define VCONSOLE_H
 
+#define NPAR 16
+
 struct vconterm {
 	void *impl;
 
@@ -13,6 +15,8 @@
 	int backc;		/* Same, count */
 
 	int vc_x, vc_y;		/* XXX Make vcon_xxx() to use cellmap->xpos_ */
+	int vc_state;
+	unsigned int	vc_npar,vc_par[NPAR];	/* Parameters of current escape sequence */
 };
 
 int vcon_init(struct vconterm *t, unsigned int a0);
